/*! For license information please see ark-sdk-bundle.js.LICENSE.txt */
!function(n,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.ArkSDK=e():n.ArkSDK=e()}(this,()=>(()=>{var __webpack_modules__={"./node_modules/@arkade-os/sdk/dist/cjs/arknote/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ArkNote = void 0;\nconst base_1 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nconst base_2 = __webpack_require__(/*! ../script/base */ "./node_modules/@arkade-os/sdk/dist/cjs/script/base.js");\nconst utils_1 = __webpack_require__(/*! @scure/btc-signer/utils */ "./node_modules/@scure/btc-signer/utils.js");\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\n/**\n * ArkNotes are special virtual coins in the Ark protocol that can be created\n * and spent without requiring any transactions. The server mints them, and they\n * are encoded as base58 strings with a human-readable prefix. It contains a\n * preimage and value.\n *\n * @example\n * ```typescript\n * // Create an ArkNote\n * const note = new ArkNote(preimage, 50000);\n *\n * // Encode to string\n * const noteString = note.toString();\n *\n * // Decode from string\n * const decodedNote = ArkNote.fromString(noteString);\n * ```\n */\nclass ArkNote {\n    constructor(preimage, value, HRP = ArkNote.DefaultHRP) {\n        this.preimage = preimage;\n        this.value = value;\n        this.HRP = HRP;\n        this.vout = 0;\n        const preimageHash = (0, utils_1.sha256)(this.preimage);\n        this.vtxoScript = new base_2.VtxoScript([noteTapscript(preimageHash)]);\n        const leaf = this.vtxoScript.leaves[0];\n        this.txid = base_1.hex.encode(new Uint8Array(preimageHash).reverse());\n        this.tapTree = this.vtxoScript.encode();\n        this.forfeitTapLeafScript = leaf;\n        this.intentTapLeafScript = leaf;\n        this.value = value;\n        this.status = { confirmed: true };\n        this.extraWitness = [this.preimage];\n    }\n    encode() {\n        const result = new Uint8Array(ArkNote.Length);\n        result.set(this.preimage, 0);\n        writeUInt32BE(result, this.value, this.preimage.length);\n        return result;\n    }\n    static decode(data, hrp = ArkNote.DefaultHRP) {\n        if (data.length !== ArkNote.Length) {\n            throw new Error(`invalid data length: expected ${ArkNote.Length} bytes, got ${data.length}`);\n        }\n        const preimage = data.subarray(0, ArkNote.PreimageLength);\n        const value = readUInt32BE(data, ArkNote.PreimageLength);\n        return new ArkNote(preimage, value, hrp);\n    }\n    static fromString(noteStr, hrp = ArkNote.DefaultHRP) {\n        noteStr = noteStr.trim();\n        if (!noteStr.startsWith(hrp)) {\n            throw new Error(`invalid human-readable part: expected ${hrp} prefix (note \'${noteStr}\')`);\n        }\n        const encoded = noteStr.slice(hrp.length);\n        const decoded = base_1.base58.decode(encoded);\n        if (decoded.length === 0) {\n            throw new Error("failed to decode base58 string");\n        }\n        return ArkNote.decode(decoded, hrp);\n    }\n    toString() {\n        return this.HRP + base_1.base58.encode(this.encode());\n    }\n}\nexports.ArkNote = ArkNote;\nArkNote.DefaultHRP = "arknote";\nArkNote.PreimageLength = 32; // 32 bytes for the preimage\nArkNote.ValueLength = 4; // 4 bytes for the value\nArkNote.Length = ArkNote.PreimageLength + ArkNote.ValueLength;\nArkNote.FakeOutpointIndex = 0;\nfunction writeUInt32BE(array, value, offset) {\n    const view = new DataView(array.buffer, array.byteOffset + offset, 4);\n    view.setUint32(0, value, false);\n}\nfunction readUInt32BE(array, offset) {\n    const view = new DataView(array.buffer, array.byteOffset + offset, 4);\n    return view.getUint32(0, false);\n}\nfunction noteTapscript(preimageHash) {\n    return btc_signer_1.Script.encode(["SHA256", preimageHash, "EQUAL"]);\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/arknote/index.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/bip322/errors.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ErrMissingWitnessUtxo = exports.ErrMissingData = exports.ErrMissingInputs = exports.BIP322Error = void 0;\nclass BIP322Error extends Error {\n    constructor(message) {\n        super(message);\n        this.name = "BIP322Error";\n    }\n}\nexports.BIP322Error = BIP322Error;\nexports.ErrMissingInputs = new BIP322Error("missing inputs");\nexports.ErrMissingData = new BIP322Error("missing data");\nexports.ErrMissingWitnessUtxo = new BIP322Error("missing witness utxo");\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/bip322/errors.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/bip322/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.BIP322 = void 0;\nexports.craftToSpendTx = craftToSpendTx;\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\nconst errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/@arkade-os/sdk/dist/cjs/bip322/errors.js");\nconst secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ "./node_modules/@noble/curves/secp256k1.js");\nconst base_1 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\n/**\n * BIP-322 signature implementation for Bitcoin message signing.\n *\n * BIP-322 defines a standard for signing Bitcoin messages as well as proving\n * ownership of coins. This namespace provides utilities for creating and\n * validating BIP-322.\n *\n * @see https://github.com/bitcoin/bips/blob/master/bip-0322.mediawiki\n *\n * @example\n * ```typescript\n * // Create a BIP-322 proof\n * const proof = BIP322.create(\n *   "Hello Bitcoin!",\n *   [input],\n *   [output]\n * );\n *\n * // Sign the proof\n * const signedProof = await identity.sign(proof);\n *\n * // Extract the signature\n * const signature = BIP322.signature(signedProof);\n * ```\n */\nvar BIP322;\n(function (BIP322) {\n    /**\n     * Creates a new BIP-322 "full" proof of funds unsigned transaction.\n     *\n     * This function constructs a special transaction that can be signed to prove\n     * ownership of VTXOs and UTXOs. The proof includes the message to be\n     * signed and the inputs/outputs that demonstrate ownership.\n     *\n     * @param message - The BIP-322 message to be signed\n     * @param inputs - Array of transaction inputs to prove ownership of\n     * @param outputs - Optional array of transaction outputs\n     * @returns An unsigned BIP-322 proof transaction\n     */\n    function create(message, inputs, outputs = []) {\n        if (inputs.length == 0)\n            throw errors_1.ErrMissingInputs;\n        if (!validateInputs(inputs))\n            throw errors_1.ErrMissingData;\n        if (!validateOutputs(outputs))\n            throw errors_1.ErrMissingData;\n        // create the initial transaction to spend\n        const toSpend = craftToSpendTx(message, inputs[0].witnessUtxo.script);\n        // create the transaction to sign\n        return craftToSignTx(toSpend, inputs, outputs);\n    }\n    BIP322.create = create;\n    /**\n     * Finalizes and extracts the FullProof transaction into a BIP-322 signature.\n     *\n     * This function takes a signed proof transaction and converts it into a\n     * base64-encoded signature string. If the proof\'s inputs have special\n     * spending conditions, a custom finalizer can be provided.\n     *\n     * @param signedProof - The signed BIP-322 proof transaction\n     * @param finalizer - Optional custom finalizer function\n     * @returns Base64-encoded BIP-322 signature\n     */\n    function signature(signedProof, finalizer = (tx) => tx.finalize()) {\n        finalizer(signedProof);\n        return base_1.base64.encode(signedProof.extract());\n    }\n    BIP322.signature = signature;\n})(BIP322 || (exports.BIP322 = BIP322 = {}));\nconst OP_RETURN_EMPTY_PKSCRIPT = new Uint8Array([btc_signer_1.OP.RETURN]);\nconst ZERO_32 = new Uint8Array(32).fill(0);\nconst MAX_INDEX = 0xffffffff;\nconst TAG_BIP322 = "BIP0322-signed-message";\nfunction validateInput(input) {\n    if (input.index === undefined)\n        throw errors_1.ErrMissingData;\n    if (input.txid === undefined)\n        throw errors_1.ErrMissingData;\n    if (input.witnessUtxo === undefined)\n        throw errors_1.ErrMissingWitnessUtxo;\n    return true;\n}\nfunction validateInputs(inputs) {\n    inputs.forEach(validateInput);\n    return true;\n}\nfunction validateOutput(output) {\n    if (output.amount === undefined)\n        throw errors_1.ErrMissingData;\n    if (output.script === undefined)\n        throw errors_1.ErrMissingData;\n    return true;\n}\nfunction validateOutputs(outputs) {\n    outputs.forEach(validateOutput);\n    return true;\n}\n// craftToSpendTx creates the initial transaction that will be spent in the proof\nfunction craftToSpendTx(message, pkScript) {\n    const messageHash = hashMessage(message);\n    const tx = new btc_signer_1.Transaction({\n        version: 0,\n        allowUnknownOutputs: true,\n        allowUnknown: true,\n        allowUnknownInputs: true,\n    });\n    // add input with zero hash and max index\n    tx.addInput({\n        txid: ZERO_32, // zero hash\n        index: MAX_INDEX,\n        sequence: 0,\n    });\n    // add output with zero value and provided pkScript\n    tx.addOutput({\n        amount: 0n,\n        script: pkScript,\n    });\n    tx.updateInput(0, {\n        finalScriptSig: btc_signer_1.Script.encode(["OP_0", messageHash]),\n    });\n    return tx;\n}\n// craftToSignTx creates the transaction that will be signed for the proof\nfunction craftToSignTx(toSpend, inputs, outputs) {\n    const firstInput = inputs[0];\n    const tx = new btc_signer_1.Transaction({\n        version: 2,\n        allowUnknownOutputs: outputs.length === 0,\n        allowUnknown: true,\n        allowUnknownInputs: true,\n        lockTime: 0,\n    });\n    // add the first "toSpend" input\n    tx.addInput({\n        ...firstInput,\n        txid: toSpend.id,\n        index: 0,\n        witnessUtxo: {\n            script: firstInput.witnessUtxo.script,\n            amount: 0n,\n        },\n        sighashType: btc_signer_1.SigHash.ALL,\n    });\n    // add other inputs\n    for (const input of inputs) {\n        tx.addInput({\n            ...input,\n            sighashType: btc_signer_1.SigHash.ALL,\n        });\n    }\n    // add the special OP_RETURN output if no outputs are provided\n    if (outputs.length === 0) {\n        outputs = [\n            {\n                amount: 0n,\n                script: OP_RETURN_EMPTY_PKSCRIPT,\n            },\n        ];\n    }\n    for (const output of outputs) {\n        tx.addOutput({\n            amount: output.amount,\n            script: output.script,\n        });\n    }\n    return tx;\n}\nfunction hashMessage(message) {\n    return secp256k1_1.schnorr.utils.taggedHash(TAG_BIP322, new TextEncoder().encode(message));\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/bip322/index.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/forfeit.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.buildForfeitTx = buildForfeitTx;\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\nconst anchor_1 = __webpack_require__(/*! ./utils/anchor */ "./node_modules/@arkade-os/sdk/dist/cjs/utils/anchor.js");\nfunction buildForfeitTx(inputs, forfeitPkScript, txLocktime) {\n    const tx = new btc_signer_1.Transaction({\n        version: 3,\n        lockTime: txLocktime,\n    });\n    let amount = 0n;\n    for (const input of inputs) {\n        if (!input.witnessUtxo) {\n            throw new Error("input needs witness utxo");\n        }\n        amount += input.witnessUtxo.amount;\n        tx.addInput(input);\n    }\n    // Add main output to server\n    tx.addOutput({\n        script: forfeitPkScript,\n        amount,\n    });\n    // Add P2A output\n    tx.addOutput(anchor_1.P2A);\n    return tx;\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/forfeit.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/identity/singleKey.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.SingleKey = void 0;\nconst utils_1 = __webpack_require__(/*! @scure/btc-signer/utils */ "./node_modules/@scure/btc-signer/utils.js");\nconst base_1 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\nconst signingSession_1 = __webpack_require__(/*! ../tree/signingSession */ "./node_modules/@arkade-os/sdk/dist/cjs/tree/signingSession.js");\nconst ZERO_32 = new Uint8Array(32).fill(0);\nconst ALL_SIGHASH = Object.values(btc_signer_1.SigHash).filter((x) => typeof x === "number");\n/**\n * In-memory single key implementation for Bitcoin transaction signing.\n *\n * @example\n * ```typescript\n * // Create from hex string\n * const key = SingleKey.fromHex(\'your_private_key_hex\');\n *\n * // Create from raw bytes\n * const key = SingleKey.fromPrivateKey(privateKeyBytes);\n *\n * // Sign a transaction\n * const signedTx = await key.sign(transaction);\n * ```\n */\nclass SingleKey {\n    constructor(key) {\n        this.key = key || (0, utils_1.randomPrivateKeyBytes)();\n    }\n    static fromPrivateKey(privateKey) {\n        return new SingleKey(privateKey);\n    }\n    static fromHex(privateKeyHex) {\n        return new SingleKey(base_1.hex.decode(privateKeyHex));\n    }\n    async sign(tx, inputIndexes) {\n        const txCpy = tx.clone();\n        if (!inputIndexes) {\n            try {\n                if (!txCpy.sign(this.key, ALL_SIGHASH, ZERO_32)) {\n                    throw new Error("Failed to sign transaction");\n                }\n            }\n            catch (e) {\n                if (e instanceof Error &&\n                    e.message.includes("No inputs signed")) {\n                    // ignore\n                }\n                else {\n                    throw e;\n                }\n            }\n            return txCpy;\n        }\n        for (const inputIndex of inputIndexes) {\n            if (!txCpy.signIdx(this.key, inputIndex, ALL_SIGHASH, ZERO_32)) {\n                throw new Error(`Failed to sign input #${inputIndex}`);\n            }\n        }\n        return txCpy;\n    }\n    xOnlyPublicKey() {\n        return (0, utils_1.pubSchnorr)(this.key);\n    }\n    signerSession() {\n        return signingSession_1.TreeSignerSession.random();\n    }\n}\nexports.SingleKey = SingleKey;\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/identity/singleKey.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Transaction = exports.Unroll = exports.P2A = exports.TxTree = exports.BIP322 = exports.IndexedDBVtxoRepository = exports.networks = exports.ArkNote = exports.waitForIncomingFunds = exports.buildOffchainTx = exports.ConditionWitness = exports.VtxoTaprootTree = exports.VtxoTreeExpiry = exports.CosignerPublicKey = exports.getArkPsbtFields = exports.setArkPsbtField = exports.ArkPsbtFieldKeyType = exports.ArkPsbtFieldKey = exports.CLTVMultisigTapscript = exports.ConditionMultisigTapscript = exports.ConditionCSVMultisigTapscript = exports.CSVMultisigTapscript = exports.MultisigTapscript = exports.decodeTapscript = exports.Response = exports.Request = exports.ServiceWorkerWallet = exports.Worker = exports.setupServiceWorker = exports.SettlementEventType = exports.ChainTxType = exports.IndexerTxType = exports.TxType = exports.VHTLC = exports.VtxoScript = exports.DefaultVtxo = exports.ArkAddress = exports.RestIndexerProvider = exports.RestArkProvider = exports.EsploraProvider = exports.ESPLORA_URL = exports.Ramps = exports.OnchainWallet = exports.SingleKey = exports.Wallet = void 0;\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\nObject.defineProperty(exports, "Transaction", ({ enumerable: true, get: function () { return btc_signer_1.Transaction; } }));\nconst singleKey_1 = __webpack_require__(/*! ./identity/singleKey */ "./node_modules/@arkade-os/sdk/dist/cjs/identity/singleKey.js");\nObject.defineProperty(exports, "SingleKey", ({ enumerable: true, get: function () { return singleKey_1.SingleKey; } }));\nconst address_1 = __webpack_require__(/*! ./script/address */ "./node_modules/@arkade-os/sdk/dist/cjs/script/address.js");\nObject.defineProperty(exports, "ArkAddress", ({ enumerable: true, get: function () { return address_1.ArkAddress; } }));\nconst vhtlc_1 = __webpack_require__(/*! ./script/vhtlc */ "./node_modules/@arkade-os/sdk/dist/cjs/script/vhtlc.js");\nObject.defineProperty(exports, "VHTLC", ({ enumerable: true, get: function () { return vhtlc_1.VHTLC; } }));\nconst default_1 = __webpack_require__(/*! ./script/default */ "./node_modules/@arkade-os/sdk/dist/cjs/script/default.js");\nObject.defineProperty(exports, "DefaultVtxo", ({ enumerable: true, get: function () { return default_1.DefaultVtxo; } }));\nconst base_1 = __webpack_require__(/*! ./script/base */ "./node_modules/@arkade-os/sdk/dist/cjs/script/base.js");\nObject.defineProperty(exports, "VtxoScript", ({ enumerable: true, get: function () { return base_1.VtxoScript; } }));\nconst wallet_1 = __webpack_require__(/*! ./wallet */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/index.js");\nObject.defineProperty(exports, "TxType", ({ enumerable: true, get: function () { return wallet_1.TxType; } }));\nconst wallet_2 = __webpack_require__(/*! ./wallet/wallet */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/wallet.js");\nObject.defineProperty(exports, "Wallet", ({ enumerable: true, get: function () { return wallet_2.Wallet; } }));\nObject.defineProperty(exports, "waitForIncomingFunds", ({ enumerable: true, get: function () { return wallet_2.waitForIncomingFunds; } }));\nconst txTree_1 = __webpack_require__(/*! ./tree/txTree */ "./node_modules/@arkade-os/sdk/dist/cjs/tree/txTree.js");\nObject.defineProperty(exports, "TxTree", ({ enumerable: true, get: function () { return txTree_1.TxTree; } }));\nconst ramps_1 = __webpack_require__(/*! ./wallet/ramps */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/ramps.js");\nObject.defineProperty(exports, "Ramps", ({ enumerable: true, get: function () { return ramps_1.Ramps; } }));\nconst wallet_3 = __webpack_require__(/*! ./wallet/serviceWorker/wallet */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/wallet.js");\nObject.defineProperty(exports, "ServiceWorkerWallet", ({ enumerable: true, get: function () { return wallet_3.ServiceWorkerWallet; } }));\nconst onchain_1 = __webpack_require__(/*! ./wallet/onchain */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/onchain.js");\nObject.defineProperty(exports, "OnchainWallet", ({ enumerable: true, get: function () { return onchain_1.OnchainWallet; } }));\nconst utils_1 = __webpack_require__(/*! ./wallet/serviceWorker/utils */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/utils.js");\nObject.defineProperty(exports, "setupServiceWorker", ({ enumerable: true, get: function () { return utils_1.setupServiceWorker; } }));\nconst worker_1 = __webpack_require__(/*! ./wallet/serviceWorker/worker */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/worker.js");\nObject.defineProperty(exports, "Worker", ({ enumerable: true, get: function () { return worker_1.Worker; } }));\nconst request_1 = __webpack_require__(/*! ./wallet/serviceWorker/request */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/request.js");\nObject.defineProperty(exports, "Request", ({ enumerable: true, get: function () { return request_1.Request; } }));\nconst response_1 = __webpack_require__(/*! ./wallet/serviceWorker/response */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/response.js");\nObject.defineProperty(exports, "Response", ({ enumerable: true, get: function () { return response_1.Response; } }));\nconst onchain_2 = __webpack_require__(/*! ./providers/onchain */ "./node_modules/@arkade-os/sdk/dist/cjs/providers/onchain.js");\nObject.defineProperty(exports, "ESPLORA_URL", ({ enumerable: true, get: function () { return onchain_2.ESPLORA_URL; } }));\nObject.defineProperty(exports, "EsploraProvider", ({ enumerable: true, get: function () { return onchain_2.EsploraProvider; } }));\nconst ark_1 = __webpack_require__(/*! ./providers/ark */ "./node_modules/@arkade-os/sdk/dist/cjs/providers/ark.js");\nObject.defineProperty(exports, "RestArkProvider", ({ enumerable: true, get: function () { return ark_1.RestArkProvider; } }));\nObject.defineProperty(exports, "SettlementEventType", ({ enumerable: true, get: function () { return ark_1.SettlementEventType; } }));\nconst tapscript_1 = __webpack_require__(/*! ./script/tapscript */ "./node_modules/@arkade-os/sdk/dist/cjs/script/tapscript.js");\nObject.defineProperty(exports, "CLTVMultisigTapscript", ({ enumerable: true, get: function () { return tapscript_1.CLTVMultisigTapscript; } }));\nObject.defineProperty(exports, "ConditionCSVMultisigTapscript", ({ enumerable: true, get: function () { return tapscript_1.ConditionCSVMultisigTapscript; } }));\nObject.defineProperty(exports, "ConditionMultisigTapscript", ({ enumerable: true, get: function () { return tapscript_1.ConditionMultisigTapscript; } }));\nObject.defineProperty(exports, "CSVMultisigTapscript", ({ enumerable: true, get: function () { return tapscript_1.CSVMultisigTapscript; } }));\nObject.defineProperty(exports, "decodeTapscript", ({ enumerable: true, get: function () { return tapscript_1.decodeTapscript; } }));\nObject.defineProperty(exports, "MultisigTapscript", ({ enumerable: true, get: function () { return tapscript_1.MultisigTapscript; } }));\nconst arkTransaction_1 = __webpack_require__(/*! ./utils/arkTransaction */ "./node_modules/@arkade-os/sdk/dist/cjs/utils/arkTransaction.js");\nObject.defineProperty(exports, "buildOffchainTx", ({ enumerable: true, get: function () { return arkTransaction_1.buildOffchainTx; } }));\nconst unknownFields_1 = __webpack_require__(/*! ./utils/unknownFields */ "./node_modules/@arkade-os/sdk/dist/cjs/utils/unknownFields.js");\nObject.defineProperty(exports, "VtxoTaprootTree", ({ enumerable: true, get: function () { return unknownFields_1.VtxoTaprootTree; } }));\nObject.defineProperty(exports, "ConditionWitness", ({ enumerable: true, get: function () { return unknownFields_1.ConditionWitness; } }));\nObject.defineProperty(exports, "getArkPsbtFields", ({ enumerable: true, get: function () { return unknownFields_1.getArkPsbtFields; } }));\nObject.defineProperty(exports, "setArkPsbtField", ({ enumerable: true, get: function () { return unknownFields_1.setArkPsbtField; } }));\nObject.defineProperty(exports, "ArkPsbtFieldKey", ({ enumerable: true, get: function () { return unknownFields_1.ArkPsbtFieldKey; } }));\nObject.defineProperty(exports, "ArkPsbtFieldKeyType", ({ enumerable: true, get: function () { return unknownFields_1.ArkPsbtFieldKeyType; } }));\nObject.defineProperty(exports, "CosignerPublicKey", ({ enumerable: true, get: function () { return unknownFields_1.CosignerPublicKey; } }));\nObject.defineProperty(exports, "VtxoTreeExpiry", ({ enumerable: true, get: function () { return unknownFields_1.VtxoTreeExpiry; } }));\nconst bip322_1 = __webpack_require__(/*! ./bip322 */ "./node_modules/@arkade-os/sdk/dist/cjs/bip322/index.js");\nObject.defineProperty(exports, "BIP322", ({ enumerable: true, get: function () { return bip322_1.BIP322; } }));\nconst arknote_1 = __webpack_require__(/*! ./arknote */ "./node_modules/@arkade-os/sdk/dist/cjs/arknote/index.js");\nObject.defineProperty(exports, "ArkNote", ({ enumerable: true, get: function () { return arknote_1.ArkNote; } }));\nconst idb_1 = __webpack_require__(/*! ./wallet/serviceWorker/db/vtxo/idb */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/db/vtxo/idb.js");\nObject.defineProperty(exports, "IndexedDBVtxoRepository", ({ enumerable: true, get: function () { return idb_1.IndexedDBVtxoRepository; } }));\nconst networks_1 = __webpack_require__(/*! ./networks */ "./node_modules/@arkade-os/sdk/dist/cjs/networks.js");\nObject.defineProperty(exports, "networks", ({ enumerable: true, get: function () { return networks_1.networks; } }));\nconst indexer_1 = __webpack_require__(/*! ./providers/indexer */ "./node_modules/@arkade-os/sdk/dist/cjs/providers/indexer.js");\nObject.defineProperty(exports, "RestIndexerProvider", ({ enumerable: true, get: function () { return indexer_1.RestIndexerProvider; } }));\nObject.defineProperty(exports, "IndexerTxType", ({ enumerable: true, get: function () { return indexer_1.IndexerTxType; } }));\nObject.defineProperty(exports, "ChainTxType", ({ enumerable: true, get: function () { return indexer_1.ChainTxType; } }));\nconst anchor_1 = __webpack_require__(/*! ./utils/anchor */ "./node_modules/@arkade-os/sdk/dist/cjs/utils/anchor.js");\nObject.defineProperty(exports, "P2A", ({ enumerable: true, get: function () { return anchor_1.P2A; } }));\nconst unroll_1 = __webpack_require__(/*! ./wallet/unroll */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/unroll.js");\nObject.defineProperty(exports, "Unroll", ({ enumerable: true, get: function () { return unroll_1.Unroll; } }));\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/index.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/musig2/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.aggregateKeys = exports.sign = exports.PartialSig = exports.generateNonces = void 0;\nvar nonces_1 = __webpack_require__(/*! ./nonces */ "./node_modules/@arkade-os/sdk/dist/cjs/musig2/nonces.js");\nObject.defineProperty(exports, "generateNonces", ({ enumerable: true, get: function () { return nonces_1.generateNonces; } }));\nvar sign_1 = __webpack_require__(/*! ./sign */ "./node_modules/@arkade-os/sdk/dist/cjs/musig2/sign.js");\nObject.defineProperty(exports, "PartialSig", ({ enumerable: true, get: function () { return sign_1.PartialSig; } }));\nObject.defineProperty(exports, "sign", ({ enumerable: true, get: function () { return sign_1.sign; } }));\nvar keys_1 = __webpack_require__(/*! ./keys */ "./node_modules/@arkade-os/sdk/dist/cjs/musig2/keys.js");\nObject.defineProperty(exports, "aggregateKeys", ({ enumerable: true, get: function () { return keys_1.aggregateKeys; } }));\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/musig2/index.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/musig2/keys.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.aggregateKeys = aggregateKeys;\nconst musig = __importStar(__webpack_require__(/*! @scure/btc-signer/musig2 */ "./node_modules/@scure/btc-signer/musig2.js"));\nconst secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ "./node_modules/@noble/curves/secp256k1.js");\n// Aggregates multiple public keys according to the MuSig2 algorithm\nfunction aggregateKeys(publicKeys, sort, options = {}) {\n    if (sort) {\n        publicKeys = musig.sortKeys(publicKeys);\n    }\n    const { aggPublicKey: preTweakedKey } = musig.keyAggregate(publicKeys);\n    if (!options.taprootTweak) {\n        return {\n            preTweakedKey: preTweakedKey.toRawBytes(true),\n            finalKey: preTweakedKey.toRawBytes(true),\n        };\n    }\n    const tweakBytes = secp256k1_1.schnorr.utils.taggedHash("TapTweak", preTweakedKey.toRawBytes(true).subarray(1), options.taprootTweak ?? new Uint8Array(0));\n    const { aggPublicKey: finalKey } = musig.keyAggregate(publicKeys, [tweakBytes], [true]);\n    return {\n        preTweakedKey: preTweakedKey.toRawBytes(true),\n        finalKey: finalKey.toRawBytes(true),\n    };\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/musig2/keys.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/musig2/nonces.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.generateNonces = generateNonces;\nconst musig = __importStar(__webpack_require__(/*! @scure/btc-signer/musig2 */ "./node_modules/@scure/btc-signer/musig2.js"));\n/**\n * Generates a pair of public and secret nonces for MuSig2 signing\n */\nfunction generateNonces(publicKey) {\n    const nonces = musig.nonceGen(publicKey);\n    return { secNonce: nonces.secret, pubNonce: nonces.public };\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/musig2/nonces.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/musig2/sign.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.PartialSig = exports.PartialSignatureError = void 0;\nexports.sign = sign;\nconst musig = __importStar(__webpack_require__(/*! @scure/btc-signer/musig2 */ "./node_modules/@scure/btc-signer/musig2.js"));\nconst utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ "./node_modules/@noble/curves/abstract/utils.js");\nconst secp256k1_1 = __webpack_require__(/*! @noble/secp256k1 */ "./node_modules/@noble/secp256k1/index.js");\nconst keys_1 = __webpack_require__(/*! ./keys */ "./node_modules/@arkade-os/sdk/dist/cjs/musig2/keys.js");\nconst secp256k1_2 = __webpack_require__(/*! @noble/curves/secp256k1 */ "./node_modules/@noble/curves/secp256k1.js");\n// Add this error type for decode failures\nclass PartialSignatureError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = "PartialSignatureError";\n    }\n}\nexports.PartialSignatureError = PartialSignatureError;\n// Implement a concrete class for PartialSignature\nclass PartialSig {\n    constructor(s, R) {\n        this.s = s;\n        this.R = R;\n        if (s.length !== 32) {\n            throw new PartialSignatureError("Invalid s length");\n        }\n        if (R.length !== 33) {\n            throw new PartialSignatureError("Invalid R length");\n        }\n    }\n    /**\n     * Encodes the partial signature into bytes\n     * Returns a 32-byte array containing just the s value\n     */\n    encode() {\n        // Return copy of s bytes\n        return new Uint8Array(this.s);\n    }\n    /**\n     * Decodes a partial signature from bytes\n     * @param bytes - 32-byte array containing s value\n     */\n    static decode(bytes) {\n        if (bytes.length !== 32) {\n            throw new PartialSignatureError("Invalid partial signature length");\n        }\n        // Verify s is less than curve order\n        const s = (0, utils_1.bytesToNumberBE)(bytes);\n        if (s >= secp256k1_1.CURVE.n) {\n            throw new PartialSignatureError("s value overflows curve order");\n        }\n        // For decode we don\'t have R, so we\'ll need to compute it later\n        const R = new Uint8Array(33); // Zero R for now\n        return new PartialSig(bytes, R);\n    }\n}\nexports.PartialSig = PartialSig;\n/**\n * Generates a MuSig2 partial signature\n */\nfunction sign(secNonce, privateKey, combinedNonce, publicKeys, message, options) {\n    let tweakBytes;\n    if (options?.taprootTweak !== undefined) {\n        const { preTweakedKey } = (0, keys_1.aggregateKeys)(options?.sortKeys ? musig.sortKeys(publicKeys) : publicKeys, true);\n        tweakBytes = secp256k1_2.schnorr.utils.taggedHash("TapTweak", preTweakedKey.subarray(1), options.taprootTweak);\n    }\n    const session = new musig.Session(combinedNonce, options?.sortKeys ? musig.sortKeys(publicKeys) : publicKeys, message, tweakBytes ? [tweakBytes] : undefined, tweakBytes ? [true] : undefined);\n    const partialSig = session.sign(secNonce, privateKey);\n    return PartialSig.decode(partialSig);\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/musig2/sign.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/networks.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.networks = exports.getNetwork = void 0;\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\nconst getNetwork = (network) => {\n    return exports.networks[network];\n};\nexports.getNetwork = getNetwork;\nexports.networks = {\n    bitcoin: withArkPrefix(btc_signer_1.NETWORK, "ark"),\n    testnet: withArkPrefix(btc_signer_1.TEST_NETWORK, "tark"),\n    signet: withArkPrefix(btc_signer_1.TEST_NETWORK, "tark"),\n    mutinynet: withArkPrefix(btc_signer_1.TEST_NETWORK, "tark"),\n    regtest: withArkPrefix({\n        ...btc_signer_1.TEST_NETWORK,\n        bech32: "bcrt",\n        pubKeyHash: 0x6f,\n        scriptHash: 0xc4,\n    }, "tark"),\n};\nfunction withArkPrefix(network, prefix) {\n    return {\n        ...network,\n        hrp: prefix,\n    };\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/networks.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/providers/ark.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.RestArkProvider = exports.SettlementEventType = void 0;\nexports.isFetchTimeoutError = isFetchTimeoutError;\nconst base_1 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nvar SettlementEventType;\n(function (SettlementEventType) {\n    SettlementEventType["BatchStarted"] = "batch_started";\n    SettlementEventType["BatchFinalization"] = "batch_finalization";\n    SettlementEventType["BatchFinalized"] = "batch_finalized";\n    SettlementEventType["BatchFailed"] = "batch_failed";\n    SettlementEventType["TreeSigningStarted"] = "tree_signing_started";\n    SettlementEventType["TreeNoncesAggregated"] = "tree_nonces_aggregated";\n    SettlementEventType["TreeTx"] = "tree_tx";\n    SettlementEventType["TreeSignature"] = "tree_signature";\n})(SettlementEventType || (exports.SettlementEventType = SettlementEventType = {}));\n/**\n * REST-based Ark provider implementation.\n * @see https://buf.build/arkade-os/arkd/docs/main:ark.v1#ark.v1.ArkService\n * @example\n * ```typescript\n * const provider = new RestArkProvider(\'https://ark.example.com\');\n * const info = await provider.getInfo();\n * ```\n */\nclass RestArkProvider {\n    constructor(serverUrl) {\n        this.serverUrl = serverUrl;\n    }\n    async getInfo() {\n        const url = `${this.serverUrl}/v1/info`;\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`Failed to get server info: ${response.statusText}`);\n        }\n        const fromServer = await response.json();\n        return {\n            ...fromServer,\n            vtxoTreeExpiry: BigInt(fromServer.vtxoTreeExpiry ?? 0),\n            unilateralExitDelay: BigInt(fromServer.unilateralExitDelay ?? 0),\n            roundInterval: BigInt(fromServer.roundInterval ?? 0),\n            dust: BigInt(fromServer.dust ?? 0),\n            utxoMinAmount: BigInt(fromServer.utxoMinAmount ?? 0),\n            utxoMaxAmount: BigInt(fromServer.utxoMaxAmount ?? -1),\n            vtxoMinAmount: BigInt(fromServer.vtxoMinAmount ?? 0),\n            vtxoMaxAmount: BigInt(fromServer.vtxoMaxAmount ?? -1),\n            boardingExitDelay: BigInt(fromServer.boardingExitDelay ?? 0),\n            marketHour: "marketHour" in fromServer && fromServer.marketHour != null\n                ? {\n                    nextStartTime: BigInt(fromServer.marketHour.nextStartTime ?? 0),\n                    nextEndTime: BigInt(fromServer.marketHour.nextEndTime ?? 0),\n                    period: BigInt(fromServer.marketHour.period ?? 0),\n                    roundInterval: BigInt(fromServer.marketHour.roundInterval ?? 0),\n                }\n                : undefined,\n        };\n    }\n    async submitTx(signedArkTx, checkpointTxs) {\n        const url = `${this.serverUrl}/v1/tx/submit`;\n        const response = await fetch(url, {\n            method: "POST",\n            headers: {\n                "Content-Type": "application/json",\n            },\n            body: JSON.stringify({\n                signedArkTx: signedArkTx,\n                checkpointTxs: checkpointTxs,\n            }),\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            try {\n                const grpcError = JSON.parse(errorText);\n                // gRPC errors usually have a message and code field\n                throw new Error(`Failed to submit virtual transaction: ${grpcError.message || grpcError.error || errorText}`);\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            }\n            catch (_) {\n                // If JSON parse fails, use the raw error text\n                throw new Error(`Failed to submit virtual transaction: ${errorText}`);\n            }\n        }\n        const data = await response.json();\n        return {\n            arkTxid: data.arkTxid,\n            finalArkTx: data.finalArkTx,\n            signedCheckpointTxs: data.signedCheckpointTxs,\n        };\n    }\n    async finalizeTx(arkTxid, finalCheckpointTxs) {\n        const url = `${this.serverUrl}/v1/tx/finalize`;\n        const response = await fetch(url, {\n            method: "POST",\n            headers: {\n                "Content-Type": "application/json",\n            },\n            body: JSON.stringify({\n                arkTxid,\n                finalCheckpointTxs,\n            }),\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Failed to finalize offchain transaction: ${errorText}`);\n        }\n    }\n    async registerIntent(intent) {\n        const url = `${this.serverUrl}/v1/batch/registerIntent`;\n        const response = await fetch(url, {\n            method: "POST",\n            headers: {\n                "Content-Type": "application/json",\n            },\n            body: JSON.stringify({\n                intent: {\n                    signature: intent.signature,\n                    message: intent.message,\n                },\n            }),\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Failed to register intent: ${errorText}`);\n        }\n        const data = await response.json();\n        return data.intentId;\n    }\n    async deleteIntent(intent) {\n        const url = `${this.serverUrl}/v1/batch/deleteIntent`;\n        const response = await fetch(url, {\n            method: "POST",\n            headers: {\n                "Content-Type": "application/json",\n            },\n            body: JSON.stringify({\n                proof: {\n                    signature: intent.signature,\n                    message: intent.message,\n                },\n            }),\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Failed to delete intent: ${errorText}`);\n        }\n    }\n    async confirmRegistration(intentId) {\n        const url = `${this.serverUrl}/v1/batch/ack`;\n        const response = await fetch(url, {\n            method: "POST",\n            headers: {\n                "Content-Type": "application/json",\n            },\n            body: JSON.stringify({\n                intentId,\n            }),\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Failed to confirm registration: ${errorText}`);\n        }\n    }\n    async submitTreeNonces(batchId, pubkey, nonces) {\n        const url = `${this.serverUrl}/v1/batch/tree/submitNonces`;\n        const response = await fetch(url, {\n            method: "POST",\n            headers: {\n                "Content-Type": "application/json",\n            },\n            body: JSON.stringify({\n                batchId,\n                pubkey,\n                treeNonces: encodeMusig2Nonces(nonces),\n            }),\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Failed to submit tree nonces: ${errorText}`);\n        }\n    }\n    async submitTreeSignatures(batchId, pubkey, signatures) {\n        const url = `${this.serverUrl}/v1/batch/tree/submitSignatures`;\n        const response = await fetch(url, {\n            method: "POST",\n            headers: {\n                "Content-Type": "application/json",\n            },\n            body: JSON.stringify({\n                batchId,\n                pubkey,\n                treeSignatures: encodeMusig2Signatures(signatures),\n            }),\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(`Failed to submit tree signatures: ${errorText}`);\n        }\n    }\n    async submitSignedForfeitTxs(signedForfeitTxs, signedCommitmentTx) {\n        const url = `${this.serverUrl}/v1/batch/submitForfeitTxs`;\n        const response = await fetch(url, {\n            method: "POST",\n            headers: {\n                "Content-Type": "application/json",\n            },\n            body: JSON.stringify({\n                signedForfeitTxs: signedForfeitTxs,\n                signedCommitmentTx: signedCommitmentTx,\n            }),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to submit forfeit transactions: ${response.statusText}`);\n        }\n    }\n    async *getEventStream(signal, topics) {\n        const url = `${this.serverUrl}/v1/batch/events`;\n        const queryParams = topics.length > 0\n            ? `?${topics.map((topic) => `topics=${encodeURIComponent(topic)}`).join("&")}`\n            : "";\n        while (!signal?.aborted) {\n            try {\n                const response = await fetch(url + queryParams, {\n                    headers: {\n                        Accept: "application/json",\n                    },\n                    signal,\n                });\n                if (!response.ok) {\n                    throw new Error(`Unexpected status ${response.status} when fetching event stream`);\n                }\n                if (!response.body) {\n                    throw new Error("Response body is null");\n                }\n                const reader = response.body.getReader();\n                const decoder = new TextDecoder();\n                let buffer = "";\n                while (!signal?.aborted) {\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        break;\n                    }\n                    // Append new data to buffer and split by newlines\n                    buffer += decoder.decode(value, { stream: true });\n                    const lines = buffer.split("\\n");\n                    // Process all complete lines\n                    for (let i = 0; i < lines.length - 1; i++) {\n                        const line = lines[i].trim();\n                        if (!line)\n                            continue;\n                        try {\n                            const data = JSON.parse(line);\n                            const event = this.parseSettlementEvent(data.result);\n                            if (event) {\n                                yield event;\n                            }\n                        }\n                        catch (err) {\n                            console.error("Failed to parse event:", err);\n                            throw err;\n                        }\n                    }\n                    // Keep the last partial line in the buffer\n                    buffer = lines[lines.length - 1];\n                }\n            }\n            catch (error) {\n                if (error instanceof Error && error.name === "AbortError") {\n                    break;\n                }\n                // ignore timeout errors, they\'re expected when the server is not sending anything for 5 min\n                // these timeouts are set by builtin fetch function\n                if (isFetchTimeoutError(error)) {\n                    console.debug("Timeout error ignored");\n                    continue;\n                }\n                console.error("Event stream error:", error);\n                throw error;\n            }\n        }\n    }\n    async *getTransactionsStream(signal) {\n        const url = `${this.serverUrl}/v1/txs`;\n        while (!signal?.aborted) {\n            try {\n                const response = await fetch(url, {\n                    headers: {\n                        Accept: "application/json",\n                    },\n                    signal,\n                });\n                if (!response.ok) {\n                    throw new Error(`Unexpected status ${response.status} when fetching transaction stream`);\n                }\n                if (!response.body) {\n                    throw new Error("Response body is null");\n                }\n                const reader = response.body.getReader();\n                const decoder = new TextDecoder();\n                let buffer = "";\n                while (!signal?.aborted) {\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        break;\n                    }\n                    // Append new data to buffer and split by newlines\n                    buffer += decoder.decode(value, { stream: true });\n                    const lines = buffer.split("\\n");\n                    // Process all complete lines\n                    for (let i = 0; i < lines.length - 1; i++) {\n                        const line = lines[i].trim();\n                        if (!line)\n                            continue;\n                        const data = JSON.parse(line);\n                        const txNotification = this.parseTransactionNotification(data.result);\n                        if (txNotification) {\n                            yield txNotification;\n                        }\n                    }\n                    // Keep the last partial line in the buffer\n                    buffer = lines[lines.length - 1];\n                }\n            }\n            catch (error) {\n                if (error instanceof Error && error.name === "AbortError") {\n                    break;\n                }\n                // ignore timeout errors, they\'re expected when the server is not sending anything for 5 min\n                // these timeouts are set by builtin fetch function\n                if (isFetchTimeoutError(error)) {\n                    console.debug("Timeout error ignored");\n                    continue;\n                }\n                console.error("Address subscription error:", error);\n                throw error;\n            }\n        }\n    }\n    parseSettlementEvent(data) {\n        // Check for BatchStarted event\n        if (data.batchStarted) {\n            return {\n                type: SettlementEventType.BatchStarted,\n                id: data.batchStarted.id,\n                intentIdHashes: data.batchStarted.intentIdHashes,\n                batchExpiry: BigInt(data.batchStarted.batchExpiry),\n            };\n        }\n        // Check for BatchFinalization event\n        if (data.batchFinalization) {\n            return {\n                type: SettlementEventType.BatchFinalization,\n                id: data.batchFinalization.id,\n                commitmentTx: data.batchFinalization.commitmentTx,\n            };\n        }\n        // Check for BatchFinalized event\n        if (data.batchFinalized) {\n            return {\n                type: SettlementEventType.BatchFinalized,\n                id: data.batchFinalized.id,\n                commitmentTxid: data.batchFinalized.commitmentTxid,\n            };\n        }\n        // Check for BatchFailed event\n        if (data.batchFailed) {\n            return {\n                type: SettlementEventType.BatchFailed,\n                id: data.batchFailed.id,\n                reason: data.batchFailed.reason,\n            };\n        }\n        // Check for TreeSigningStarted event\n        if (data.treeSigningStarted) {\n            return {\n                type: SettlementEventType.TreeSigningStarted,\n                id: data.treeSigningStarted.id,\n                cosignersPublicKeys: data.treeSigningStarted.cosignersPubkeys,\n                unsignedCommitmentTx: data.treeSigningStarted.unsignedCommitmentTx,\n            };\n        }\n        // Check for TreeNoncesAggregated event\n        if (data.treeNoncesAggregated) {\n            return {\n                type: SettlementEventType.TreeNoncesAggregated,\n                id: data.treeNoncesAggregated.id,\n                treeNonces: decodeMusig2Nonces(data.treeNoncesAggregated.treeNonces),\n            };\n        }\n        // Check for TreeTx event\n        if (data.treeTx) {\n            const children = Object.fromEntries(Object.entries(data.treeTx.children).map(([outputIndex, txid]) => {\n                return [parseInt(outputIndex), txid];\n            }));\n            return {\n                type: SettlementEventType.TreeTx,\n                id: data.treeTx.id,\n                topic: data.treeTx.topic,\n                batchIndex: data.treeTx.batchIndex,\n                chunk: {\n                    txid: data.treeTx.txid,\n                    tx: data.treeTx.tx,\n                    children,\n                },\n            };\n        }\n        if (data.treeSignature) {\n            return {\n                type: SettlementEventType.TreeSignature,\n                id: data.treeSignature.id,\n                topic: data.treeSignature.topic,\n                batchIndex: data.treeSignature.batchIndex,\n                txid: data.treeSignature.txid,\n                signature: data.treeSignature.signature,\n            };\n        }\n        console.warn("Unknown event type:", data);\n        return null;\n    }\n    parseTransactionNotification(data) {\n        if (data.commitmentTx) {\n            return {\n                commitmentTx: {\n                    txid: data.commitmentTx.txid,\n                    tx: data.commitmentTx.tx,\n                    spentVtxos: data.commitmentTx.spentVtxos.map(mapVtxo),\n                    spendableVtxos: data.commitmentTx.spendableVtxos.map(mapVtxo),\n                    checkpointTxs: data.commitmentTx.checkpointTxs,\n                },\n            };\n        }\n        if (data.arkTx) {\n            return {\n                arkTx: {\n                    txid: data.arkTx.txid,\n                    tx: data.arkTx.tx,\n                    spentVtxos: data.arkTx.spentVtxos.map(mapVtxo),\n                    spendableVtxos: data.arkTx.spendableVtxos.map(mapVtxo),\n                    checkpointTxs: data.arkTx.checkpointTxs,\n                },\n            };\n        }\n        console.warn("Unknown transaction notification type:", data);\n        return null;\n    }\n}\nexports.RestArkProvider = RestArkProvider;\nfunction encodeMusig2Nonces(nonces) {\n    const noncesObject = {};\n    for (const [txid, nonce] of nonces) {\n        noncesObject[txid] = base_1.hex.encode(nonce.pubNonce);\n    }\n    return JSON.stringify(noncesObject);\n}\nfunction encodeMusig2Signatures(signatures) {\n    const sigObject = {};\n    for (const [txid, sig] of signatures) {\n        sigObject[txid] = base_1.hex.encode(sig.encode());\n    }\n    return JSON.stringify(sigObject);\n}\nfunction decodeMusig2Nonces(str) {\n    const noncesObject = JSON.parse(str);\n    return new Map(Object.entries(noncesObject).map(([txid, nonce]) => {\n        if (typeof nonce !== "string") {\n            throw new Error("invalid nonce");\n        }\n        return [txid, { pubNonce: base_1.hex.decode(nonce) }];\n    }));\n}\nfunction isFetchTimeoutError(err) {\n    const checkError = (error) => {\n        if (!(error instanceof Error))\n            return false;\n        // TODO: get something more robust than this\n        const isCloudflare524 = error.name === "TypeError" && error.message === "Failed to fetch";\n        return (isCloudflare524 ||\n            error.name === "HeadersTimeoutError" ||\n            error.name === "BodyTimeoutError" ||\n            error.code === "UND_ERR_HEADERS_TIMEOUT" ||\n            error.code === "UND_ERR_BODY_TIMEOUT");\n    };\n    return checkError(err) || checkError(err.cause);\n}\nfunction mapVtxo(vtxo) {\n    return {\n        outpoint: {\n            txid: vtxo.outpoint.txid,\n            vout: vtxo.outpoint.vout,\n        },\n        amount: vtxo.amount,\n        script: vtxo.script,\n        createdAt: vtxo.createdAt,\n        expiresAt: vtxo.expiresAt,\n        commitmentTxids: vtxo.commitmentTxids,\n        isPreconfirmed: vtxo.isPreconfirmed,\n        isSwept: vtxo.isSwept,\n        isUnrolled: vtxo.isUnrolled,\n        isSpent: vtxo.isSpent,\n        spentBy: vtxo.spentBy,\n        settledBy: vtxo.settledBy,\n        arkTxid: vtxo.arkTxid,\n    };\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/providers/ark.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/providers/indexer.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.RestIndexerProvider = exports.ChainTxType = exports.IndexerTxType = void 0;\nconst ark_1 = __webpack_require__(/*! ./ark */ "./node_modules/@arkade-os/sdk/dist/cjs/providers/ark.js");\nvar IndexerTxType;\n(function (IndexerTxType) {\n    IndexerTxType[IndexerTxType["INDEXER_TX_TYPE_UNSPECIFIED"] = 0] = "INDEXER_TX_TYPE_UNSPECIFIED";\n    IndexerTxType[IndexerTxType["INDEXER_TX_TYPE_RECEIVED"] = 1] = "INDEXER_TX_TYPE_RECEIVED";\n    IndexerTxType[IndexerTxType["INDEXER_TX_TYPE_SENT"] = 2] = "INDEXER_TX_TYPE_SENT";\n})(IndexerTxType || (exports.IndexerTxType = IndexerTxType = {}));\nvar ChainTxType;\n(function (ChainTxType) {\n    ChainTxType["UNSPECIFIED"] = "INDEXER_CHAINED_TX_TYPE_UNSPECIFIED";\n    ChainTxType["COMMITMENT"] = "INDEXER_CHAINED_TX_TYPE_COMMITMENT";\n    ChainTxType["ARK"] = "INDEXER_CHAINED_TX_TYPE_ARK";\n    ChainTxType["TREE"] = "INDEXER_CHAINED_TX_TYPE_TREE";\n    ChainTxType["CHECKPOINT"] = "INDEXER_CHAINED_TX_TYPE_CHECKPOINT";\n})(ChainTxType || (exports.ChainTxType = ChainTxType = {}));\n/**\n * REST-based Indexer provider implementation.\n * @see https://buf.build/arkade-os/arkd/docs/main:ark.v1#ark.v1.IndexerService\n * @example\n * ```typescript\n * const provider = new RestIndexerProvider(\'https://ark.indexer.example.com\');\n * const commitmentTx = await provider.getCommitmentTx("6686af8f3be3517880821f62e6c3d749b9d6713736a1d8e229a55daa659446b2");\n * ```\n */\nclass RestIndexerProvider {\n    constructor(serverUrl) {\n        this.serverUrl = serverUrl;\n    }\n    async getVtxoTree(batchOutpoint, opts) {\n        let url = `${this.serverUrl}/v1/batch/${batchOutpoint.txid}/${batchOutpoint.vout}/tree`;\n        const params = new URLSearchParams();\n        if (opts) {\n            if (opts.pageIndex !== undefined)\n                params.append("page.index", opts.pageIndex.toString());\n            if (opts.pageSize !== undefined)\n                params.append("page.size", opts.pageSize.toString());\n        }\n        if (params.toString()) {\n            url += "?" + params.toString();\n        }\n        const res = await fetch(url);\n        if (!res.ok) {\n            throw new Error(`Failed to fetch vtxo tree: ${res.statusText}`);\n        }\n        const data = await res.json();\n        if (!Response.isVtxoTreeResponse(data)) {\n            throw new Error("Invalid vtxo tree data received");\n        }\n        data.vtxoTree.forEach((tx) => {\n            tx.children = Object.fromEntries(Object.entries(tx.children).map(([key, value]) => [\n                Number(key),\n                value,\n            ]));\n        });\n        return data;\n    }\n    async getVtxoTreeLeaves(batchOutpoint, opts) {\n        let url = `${this.serverUrl}/v1/batch/${batchOutpoint.txid}/${batchOutpoint.vout}/tree/leaves`;\n        const params = new URLSearchParams();\n        if (opts) {\n            if (opts.pageIndex !== undefined)\n                params.append("page.index", opts.pageIndex.toString());\n            if (opts.pageSize !== undefined)\n                params.append("page.size", opts.pageSize.toString());\n        }\n        if (params.toString()) {\n            url += "?" + params.toString();\n        }\n        const res = await fetch(url);\n        if (!res.ok) {\n            throw new Error(`Failed to fetch vtxo tree leaves: ${res.statusText}`);\n        }\n        const data = await res.json();\n        if (!Response.isVtxoTreeLeavesResponse(data)) {\n            throw new Error("Invalid vtxos tree leaves data received");\n        }\n        return data;\n    }\n    async getBatchSweepTransactions(batchOutpoint) {\n        const url = `${this.serverUrl}/v1/batch/${batchOutpoint.txid}/${batchOutpoint.vout}/sweepTxs`;\n        const res = await fetch(url);\n        if (!res.ok) {\n            throw new Error(`Failed to fetch batch sweep transactions: ${res.statusText}`);\n        }\n        const data = await res.json();\n        if (!Response.isBatchSweepTransactionsResponse(data)) {\n            throw new Error("Invalid batch sweep transactions data received");\n        }\n        return data;\n    }\n    async getCommitmentTx(txid) {\n        const url = `${this.serverUrl}/v1/commitmentTx/${txid}`;\n        const res = await fetch(url);\n        if (!res.ok) {\n            throw new Error(`Failed to fetch commitment tx: ${res.statusText}`);\n        }\n        const data = await res.json();\n        if (!Response.isCommitmentTx(data)) {\n            throw new Error("Invalid commitment tx data received");\n        }\n        return data;\n    }\n    async getCommitmentTxConnectors(txid, opts) {\n        let url = `${this.serverUrl}/v1/commitmentTx/${txid}/connectors`;\n        const params = new URLSearchParams();\n        if (opts) {\n            if (opts.pageIndex !== undefined)\n                params.append("page.index", opts.pageIndex.toString());\n            if (opts.pageSize !== undefined)\n                params.append("page.size", opts.pageSize.toString());\n        }\n        if (params.toString()) {\n            url += "?" + params.toString();\n        }\n        const res = await fetch(url);\n        if (!res.ok) {\n            throw new Error(`Failed to fetch commitment tx connectors: ${res.statusText}`);\n        }\n        const data = await res.json();\n        if (!Response.isConnectorsResponse(data)) {\n            throw new Error("Invalid commitment tx connectors data received");\n        }\n        data.connectors.forEach((tx) => {\n            tx.children = Object.fromEntries(Object.entries(tx.children).map(([key, value]) => [\n                Number(key),\n                value,\n            ]));\n        });\n        return data;\n    }\n    async getCommitmentTxForfeitTxs(txid, opts) {\n        let url = `${this.serverUrl}/v1/commitmentTx/${txid}/forfeitTxs`;\n        const params = new URLSearchParams();\n        if (opts) {\n            if (opts.pageIndex !== undefined)\n                params.append("page.index", opts.pageIndex.toString());\n            if (opts.pageSize !== undefined)\n                params.append("page.size", opts.pageSize.toString());\n        }\n        if (params.toString()) {\n            url += "?" + params.toString();\n        }\n        const res = await fetch(url);\n        if (!res.ok) {\n            throw new Error(`Failed to fetch commitment tx forfeitTxs: ${res.statusText}`);\n        }\n        const data = await res.json();\n        if (!Response.isForfeitTxsResponse(data)) {\n            throw new Error("Invalid commitment tx forfeitTxs data received");\n        }\n        return data;\n    }\n    async *getSubscription(subscriptionId, abortSignal) {\n        const url = `${this.serverUrl}/v1/script/subscription/${subscriptionId}`;\n        while (!abortSignal.aborted) {\n            try {\n                const res = await fetch(url, {\n                    headers: {\n                        Accept: "application/json",\n                    },\n                });\n                if (!res.ok) {\n                    throw new Error(`Unexpected status ${res.status} when subscribing to address updates`);\n                }\n                if (!res.body) {\n                    throw new Error("Response body is null");\n                }\n                const reader = res.body.getReader();\n                const decoder = new TextDecoder();\n                let buffer = "";\n                while (!abortSignal.aborted) {\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        break;\n                    }\n                    buffer += decoder.decode(value, { stream: true });\n                    const lines = buffer.split("\\n");\n                    for (let i = 0; i < lines.length - 1; i++) {\n                        const line = lines[i].trim();\n                        if (!line)\n                            continue;\n                        const data = JSON.parse(line);\n                        if ("result" in data) {\n                            yield {\n                                txid: data.result.txid,\n                                scripts: data.result.scripts || [],\n                                newVtxos: (data.result.newVtxos || []).map(convertVtxo),\n                                spentVtxos: (data.result.spentVtxos || []).map(convertVtxo),\n                                tx: data.result.tx,\n                                checkpointTxs: data.result.checkpointTxs,\n                            };\n                        }\n                    }\n                    buffer = lines[lines.length - 1];\n                }\n            }\n            catch (error) {\n                if (error instanceof Error && error.name === "AbortError") {\n                    break;\n                }\n                // ignore timeout errors, they\'re expected when the server is not sending anything for 5 min\n                // these timeouts are set by builtin fetch function\n                if ((0, ark_1.isFetchTimeoutError)(error)) {\n                    console.debug("Timeout error ignored");\n                    continue;\n                }\n                console.error("Subscription error:", error);\n                throw error;\n            }\n        }\n    }\n    async getVirtualTxs(txids, opts) {\n        let url = `${this.serverUrl}/v1/virtualTx/${txids.join(",")}`;\n        const params = new URLSearchParams();\n        if (opts) {\n            if (opts.pageIndex !== undefined)\n                params.append("page.index", opts.pageIndex.toString());\n            if (opts.pageSize !== undefined)\n                params.append("page.size", opts.pageSize.toString());\n        }\n        if (params.toString()) {\n            url += "?" + params.toString();\n        }\n        const res = await fetch(url);\n        if (!res.ok) {\n            throw new Error(`Failed to fetch virtual txs: ${res.statusText}`);\n        }\n        const data = await res.json();\n        if (!Response.isVirtualTxsResponse(data)) {\n            throw new Error("Invalid virtual txs data received");\n        }\n        return data;\n    }\n    async getVtxoChain(vtxoOutpoint, opts) {\n        let url = `${this.serverUrl}/v1/vtxo/${vtxoOutpoint.txid}/${vtxoOutpoint.vout}/chain`;\n        const params = new URLSearchParams();\n        if (opts) {\n            if (opts.pageIndex !== undefined)\n                params.append("page.index", opts.pageIndex.toString());\n            if (opts.pageSize !== undefined)\n                params.append("page.size", opts.pageSize.toString());\n        }\n        if (params.toString()) {\n            url += "?" + params.toString();\n        }\n        const res = await fetch(url);\n        if (!res.ok) {\n            throw new Error(`Failed to fetch vtxo chain: ${res.statusText}`);\n        }\n        const data = await res.json();\n        if (!Response.isVtxoChainResponse(data)) {\n            throw new Error("Invalid vtxo chain data received");\n        }\n        return data;\n    }\n    async getVtxos(opts) {\n        // scripts and outpoints are mutually exclusive\n        if (opts?.scripts && opts?.outpoints) {\n            throw new Error("scripts and outpoints are mutually exclusive options");\n        }\n        if (!opts?.scripts && !opts?.outpoints) {\n            throw new Error("Either scripts or outpoints must be provided");\n        }\n        let url = `${this.serverUrl}/v1/vtxos`;\n        const params = new URLSearchParams();\n        // Handle scripts with multi collection format\n        if (opts?.scripts && opts.scripts.length > 0) {\n            opts.scripts.forEach((script) => {\n                params.append("scripts", script);\n            });\n        }\n        // Handle outpoints with multi collection format\n        if (opts?.outpoints && opts.outpoints.length > 0) {\n            opts.outpoints.forEach((outpoint) => {\n                params.append("outpoints", `${outpoint.txid}:${outpoint.vout}`);\n            });\n        }\n        if (opts) {\n            if (opts.spendableOnly !== undefined)\n                params.append("spendableOnly", opts.spendableOnly.toString());\n            if (opts.spentOnly !== undefined)\n                params.append("spentOnly", opts.spentOnly.toString());\n            if (opts.recoverableOnly !== undefined)\n                params.append("recoverableOnly", opts.recoverableOnly.toString());\n            if (opts.pageIndex !== undefined)\n                params.append("page.index", opts.pageIndex.toString());\n            if (opts.pageSize !== undefined)\n                params.append("page.size", opts.pageSize.toString());\n        }\n        if (params.toString()) {\n            url += "?" + params.toString();\n        }\n        const res = await fetch(url);\n        if (!res.ok) {\n            throw new Error(`Failed to fetch vtxos: ${res.statusText}`);\n        }\n        const data = await res.json();\n        if (!Response.isVtxosResponse(data)) {\n            throw new Error("Invalid vtxos data received");\n        }\n        return {\n            vtxos: data.vtxos.map(convertVtxo),\n            page: data.page,\n        };\n    }\n    async subscribeForScripts(scripts, subscriptionId) {\n        const url = `${this.serverUrl}/v1/script/subscribe`;\n        const res = await fetch(url, {\n            headers: {\n                "Content-Type": "application/json",\n            },\n            method: "POST",\n            body: JSON.stringify({ scripts, subscriptionId }),\n        });\n        if (!res.ok) {\n            const errorText = await res.text();\n            throw new Error(`Failed to subscribe to scripts: ${errorText}`);\n        }\n        const data = await res.json();\n        if (!data.subscriptionId)\n            throw new Error(`Subscription ID not found`);\n        return data.subscriptionId;\n    }\n    async unsubscribeForScripts(subscriptionId, scripts) {\n        const url = `${this.serverUrl}/v1/script/unsubscribe`;\n        const res = await fetch(url, {\n            headers: {\n                "Content-Type": "application/json",\n            },\n            method: "POST",\n            body: JSON.stringify({ subscriptionId, scripts }),\n        });\n        if (!res.ok) {\n            const errorText = await res.text();\n            throw new Error(`Failed to unsubscribe to scripts: ${errorText}`);\n        }\n    }\n}\nexports.RestIndexerProvider = RestIndexerProvider;\nfunction convertVtxo(vtxo) {\n    return {\n        txid: vtxo.outpoint.txid,\n        vout: vtxo.outpoint.vout,\n        value: Number(vtxo.amount),\n        status: {\n            confirmed: !vtxo.isSwept && !vtxo.isPreconfirmed,\n        },\n        virtualStatus: {\n            state: vtxo.isSwept\n                ? "swept"\n                : vtxo.isPreconfirmed\n                    ? "preconfirmed"\n                    : "settled",\n            commitmentTxIds: vtxo.commitmentTxids,\n            batchExpiry: vtxo.expiresAt\n                ? Number(vtxo.expiresAt) * 1000\n                : undefined,\n        },\n        spentBy: vtxo.spentBy ?? "",\n        settledBy: vtxo.settledBy,\n        arkTxId: vtxo.arkTxid,\n        createdAt: new Date(Number(vtxo.createdAt) * 1000),\n        isUnrolled: vtxo.isUnrolled,\n    };\n}\n// Unexported namespace for type guards only\nvar Response;\n(function (Response) {\n    function isBatch(data) {\n        return (typeof data === "object" &&\n            typeof data.totalOutputAmount === "string" &&\n            typeof data.totalOutputVtxos === "number" &&\n            typeof data.expiresAt === "string" &&\n            typeof data.swept === "boolean");\n    }\n    function isChain(data) {\n        return (typeof data === "object" &&\n            typeof data.txid === "string" &&\n            typeof data.expiresAt === "string" &&\n            Object.values(ChainTxType).includes(data.type) &&\n            Array.isArray(data.spends) &&\n            data.spends.every((spend) => typeof spend === "string"));\n    }\n    function isCommitmentTx(data) {\n        return (typeof data === "object" &&\n            typeof data.startedAt === "string" &&\n            typeof data.endedAt === "string" &&\n            typeof data.totalInputAmount === "string" &&\n            typeof data.totalInputVtxos === "number" &&\n            typeof data.totalOutputAmount === "string" &&\n            typeof data.totalOutputVtxos === "number" &&\n            typeof data.batches === "object" &&\n            Object.values(data.batches).every(isBatch));\n    }\n    Response.isCommitmentTx = isCommitmentTx;\n    function isOutpoint(data) {\n        return (typeof data === "object" &&\n            typeof data.txid === "string" &&\n            typeof data.vout === "number");\n    }\n    Response.isOutpoint = isOutpoint;\n    function isOutpointArray(data) {\n        return Array.isArray(data) && data.every(isOutpoint);\n    }\n    Response.isOutpointArray = isOutpointArray;\n    function isTx(data) {\n        return (typeof data === "object" &&\n            typeof data.txid === "string" &&\n            typeof data.children === "object" &&\n            Object.values(data.children).every(isTxid) &&\n            Object.keys(data.children).every((k) => Number.isInteger(Number(k))));\n    }\n    function isTxsArray(data) {\n        return Array.isArray(data) && data.every(isTx);\n    }\n    Response.isTxsArray = isTxsArray;\n    function isTxHistoryRecord(data) {\n        return (typeof data === "object" &&\n            typeof data.amount === "string" &&\n            typeof data.createdAt === "string" &&\n            typeof data.isSettled === "boolean" &&\n            typeof data.settledBy === "string" &&\n            Object.values(IndexerTxType).includes(data.type) &&\n            ((!data.commitmentTxid && typeof data.virtualTxid === "string") ||\n                (typeof data.commitmentTxid === "string" && !data.virtualTxid)));\n    }\n    function isTxHistoryRecordArray(data) {\n        return Array.isArray(data) && data.every(isTxHistoryRecord);\n    }\n    Response.isTxHistoryRecordArray = isTxHistoryRecordArray;\n    function isTxid(data) {\n        return typeof data === "string" && data.length === 64;\n    }\n    function isTxidArray(data) {\n        return Array.isArray(data) && data.every(isTxid);\n    }\n    Response.isTxidArray = isTxidArray;\n    function isVtxo(data) {\n        return (typeof data === "object" &&\n            isOutpoint(data.outpoint) &&\n            typeof data.createdAt === "string" &&\n            typeof data.expiresAt === "string" &&\n            typeof data.amount === "string" &&\n            typeof data.script === "string" &&\n            typeof data.isPreconfirmed === "boolean" &&\n            typeof data.isSwept === "boolean" &&\n            typeof data.isUnrolled === "boolean" &&\n            typeof data.isSpent === "boolean" &&\n            (!data.spentBy || typeof data.spentBy === "string") &&\n            (!data.settledBy || typeof data.settledBy === "string") &&\n            (!data.arkTxid || typeof data.arkTxid === "string") &&\n            Array.isArray(data.commitmentTxids) &&\n            data.commitmentTxids.every(isTxid));\n    }\n    function isPageResponse(data) {\n        return (typeof data === "object" &&\n            typeof data.current === "number" &&\n            typeof data.next === "number" &&\n            typeof data.total === "number");\n    }\n    function isVtxoTreeResponse(data) {\n        return (typeof data === "object" &&\n            Array.isArray(data.vtxoTree) &&\n            data.vtxoTree.every(isTx) &&\n            (!data.page || isPageResponse(data.page)));\n    }\n    Response.isVtxoTreeResponse = isVtxoTreeResponse;\n    function isVtxoTreeLeavesResponse(data) {\n        return (typeof data === "object" &&\n            Array.isArray(data.leaves) &&\n            data.leaves.every(isOutpoint) &&\n            (!data.page || isPageResponse(data.page)));\n    }\n    Response.isVtxoTreeLeavesResponse = isVtxoTreeLeavesResponse;\n    function isConnectorsResponse(data) {\n        return (typeof data === "object" &&\n            Array.isArray(data.connectors) &&\n            data.connectors.every(isTx) &&\n            (!data.page || isPageResponse(data.page)));\n    }\n    Response.isConnectorsResponse = isConnectorsResponse;\n    function isForfeitTxsResponse(data) {\n        return (typeof data === "object" &&\n            Array.isArray(data.txids) &&\n            data.txids.every(isTxid) &&\n            (!data.page || isPageResponse(data.page)));\n    }\n    Response.isForfeitTxsResponse = isForfeitTxsResponse;\n    function isSweptCommitmentTxResponse(data) {\n        return (typeof data === "object" &&\n            Array.isArray(data.sweptBy) &&\n            data.sweptBy.every(isTxid));\n    }\n    Response.isSweptCommitmentTxResponse = isSweptCommitmentTxResponse;\n    function isBatchSweepTransactionsResponse(data) {\n        return (typeof data === "object" &&\n            Array.isArray(data.sweptBy) &&\n            data.sweptBy.every(isTxid));\n    }\n    Response.isBatchSweepTransactionsResponse = isBatchSweepTransactionsResponse;\n    function isVirtualTxsResponse(data) {\n        return (typeof data === "object" &&\n            Array.isArray(data.txs) &&\n            data.txs.every((tx) => typeof tx === "string") &&\n            (!data.page || isPageResponse(data.page)));\n    }\n    Response.isVirtualTxsResponse = isVirtualTxsResponse;\n    function isVtxoChainResponse(data) {\n        return (typeof data === "object" &&\n            Array.isArray(data.chain) &&\n            data.chain.every(isChain) &&\n            (!data.page || isPageResponse(data.page)));\n    }\n    Response.isVtxoChainResponse = isVtxoChainResponse;\n    function isVtxosResponse(data) {\n        return (typeof data === "object" &&\n            Array.isArray(data.vtxos) &&\n            data.vtxos.every(isVtxo) &&\n            (!data.page || isPageResponse(data.page)));\n    }\n    Response.isVtxosResponse = isVtxosResponse;\n})(Response || (Response = {}));\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/providers/indexer.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/providers/onchain.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.EsploraProvider = exports.ESPLORA_URL = void 0;\n/**\n * The default base URLs for esplora API providers.\n */\nexports.ESPLORA_URL = {\n    bitcoin: "https://mempool.space/api",\n    testnet: "https://mempool.space/testnet/api",\n    signet: "https://mempool.space/signet/api",\n    mutinynet: "https://mutinynet.com/api",\n    regtest: "http://localhost:3000",\n};\n/**\n * Implementation of the onchain provider interface for esplora REST API.\n * @see https://mempool.space/docs/api/rest\n * @example\n * ```typescript\n * const provider = new EsploraProvider("https://mempool.space/api");\n * const utxos = await provider.getCoins("bcrt1q679zsd45msawvr7782r0twvmukns3drlstjt77");\n * ```\n */\nclass EsploraProvider {\n    constructor(baseUrl) {\n        this.baseUrl = baseUrl;\n    }\n    async getCoins(address) {\n        const response = await fetch(`${this.baseUrl}/address/${address}/utxo`);\n        if (!response.ok) {\n            throw new Error(`Failed to fetch UTXOs: ${response.statusText}`);\n        }\n        return response.json();\n    }\n    async getFeeRate() {\n        const response = await fetch(`${this.baseUrl}/fee-estimates`);\n        if (!response.ok) {\n            throw new Error(`Failed to fetch fee rate: ${response.statusText}`);\n        }\n        const fees = (await response.json());\n        return fees["1"] ?? undefined;\n    }\n    async broadcastTransaction(...txs) {\n        switch (txs.length) {\n            case 1:\n                return this.broadcastTx(txs[0]);\n            case 2:\n                return this.broadcastPackage(txs[0], txs[1]);\n            default:\n                throw new Error("Only 1 or 1C1P package can be broadcast");\n        }\n    }\n    async getTxOutspends(txid) {\n        const response = await fetch(`${this.baseUrl}/tx/${txid}/outspends`);\n        if (!response.ok) {\n            const error = await response.text();\n            throw new Error(`Failed to get transaction outspends: ${error}`);\n        }\n        return response.json();\n    }\n    async getTransactions(address) {\n        const response = await fetch(`${this.baseUrl}/address/${address}/txs`);\n        if (!response.ok) {\n            const error = await response.text();\n            throw new Error(`Failed to get transactions: ${error}`);\n        }\n        return response.json();\n    }\n    async getTxStatus(txid) {\n        // make sure tx exists in mempool or in block\n        const txresponse = await fetch(`${this.baseUrl}/tx/${txid}`);\n        if (!txresponse.ok) {\n            throw new Error(txresponse.statusText);\n        }\n        const tx = await txresponse.json();\n        if (!tx.status.confirmed) {\n            return { confirmed: false };\n        }\n        const response = await fetch(`${this.baseUrl}/tx/${txid}/status`);\n        if (!response.ok) {\n            throw new Error(`Failed to get transaction status: ${response.statusText}`);\n        }\n        const data = await response.json();\n        if (!data.confirmed) {\n            return { confirmed: false };\n        }\n        return {\n            confirmed: data.confirmed,\n            blockTime: data.block_time,\n            blockHeight: data.block_height,\n        };\n    }\n    async watchAddresses(addresses, callback) {\n        let intervalId = null;\n        const wsUrl = this.baseUrl.replace(/^http(s)?:/, "ws$1:") + "/v1/ws";\n        const poll = async () => {\n            // websocket is not reliable, so we will fallback to polling\n            const pollingInterval = 5000; // 5 seconds\n            const getAllTxs = () => {\n                return Promise.all(addresses.map((address) => this.getTransactions(address))).then((txArrays) => txArrays.flat());\n            };\n            // initial fetch to get existing transactions\n            const initialTxs = await getAllTxs();\n            // we use block_time in key to also notify when a transaction is confirmed\n            const txKey = (tx) => `${tx.txid}_${tx.status.block_time}`;\n            // polling for new transactions\n            intervalId = setInterval(async () => {\n                try {\n                    // get current transactions\n                    // we will compare with initialTxs to find new ones\n                    const currentTxs = await getAllTxs();\n                    // create a set of existing transactions to avoid duplicates\n                    const existingTxs = new Set(initialTxs.map(txKey));\n                    // filter out transactions that are already in initialTxs\n                    const newTxs = currentTxs.filter((tx) => !existingTxs.has(txKey(tx)));\n                    if (newTxs.length > 0) {\n                        // Update the tracking set instead of growing the array\n                        initialTxs.push(...newTxs);\n                        callback(newTxs);\n                    }\n                }\n                catch (error) {\n                    console.error("Error in polling mechanism:", error);\n                }\n            }, pollingInterval);\n        };\n        let ws = null;\n        try {\n            ws = new WebSocket(wsUrl);\n            ws.addEventListener("open", () => {\n                // subscribe to address updates\n                const subscribeMsg = {\n                    "track-addresses": addresses,\n                };\n                ws.send(JSON.stringify(subscribeMsg));\n            });\n            ws.addEventListener("message", (event) => {\n                try {\n                    const newTxs = [];\n                    const message = JSON.parse(event.data.toString());\n                    if (!message["multi-address-transactions"])\n                        return;\n                    const aux = message["multi-address-transactions"];\n                    for (const address in aux) {\n                        for (const type of [\n                            "mempool",\n                            "confirmed",\n                            "removed",\n                        ]) {\n                            if (!aux[address][type])\n                                continue;\n                            newTxs.push(...aux[address][type].filter(isExplorerTransaction));\n                        }\n                    }\n                    // callback with new transactions\n                    if (newTxs.length > 0)\n                        callback(newTxs);\n                }\n                catch (error) {\n                    console.error("Failed to process WebSocket message:", error);\n                }\n            });\n            ws.addEventListener("error", async () => {\n                // if websocket is not available, fallback to polling\n                await poll();\n            });\n        }\n        catch {\n            if (intervalId)\n                clearInterval(intervalId);\n            // if websocket is not available, fallback to polling\n            await poll();\n        }\n        const stopFunc = () => {\n            if (ws && ws.readyState === WebSocket.OPEN)\n                ws.close();\n            if (intervalId)\n                clearInterval(intervalId);\n        };\n        return stopFunc;\n    }\n    async getChainTip() {\n        const tipBlocks = await fetch(`${this.baseUrl}/blocks/tip`);\n        if (!tipBlocks.ok) {\n            throw new Error(`Failed to get chain tip: ${tipBlocks.statusText}`);\n        }\n        const tip = await tipBlocks.json();\n        if (!isValidBlocksTip(tip)) {\n            throw new Error(`Invalid chain tip: ${JSON.stringify(tip)}`);\n        }\n        if (tip.length === 0) {\n            throw new Error("No chain tip found");\n        }\n        const hash = tip[0].id;\n        return {\n            height: tip[0].height,\n            time: tip[0].mediantime,\n            hash,\n        };\n    }\n    async broadcastPackage(parent, child) {\n        const response = await fetch(`${this.baseUrl}/txs/package`, {\n            method: "POST",\n            headers: {\n                "Content-Type": "application/json",\n            },\n            body: JSON.stringify([parent, child]),\n        });\n        if (!response.ok) {\n            const error = await response.text();\n            throw new Error(`Failed to broadcast package: ${error}`);\n        }\n        return response.json();\n    }\n    async broadcastTx(tx) {\n        const response = await fetch(`${this.baseUrl}/tx`, {\n            method: "POST",\n            headers: {\n                "Content-Type": "text/plain",\n            },\n            body: tx,\n        });\n        if (!response.ok) {\n            const error = await response.text();\n            throw new Error(`Failed to broadcast transaction: ${error}`);\n        }\n        return response.text();\n    }\n}\nexports.EsploraProvider = EsploraProvider;\nfunction isValidBlocksTip(tip) {\n    return (Array.isArray(tip) &&\n        tip.every((t) => {\n            t &&\n                typeof t === "object" &&\n                typeof t.id === "string" &&\n                t.id.length > 0 &&\n                typeof t.height === "number" &&\n                t.height >= 0 &&\n                typeof t.mediantime === "number" &&\n                t.mediantime > 0;\n        }));\n}\nconst isExplorerTransaction = (tx) => {\n    return (typeof tx.txid === "string" &&\n        Array.isArray(tx.vout) &&\n        tx.vout.every((vout) => typeof vout.scriptpubkey_address === "string" &&\n            typeof vout.value === "string") &&\n        typeof tx.status === "object" &&\n        typeof tx.status.confirmed === "boolean" &&\n        typeof tx.status.block_time === "number");\n};\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/providers/onchain.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/script/address.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ArkAddress = void 0;\nconst base_1 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\n/**\n * ArkAddress allows to create and decode bech32m encoded ark address.\n * An ark address is composed of:\n * - a human readable prefix (hrp)\n * - a version byte (1 byte)\n * - a server public key (32 bytes)\n * - a vtxo taproot public key (32 bytes)\n *\n * @example\n * ```typescript\n * const address = new ArkAddress(\n *     new Uint8Array(32), // server public key\n *     new Uint8Array(32), // vtxo taproot public key\n *     "ark"\n * );\n *\n * const encoded = address.encode();\n * console.log("address: ", encoded);\n *\n * const decoded = ArkAddress.decode(encoded);\n * ```\n */\nclass ArkAddress {\n    constructor(serverPubKey, vtxoTaprootKey, hrp, version = 0) {\n        this.serverPubKey = serverPubKey;\n        this.vtxoTaprootKey = vtxoTaprootKey;\n        this.hrp = hrp;\n        this.version = version;\n        if (serverPubKey.length !== 32) {\n            throw new Error("Invalid server public key length, expected 32 bytes, got " +\n                serverPubKey.length);\n        }\n        if (vtxoTaprootKey.length !== 32) {\n            throw new Error("Invalid vtxo taproot public key length, expected 32 bytes, got " +\n                vtxoTaprootKey.length);\n        }\n    }\n    static decode(address) {\n        const decoded = base_1.bech32m.decodeUnsafe(address, 1023);\n        if (!decoded) {\n            throw new Error("Invalid address");\n        }\n        const data = new Uint8Array(base_1.bech32m.fromWords(decoded.words));\n        // First the version byte, then 32 bytes server pubkey, then 32 bytes vtxo taproot pubkey\n        if (data.length !== 1 + 32 + 32) {\n            throw new Error("Invalid data length, expected 65 bytes, got " + data.length);\n        }\n        const version = data[0];\n        const serverPubKey = data.slice(1, 33);\n        const vtxoTaprootPubKey = data.slice(33, 65);\n        return new ArkAddress(serverPubKey, vtxoTaprootPubKey, decoded.prefix, version);\n    }\n    encode() {\n        // Combine version byte, server pubkey, and vtxo taproot pubkey\n        const data = new Uint8Array(1 + 32 + 32);\n        data[0] = this.version;\n        data.set(this.serverPubKey, 1);\n        data.set(this.vtxoTaprootKey, 33);\n        const words = base_1.bech32m.toWords(data);\n        return base_1.bech32m.encode(this.hrp, words, 1023);\n    }\n    // pkScript is the script that should be used to send non-dust funds to the address\n    get pkScript() {\n        return btc_signer_1.Script.encode(["OP_1", this.vtxoTaprootKey]);\n    }\n    // subdustPkScript is the script that should be used to send sub-dust funds to the address\n    get subdustPkScript() {\n        return btc_signer_1.Script.encode(["RETURN", this.vtxoTaprootKey]);\n    }\n}\nexports.ArkAddress = ArkAddress;\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/script/address.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/script/base.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.VtxoScript = void 0;\nexports.scriptFromTapLeafScript = scriptFromTapLeafScript;\nconst payment_1 = __webpack_require__(/*! @scure/btc-signer/payment */ "./node_modules/@scure/btc-signer/payment.js");\nconst utils_1 = __webpack_require__(/*! @scure/btc-signer/utils */ "./node_modules/@scure/btc-signer/utils.js");\nconst address_1 = __webpack_require__(/*! ./address */ "./node_modules/@arkade-os/sdk/dist/cjs/script/address.js");\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\nconst base_1 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nconst tapscript_1 = __webpack_require__(/*! ./tapscript */ "./node_modules/@arkade-os/sdk/dist/cjs/script/tapscript.js");\nfunction scriptFromTapLeafScript(leaf) {\n    return leaf[1].subarray(0, leaf[1].length - 1); // remove the version byte\n}\n/**\n * VtxoScript is a script that contains a list of tapleaf scripts.\n * It is used to create vtxo scripts.\n *\n * @example\n * ```typescript\n * const vtxoScript = new VtxoScript([new Uint8Array(32), new Uint8Array(32)]);\n */\nclass VtxoScript {\n    static decode(tapTree) {\n        const leaves = decodeTaprootTree(tapTree);\n        return new VtxoScript(leaves);\n    }\n    constructor(scripts) {\n        this.scripts = scripts;\n        const tapTree = (0, payment_1.taprootListToTree)(scripts.map((script) => ({ script, leafVersion: payment_1.TAP_LEAF_VERSION })));\n        const payment = (0, payment_1.p2tr)(utils_1.TAPROOT_UNSPENDABLE_KEY, tapTree, undefined, true);\n        if (!payment.tapLeafScript ||\n            payment.tapLeafScript.length !== scripts.length) {\n            throw new Error("invalid scripts");\n        }\n        this.leaves = payment.tapLeafScript;\n        this.tweakedPublicKey = payment.tweakedPubkey;\n    }\n    encode() {\n        const tapTree = encodeTaprootTree(this.scripts);\n        return tapTree;\n    }\n    address(prefix, serverPubKey) {\n        return new address_1.ArkAddress(serverPubKey, this.tweakedPublicKey, prefix);\n    }\n    get pkScript() {\n        return btc_signer_1.Script.encode(["OP_1", this.tweakedPublicKey]);\n    }\n    onchainAddress(network) {\n        return (0, payment_1.Address)(network).encode({\n            type: "tr",\n            pubkey: this.tweakedPublicKey,\n        });\n    }\n    findLeaf(scriptHex) {\n        const leaf = this.leaves.find((leaf) => base_1.hex.encode(scriptFromTapLeafScript(leaf)) === scriptHex);\n        if (!leaf) {\n            throw new Error(`leaf \'${scriptHex}\' not found`);\n        }\n        return leaf;\n    }\n    exitPaths() {\n        const paths = [];\n        for (const leaf of this.leaves) {\n            try {\n                const tapscript = tapscript_1.CSVMultisigTapscript.decode(scriptFromTapLeafScript(leaf));\n                paths.push(tapscript);\n                continue;\n            }\n            catch (e) {\n                try {\n                    const tapscript = tapscript_1.ConditionCSVMultisigTapscript.decode(scriptFromTapLeafScript(leaf));\n                    paths.push(tapscript);\n                }\n                catch (e) {\n                    continue;\n                }\n            }\n        }\n        return paths;\n    }\n}\nexports.VtxoScript = VtxoScript;\nfunction decodeTaprootTree(tapTree) {\n    let offset = 0;\n    const scripts = [];\n    // Read number of leaves\n    const [numLeaves, numLeavesSize] = decodeCompactSizeUint(tapTree, offset);\n    offset += numLeavesSize;\n    // Read each leaf\n    for (let i = 0; i < numLeaves; i++) {\n        // Skip depth (1 byte)\n        offset += 1;\n        // Skip leaf version (1 byte)\n        offset += 1;\n        // Read script length\n        const [scriptLength, scriptLengthSize] = decodeCompactSizeUint(tapTree, offset);\n        offset += scriptLengthSize;\n        // Read script content\n        const script = tapTree.slice(offset, offset + scriptLength);\n        scripts.push(script);\n        offset += scriptLength;\n    }\n    return scripts;\n}\nfunction decodeCompactSizeUint(data, offset) {\n    const firstByte = data[offset];\n    if (firstByte < 0xfd) {\n        return [firstByte, 1];\n    }\n    else if (firstByte === 0xfd) {\n        const value = new DataView(data.buffer).getUint16(offset + 1, true);\n        return [value, 3];\n    }\n    else if (firstByte === 0xfe) {\n        const value = new DataView(data.buffer).getUint32(offset + 1, true);\n        return [value, 5];\n    }\n    else {\n        const value = Number(new DataView(data.buffer).getBigUint64(offset + 1, true));\n        return [value, 9];\n    }\n}\nfunction encodeTaprootTree(leaves) {\n    const chunks = [];\n    // Write number of leaves as compact size uint\n    chunks.push(encodeCompactSizeUint(leaves.length));\n    for (const tapscript of leaves) {\n        // Write depth (always 1 for now)\n        chunks.push(new Uint8Array([1]));\n        // Write leaf version (0xc0 for tapscript)\n        chunks.push(new Uint8Array([0xc0]));\n        // Write script length and script\n        chunks.push(encodeCompactSizeUint(tapscript.length));\n        chunks.push(tapscript);\n    }\n    // Concatenate all chunks\n    const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks) {\n        result.set(chunk, offset);\n        offset += chunk.length;\n    }\n    return result;\n}\nfunction encodeCompactSizeUint(value) {\n    if (value < 0xfd) {\n        return new Uint8Array([value]);\n    }\n    else if (value <= 0xffff) {\n        const buffer = new Uint8Array(3);\n        buffer[0] = 0xfd;\n        new DataView(buffer.buffer).setUint16(1, value, true);\n        return buffer;\n    }\n    else if (value <= 0xffffffff) {\n        const buffer = new Uint8Array(5);\n        buffer[0] = 0xfe;\n        new DataView(buffer.buffer).setUint32(1, value, true);\n        return buffer;\n    }\n    else {\n        const buffer = new Uint8Array(9);\n        buffer[0] = 0xff;\n        new DataView(buffer.buffer).setBigUint64(1, BigInt(value), true);\n        return buffer;\n    }\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/script/base.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/script/default.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.DefaultVtxo = void 0;\nconst base_1 = __webpack_require__(/*! ./base */ "./node_modules/@arkade-os/sdk/dist/cjs/script/base.js");\nconst tapscript_1 = __webpack_require__(/*! ./tapscript */ "./node_modules/@arkade-os/sdk/dist/cjs/script/tapscript.js");\nconst base_2 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\n/**\n * DefaultVtxo is the default implementation of a VtxoScript.\n * It contains 1 forfeit path and 1 exit path.\n * - forfeit = (Alice + Server)\n * - exit = (Alice) after csvTimelock\n */\nvar DefaultVtxo;\n(function (DefaultVtxo) {\n    /**\n     * DefaultVtxo.Script is the class letting to create the vtxo script.\n     * @example\n     * ```typescript\n     * const vtxoScript = new DefaultVtxo.Script({\n     *     pubKey: new Uint8Array(32),\n     *     serverPubKey: new Uint8Array(32),\n     * });\n     *\n     * console.log("script pub key:", vtxoScript.pkScript)\n     * ```\n     */\n    class Script extends base_1.VtxoScript {\n        constructor(options) {\n            const { pubKey, serverPubKey, csvTimelock = Script.DEFAULT_TIMELOCK, } = options;\n            const forfeitScript = tapscript_1.MultisigTapscript.encode({\n                pubkeys: [pubKey, serverPubKey],\n            }).script;\n            const exitScript = tapscript_1.CSVMultisigTapscript.encode({\n                timelock: csvTimelock,\n                pubkeys: [pubKey],\n            }).script;\n            super([forfeitScript, exitScript]);\n            this.options = options;\n            this.forfeitScript = base_2.hex.encode(forfeitScript);\n            this.exitScript = base_2.hex.encode(exitScript);\n        }\n        forfeit() {\n            return this.findLeaf(this.forfeitScript);\n        }\n        exit() {\n            return this.findLeaf(this.exitScript);\n        }\n    }\n    Script.DEFAULT_TIMELOCK = {\n        value: 144n,\n        type: "blocks",\n    }; // 1 day in blocks\n    DefaultVtxo.Script = Script;\n})(DefaultVtxo || (exports.DefaultVtxo = DefaultVtxo = {}));\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/script/default.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/script/tapscript.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.CLTVMultisigTapscript = exports.ConditionMultisigTapscript = exports.ConditionCSVMultisigTapscript = exports.CSVMultisigTapscript = exports.MultisigTapscript = exports.TapscriptType = void 0;\nexports.decodeTapscript = decodeTapscript;\nconst bip68 = __importStar(__webpack_require__(/*! bip68 */ "./node_modules/bip68/index.js"));\nconst script_1 = __webpack_require__(/*! @scure/btc-signer/script */ "./node_modules/@scure/btc-signer/script.js");\nconst payment_1 = __webpack_require__(/*! @scure/btc-signer/payment */ "./node_modules/@scure/btc-signer/payment.js");\nconst base_1 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nconst MinimalScriptNum = (0, script_1.ScriptNum)(undefined, true);\nvar TapscriptType;\n(function (TapscriptType) {\n    TapscriptType["Multisig"] = "multisig";\n    TapscriptType["CSVMultisig"] = "csv-multisig";\n    TapscriptType["ConditionCSVMultisig"] = "condition-csv-multisig";\n    TapscriptType["ConditionMultisig"] = "condition-multisig";\n    TapscriptType["CLTVMultisig"] = "cltv-multisig";\n})(TapscriptType || (exports.TapscriptType = TapscriptType = {}));\n/**\n * decodeTapscript is a function that decodes an ark tapsript from a raw script.\n *\n * @throws {Error} if the script is not a valid ark tapscript\n * @example\n * ```typescript\n * const arkTapscript = decodeTapscript(new Uint8Array(32));\n * console.log("type:", arkTapscript.type);\n * ```\n */\nfunction decodeTapscript(script) {\n    const types = [\n        MultisigTapscript,\n        CSVMultisigTapscript,\n        ConditionCSVMultisigTapscript,\n        ConditionMultisigTapscript,\n        CLTVMultisigTapscript,\n    ];\n    for (const type of types) {\n        try {\n            return type.decode(script);\n        }\n        catch (error) {\n            continue;\n        }\n    }\n    throw new Error(`Failed to decode: script ${base_1.hex.encode(script)} is not a valid tapscript`);\n}\n/**\n * Implements a multi-signature tapscript.\n *\n * <pubkey> CHECKSIGVERIFY <pubkey> CHECKSIG\n *\n * @example\n * ```typescript\n * const multisigTapscript = MultisigTapscript.encode({ pubkeys: [new Uint8Array(32), new Uint8Array(32)] });\n * ```\n */\nvar MultisigTapscript;\n(function (MultisigTapscript) {\n    let MultisigType;\n    (function (MultisigType) {\n        MultisigType[MultisigType["CHECKSIG"] = 0] = "CHECKSIG";\n        MultisigType[MultisigType["CHECKSIGADD"] = 1] = "CHECKSIGADD";\n    })(MultisigType = MultisigTapscript.MultisigType || (MultisigTapscript.MultisigType = {}));\n    function encode(params) {\n        if (params.pubkeys.length === 0) {\n            throw new Error("At least 1 pubkey is required");\n        }\n        for (const pubkey of params.pubkeys) {\n            if (pubkey.length !== 32) {\n                throw new Error(`Invalid pubkey length: expected 32, got ${pubkey.length}`);\n            }\n        }\n        if (!params.type) {\n            params.type = MultisigType.CHECKSIG;\n        }\n        if (params.type === MultisigType.CHECKSIGADD) {\n            return {\n                type: TapscriptType.Multisig,\n                params,\n                script: (0, payment_1.p2tr_ms)(params.pubkeys.length, params.pubkeys).script,\n            };\n        }\n        const asm = [];\n        for (let i = 0; i < params.pubkeys.length; i++) {\n            asm.push(params.pubkeys[i]);\n            // CHECKSIGVERIFY except the last pubkey\n            if (i < params.pubkeys.length - 1) {\n                asm.push("CHECKSIGVERIFY");\n            }\n            else {\n                asm.push("CHECKSIG");\n            }\n        }\n        return {\n            type: TapscriptType.Multisig,\n            params,\n            script: script_1.Script.encode(asm),\n        };\n    }\n    MultisigTapscript.encode = encode;\n    function decode(script) {\n        if (script.length === 0) {\n            throw new Error("Failed to decode: script is empty");\n        }\n        try {\n            // Try decoding as checksigAdd first\n            return decodeChecksigAdd(script);\n        }\n        catch (error) {\n            // If checksigAdd fails, try regular checksig\n            try {\n                return decodeChecksig(script);\n            }\n            catch (error2) {\n                throw new Error(`Failed to decode script: ${error2 instanceof Error ? error2.message : String(error2)}`);\n            }\n        }\n    }\n    MultisigTapscript.decode = decode;\n    // <pubkey> CHECKSIG <pubkey> CHECKSIGADD <len_keys> NUMEQUAL\n    function decodeChecksigAdd(script) {\n        const asm = script_1.Script.decode(script);\n        const pubkeys = [];\n        let foundNumEqual = false;\n        // Parse through ASM operations\n        for (let i = 0; i < asm.length; i++) {\n            const op = asm[i];\n            // If it\'s a data push, it should be a 32-byte pubkey\n            if (typeof op !== "string" && typeof op !== "number") {\n                if (op.length !== 32) {\n                    throw new Error(`Invalid pubkey length: expected 32, got ${op.length}`);\n                }\n                pubkeys.push(op);\n                // Check next operation is CHECKSIGADD or CHECKSIG\n                if (i + 1 >= asm.length ||\n                    (asm[i + 1] !== "CHECKSIGADD" && asm[i + 1] !== "CHECKSIG")) {\n                    throw new Error("Expected CHECKSIGADD or CHECKSIG after pubkey");\n                }\n                i++; // Skip the CHECKSIGADD op\n                continue;\n            }\n            // Last operation should be NUMEQUAL\n            if (i === asm.length - 1) {\n                if (op !== "NUMEQUAL") {\n                    throw new Error("Expected NUMEQUAL at end of script");\n                }\n                foundNumEqual = true;\n            }\n        }\n        if (!foundNumEqual) {\n            throw new Error("Missing NUMEQUAL operation");\n        }\n        if (pubkeys.length === 0) {\n            throw new Error("Invalid script: must have at least 1 pubkey");\n        }\n        // Verify the script by re-encoding and comparing\n        const reconstructed = encode({\n            pubkeys,\n            type: MultisigType.CHECKSIGADD,\n        });\n        if (base_1.hex.encode(reconstructed.script) !== base_1.hex.encode(script)) {\n            throw new Error("Invalid script format: script reconstruction mismatch");\n        }\n        return {\n            type: TapscriptType.Multisig,\n            params: { pubkeys, type: MultisigType.CHECKSIGADD },\n            script,\n        };\n    }\n    // <pubkey> CHECKSIGVERIFY <pubkey> CHECKSIG\n    function decodeChecksig(script) {\n        const asm = script_1.Script.decode(script);\n        const pubkeys = [];\n        // Parse through ASM operations\n        for (let i = 0; i < asm.length; i++) {\n            const op = asm[i];\n            // If it\'s a data push, it should be a 32-byte pubkey\n            if (typeof op !== "string" && typeof op !== "number") {\n                if (op.length !== 32) {\n                    throw new Error(`Invalid pubkey length: expected 32, got ${op.length}`);\n                }\n                pubkeys.push(op);\n                // Check next operation\n                if (i + 1 >= asm.length) {\n                    throw new Error("Unexpected end of script");\n                }\n                const nextOp = asm[i + 1];\n                if (nextOp !== "CHECKSIGVERIFY" && nextOp !== "CHECKSIG") {\n                    throw new Error("Expected CHECKSIGVERIFY or CHECKSIG after pubkey");\n                }\n                // Last operation must be CHECKSIG, not CHECKSIGVERIFY\n                if (i === asm.length - 2 && nextOp !== "CHECKSIG") {\n                    throw new Error("Last operation must be CHECKSIG");\n                }\n                i++; // Skip the CHECKSIG/CHECKSIGVERIFY op\n                continue;\n            }\n        }\n        if (pubkeys.length === 0) {\n            throw new Error("Invalid script: must have at least 1 pubkey");\n        }\n        // Verify the script by re-encoding and comparing\n        const reconstructed = encode({ pubkeys, type: MultisigType.CHECKSIG });\n        if (base_1.hex.encode(reconstructed.script) !== base_1.hex.encode(script)) {\n            throw new Error("Invalid script format: script reconstruction mismatch");\n        }\n        return {\n            type: TapscriptType.Multisig,\n            params: { pubkeys, type: MultisigType.CHECKSIG },\n            script,\n        };\n    }\n    function is(tapscript) {\n        return tapscript.type === TapscriptType.Multisig;\n    }\n    MultisigTapscript.is = is;\n})(MultisigTapscript || (exports.MultisigTapscript = MultisigTapscript = {}));\n/**\n * Implements a relative timelock script that requires all specified pubkeys to sign\n * after the relative timelock has expired. The timelock can be specified in blocks or seconds.\n *\n * This is the standard exit closure and it is also used for the sweep closure in vtxo trees.\n *\n * <sequence> CHECKSEQUENCEVERIFY DROP <pubkey> CHECKSIG\n *\n * @example\n * ```typescript\n * const csvMultisigTapscript = CSVMultisigTapscript.encode({ timelock: { type: "blocks", value: 144 }, pubkeys: [new Uint8Array(32), new Uint8Array(32)] });\n * ```\n */\nvar CSVMultisigTapscript;\n(function (CSVMultisigTapscript) {\n    function encode(params) {\n        for (const pubkey of params.pubkeys) {\n            if (pubkey.length !== 32) {\n                throw new Error(`Invalid pubkey length: expected 32, got ${pubkey.length}`);\n            }\n        }\n        const sequence = MinimalScriptNum.encode(BigInt(bip68.encode(params.timelock.type === "blocks"\n            ? { blocks: Number(params.timelock.value) }\n            : { seconds: Number(params.timelock.value) })));\n        const asm = [\n            sequence.length === 1 ? sequence[0] : sequence,\n            "CHECKSEQUENCEVERIFY",\n            "DROP",\n        ];\n        const multisigScript = MultisigTapscript.encode(params);\n        const script = new Uint8Array([\n            ...script_1.Script.encode(asm),\n            ...multisigScript.script,\n        ]);\n        return {\n            type: TapscriptType.CSVMultisig,\n            params,\n            script,\n        };\n    }\n    CSVMultisigTapscript.encode = encode;\n    function decode(script) {\n        if (script.length === 0) {\n            throw new Error("Failed to decode: script is empty");\n        }\n        const asm = script_1.Script.decode(script);\n        if (asm.length < 3) {\n            throw new Error(`Invalid script: too short (expected at least 3)`);\n        }\n        const sequence = asm[0];\n        if (typeof sequence === "string" || typeof sequence === "number") {\n            throw new Error("Invalid script: expected sequence number");\n        }\n        if (asm[1] !== "CHECKSEQUENCEVERIFY" || asm[2] !== "DROP") {\n            throw new Error("Invalid script: expected CHECKSEQUENCEVERIFY DROP");\n        }\n        const multisigScript = new Uint8Array(script_1.Script.encode(asm.slice(3)));\n        let multisig;\n        try {\n            multisig = MultisigTapscript.decode(multisigScript);\n        }\n        catch (error) {\n            throw new Error(`Invalid multisig script: ${error instanceof Error ? error.message : String(error)}`);\n        }\n        const sequenceNum = Number(MinimalScriptNum.decode(sequence));\n        const decodedTimelock = bip68.decode(sequenceNum);\n        const timelock = decodedTimelock.blocks !== undefined\n            ? { type: "blocks", value: BigInt(decodedTimelock.blocks) }\n            : { type: "seconds", value: BigInt(decodedTimelock.seconds) };\n        const reconstructed = encode({\n            timelock,\n            ...multisig.params,\n        });\n        if (base_1.hex.encode(reconstructed.script) !== base_1.hex.encode(script)) {\n            throw new Error("Invalid script format: script reconstruction mismatch");\n        }\n        return {\n            type: TapscriptType.CSVMultisig,\n            params: {\n                timelock,\n                ...multisig.params,\n            },\n            script,\n        };\n    }\n    CSVMultisigTapscript.decode = decode;\n    function is(tapscript) {\n        return tapscript.type === TapscriptType.CSVMultisig;\n    }\n    CSVMultisigTapscript.is = is;\n})(CSVMultisigTapscript || (exports.CSVMultisigTapscript = CSVMultisigTapscript = {}));\n/**\n * Combines a condition script with an exit closure. The resulting script requires\n * the condition to be met, followed by the standard exit closure requirements\n * (timelock and signatures).\n *\n * <conditionScript> VERIFY <sequence> CHECKSEQUENCEVERIFY DROP <pubkey> CHECKSIGVERIFY <pubkey> CHECKSIG\n *\n * @example\n * ```typescript\n * const conditionCSVMultisigTapscript = ConditionCSVMultisigTapscript.encode({ conditionScript: new Uint8Array(32), pubkeys: [new Uint8Array(32), new Uint8Array(32)] });\n * ```\n */\nvar ConditionCSVMultisigTapscript;\n(function (ConditionCSVMultisigTapscript) {\n    function encode(params) {\n        const script = new Uint8Array([\n            ...params.conditionScript,\n            ...script_1.Script.encode(["VERIFY"]),\n            ...CSVMultisigTapscript.encode(params).script,\n        ]);\n        return {\n            type: TapscriptType.ConditionCSVMultisig,\n            params,\n            script,\n        };\n    }\n    ConditionCSVMultisigTapscript.encode = encode;\n    function decode(script) {\n        if (script.length === 0) {\n            throw new Error("Failed to decode: script is empty");\n        }\n        const asm = script_1.Script.decode(script);\n        if (asm.length < 1) {\n            throw new Error(`Invalid script: too short (expected at least 1)`);\n        }\n        let verifyIndex = -1;\n        for (let i = asm.length - 1; i >= 0; i--) {\n            if (asm[i] === "VERIFY") {\n                verifyIndex = i;\n            }\n        }\n        if (verifyIndex === -1) {\n            throw new Error("Invalid script: missing VERIFY operation");\n        }\n        const conditionScript = new Uint8Array(script_1.Script.encode(asm.slice(0, verifyIndex)));\n        const csvMultisigScript = new Uint8Array(script_1.Script.encode(asm.slice(verifyIndex + 1)));\n        let csvMultisig;\n        try {\n            csvMultisig = CSVMultisigTapscript.decode(csvMultisigScript);\n        }\n        catch (error) {\n            throw new Error(`Invalid CSV multisig script: ${error instanceof Error ? error.message : String(error)}`);\n        }\n        const reconstructed = encode({\n            conditionScript,\n            ...csvMultisig.params,\n        });\n        if (base_1.hex.encode(reconstructed.script) !== base_1.hex.encode(script)) {\n            throw new Error("Invalid script format: script reconstruction mismatch");\n        }\n        return {\n            type: TapscriptType.ConditionCSVMultisig,\n            params: {\n                conditionScript,\n                ...csvMultisig.params,\n            },\n            script,\n        };\n    }\n    ConditionCSVMultisigTapscript.decode = decode;\n    function is(tapscript) {\n        return tapscript.type === TapscriptType.ConditionCSVMultisig;\n    }\n    ConditionCSVMultisigTapscript.is = is;\n})(ConditionCSVMultisigTapscript || (exports.ConditionCSVMultisigTapscript = ConditionCSVMultisigTapscript = {}));\n/**\n * Combines a condition script with a forfeit closure. The resulting script requires\n * the condition to be met, followed by the standard forfeit closure requirements\n * (multi-signature).\n *\n * <conditionScript> VERIFY <pubkey> CHECKSIGVERIFY <pubkey> CHECKSIG\n *\n * @example\n * ```typescript\n * const conditionMultisigTapscript = ConditionMultisigTapscript.encode({ conditionScript: new Uint8Array(32), pubkeys: [new Uint8Array(32), new Uint8Array(32)] });\n * ```\n */\nvar ConditionMultisigTapscript;\n(function (ConditionMultisigTapscript) {\n    function encode(params) {\n        const script = new Uint8Array([\n            ...params.conditionScript,\n            ...script_1.Script.encode(["VERIFY"]),\n            ...MultisigTapscript.encode(params).script,\n        ]);\n        return {\n            type: TapscriptType.ConditionMultisig,\n            params,\n            script,\n        };\n    }\n    ConditionMultisigTapscript.encode = encode;\n    function decode(script) {\n        if (script.length === 0) {\n            throw new Error("Failed to decode: script is empty");\n        }\n        const asm = script_1.Script.decode(script);\n        if (asm.length < 1) {\n            throw new Error(`Invalid script: too short (expected at least 1)`);\n        }\n        let verifyIndex = -1;\n        for (let i = asm.length - 1; i >= 0; i--) {\n            if (asm[i] === "VERIFY") {\n                verifyIndex = i;\n            }\n        }\n        if (verifyIndex === -1) {\n            throw new Error("Invalid script: missing VERIFY operation");\n        }\n        const conditionScript = new Uint8Array(script_1.Script.encode(asm.slice(0, verifyIndex)));\n        const multisigScript = new Uint8Array(script_1.Script.encode(asm.slice(verifyIndex + 1)));\n        let multisig;\n        try {\n            multisig = MultisigTapscript.decode(multisigScript);\n        }\n        catch (error) {\n            throw new Error(`Invalid multisig script: ${error instanceof Error ? error.message : String(error)}`);\n        }\n        const reconstructed = encode({\n            conditionScript,\n            ...multisig.params,\n        });\n        if (base_1.hex.encode(reconstructed.script) !== base_1.hex.encode(script)) {\n            throw new Error("Invalid script format: script reconstruction mismatch");\n        }\n        return {\n            type: TapscriptType.ConditionMultisig,\n            params: {\n                conditionScript,\n                ...multisig.params,\n            },\n            script,\n        };\n    }\n    ConditionMultisigTapscript.decode = decode;\n    function is(tapscript) {\n        return tapscript.type === TapscriptType.ConditionMultisig;\n    }\n    ConditionMultisigTapscript.is = is;\n})(ConditionMultisigTapscript || (exports.ConditionMultisigTapscript = ConditionMultisigTapscript = {}));\n/**\n * Implements an absolute timelock (CLTV) script combined with a forfeit closure.\n * The script requires waiting until a specific block height/timestamp before the\n * forfeit closure conditions can be met.\n *\n * <locktime> CHECKLOCKTIMEVERIFY DROP <pubkey> CHECKSIGVERIFY <pubkey> CHECKSIG\n *\n * @example\n * ```typescript\n * const cltvMultisigTapscript = CLTVMultisigTapscript.encode({ absoluteTimelock: 144, pubkeys: [new Uint8Array(32), new Uint8Array(32)] });\n * ```\n */\nvar CLTVMultisigTapscript;\n(function (CLTVMultisigTapscript) {\n    function encode(params) {\n        const locktime = MinimalScriptNum.encode(params.absoluteTimelock);\n        const asm = [\n            locktime.length === 1 ? locktime[0] : locktime,\n            "CHECKLOCKTIMEVERIFY",\n            "DROP",\n        ];\n        const timelockedScript = script_1.Script.encode(asm);\n        const script = new Uint8Array([\n            ...timelockedScript,\n            ...MultisigTapscript.encode(params).script,\n        ]);\n        return {\n            type: TapscriptType.CLTVMultisig,\n            params,\n            script,\n        };\n    }\n    CLTVMultisigTapscript.encode = encode;\n    function decode(script) {\n        if (script.length === 0) {\n            throw new Error("Failed to decode: script is empty");\n        }\n        const asm = script_1.Script.decode(script);\n        if (asm.length < 3) {\n            throw new Error(`Invalid script: too short (expected at least 3)`);\n        }\n        const locktime = asm[0];\n        if (typeof locktime === "string" || typeof locktime === "number") {\n            throw new Error("Invalid script: expected locktime number");\n        }\n        if (asm[1] !== "CHECKLOCKTIMEVERIFY" || asm[2] !== "DROP") {\n            throw new Error("Invalid script: expected CHECKLOCKTIMEVERIFY DROP");\n        }\n        const multisigScript = new Uint8Array(script_1.Script.encode(asm.slice(3)));\n        let multisig;\n        try {\n            multisig = MultisigTapscript.decode(multisigScript);\n        }\n        catch (error) {\n            throw new Error(`Invalid multisig script: ${error instanceof Error ? error.message : String(error)}`);\n        }\n        const absoluteTimelock = MinimalScriptNum.decode(locktime);\n        const reconstructed = encode({\n            absoluteTimelock,\n            ...multisig.params,\n        });\n        if (base_1.hex.encode(reconstructed.script) !== base_1.hex.encode(script)) {\n            throw new Error("Invalid script format: script reconstruction mismatch");\n        }\n        return {\n            type: TapscriptType.CLTVMultisig,\n            params: {\n                absoluteTimelock,\n                ...multisig.params,\n            },\n            script,\n        };\n    }\n    CLTVMultisigTapscript.decode = decode;\n    function is(tapscript) {\n        return tapscript.type === TapscriptType.CLTVMultisig;\n    }\n    CLTVMultisigTapscript.is = is;\n})(CLTVMultisigTapscript || (exports.CLTVMultisigTapscript = CLTVMultisigTapscript = {}));\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/script/tapscript.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/script/vhtlc.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.VHTLC = void 0;\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\nconst tapscript_1 = __webpack_require__(/*! ./tapscript */ "./node_modules/@arkade-os/sdk/dist/cjs/script/tapscript.js");\nconst base_1 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nconst base_2 = __webpack_require__(/*! ./base */ "./node_modules/@arkade-os/sdk/dist/cjs/script/base.js");\n/**\n * Virtual Hash Time Lock Contract (VHTLC) implementation.\n *\n * VHTLC is a contract that enables atomic swaps and conditional payments\n * in the Ark protocol. It provides multiple spending paths:\n *\n * - **claim**: Receiver can claim funds by revealing the preimage\n * - **refund**: Sender and receiver can collaboratively refund\n * - **refundWithoutReceiver**: Sender can refund after locktime expires\n * - **unilateralClaim**: Receiver can claim unilaterally after delay\n * - **unilateralRefund**: Sender and receiver can refund unilaterally after delay\n * - **unilateralRefundWithoutReceiver**: Sender can refund unilaterally after delay\n *\n * @example\n * ```typescript\n * const vhtlc = new VHTLC.Script({\n *   sender: alicePubKey,\n *   receiver: bobPubKey,\n *   server: serverPubKey,\n *   preimageHash: hash160(secret),\n *   refundLocktime: BigInt(chainTip + 10),\n *   unilateralClaimDelay: { type: \'blocks\', value: 100n },\n *   unilateralRefundDelay: { type: \'blocks\', value: 102n },\n *   unilateralRefundWithoutReceiverDelay: { type: \'blocks\', value: 103n }\n * });\n * ```\n */\nvar VHTLC;\n(function (VHTLC) {\n    class Script extends base_2.VtxoScript {\n        constructor(options) {\n            validateOptions(options);\n            const { sender, receiver, server, preimageHash, refundLocktime, unilateralClaimDelay, unilateralRefundDelay, unilateralRefundWithoutReceiverDelay, } = options;\n            const conditionScript = preimageConditionScript(preimageHash);\n            const claimScript = tapscript_1.ConditionMultisigTapscript.encode({\n                conditionScript,\n                pubkeys: [receiver, server],\n            }).script;\n            const refundScript = tapscript_1.MultisigTapscript.encode({\n                pubkeys: [sender, receiver, server],\n            }).script;\n            const refundWithoutReceiverScript = tapscript_1.CLTVMultisigTapscript.encode({\n                absoluteTimelock: refundLocktime,\n                pubkeys: [sender, server],\n            }).script;\n            const unilateralClaimScript = tapscript_1.ConditionCSVMultisigTapscript.encode({\n                conditionScript,\n                timelock: unilateralClaimDelay,\n                pubkeys: [receiver],\n            }).script;\n            const unilateralRefundScript = tapscript_1.CSVMultisigTapscript.encode({\n                timelock: unilateralRefundDelay,\n                pubkeys: [sender, receiver],\n            }).script;\n            const unilateralRefundWithoutReceiverScript = tapscript_1.CSVMultisigTapscript.encode({\n                timelock: unilateralRefundWithoutReceiverDelay,\n                pubkeys: [sender],\n            }).script;\n            super([\n                claimScript,\n                refundScript,\n                refundWithoutReceiverScript,\n                unilateralClaimScript,\n                unilateralRefundScript,\n                unilateralRefundWithoutReceiverScript,\n            ]);\n            this.options = options;\n            this.claimScript = base_1.hex.encode(claimScript);\n            this.refundScript = base_1.hex.encode(refundScript);\n            this.refundWithoutReceiverScript = base_1.hex.encode(refundWithoutReceiverScript);\n            this.unilateralClaimScript = base_1.hex.encode(unilateralClaimScript);\n            this.unilateralRefundScript = base_1.hex.encode(unilateralRefundScript);\n            this.unilateralRefundWithoutReceiverScript = base_1.hex.encode(unilateralRefundWithoutReceiverScript);\n        }\n        claim() {\n            return this.findLeaf(this.claimScript);\n        }\n        refund() {\n            return this.findLeaf(this.refundScript);\n        }\n        refundWithoutReceiver() {\n            return this.findLeaf(this.refundWithoutReceiverScript);\n        }\n        unilateralClaim() {\n            return this.findLeaf(this.unilateralClaimScript);\n        }\n        unilateralRefund() {\n            return this.findLeaf(this.unilateralRefundScript);\n        }\n        unilateralRefundWithoutReceiver() {\n            return this.findLeaf(this.unilateralRefundWithoutReceiverScript);\n        }\n    }\n    VHTLC.Script = Script;\n    function validateOptions(options) {\n        const { sender, receiver, server, preimageHash, refundLocktime, unilateralClaimDelay, unilateralRefundDelay, unilateralRefundWithoutReceiverDelay, } = options;\n        if (!preimageHash || preimageHash.length !== 20) {\n            throw new Error("preimage hash must be 20 bytes");\n        }\n        if (!receiver || receiver.length !== 32) {\n            throw new Error("Invalid public key length (receiver)");\n        }\n        if (!sender || sender.length !== 32) {\n            throw new Error("Invalid public key length (sender)");\n        }\n        if (!server || server.length !== 32) {\n            throw new Error("Invalid public key length (server)");\n        }\n        if (typeof refundLocktime !== "bigint" || refundLocktime <= 0n) {\n            throw new Error("refund locktime must be greater than 0");\n        }\n        if (!unilateralClaimDelay ||\n            typeof unilateralClaimDelay.value !== "bigint" ||\n            unilateralClaimDelay.value <= 0n) {\n            throw new Error("unilateral claim delay must greater than 0");\n        }\n        if (unilateralClaimDelay.type === "seconds" &&\n            unilateralClaimDelay.value % 512n !== 0n) {\n            throw new Error("seconds timelock must be multiple of 512");\n        }\n        if (unilateralClaimDelay.type === "seconds" &&\n            unilateralClaimDelay.value < 512n) {\n            throw new Error("seconds timelock must be greater or equal to 512");\n        }\n        if (!unilateralRefundDelay ||\n            typeof unilateralRefundDelay.value !== "bigint" ||\n            unilateralRefundDelay.value <= 0n) {\n            throw new Error("unilateral refund delay must greater than 0");\n        }\n        if (unilateralRefundDelay.type === "seconds" &&\n            unilateralRefundDelay.value % 512n !== 0n) {\n            throw new Error("seconds timelock must be multiple of 512");\n        }\n        if (unilateralRefundDelay.type === "seconds" &&\n            unilateralRefundDelay.value < 512n) {\n            throw new Error("seconds timelock must be greater or equal to 512");\n        }\n        if (!unilateralRefundWithoutReceiverDelay ||\n            typeof unilateralRefundWithoutReceiverDelay.value !== "bigint" ||\n            unilateralRefundWithoutReceiverDelay.value <= 0n) {\n            throw new Error("unilateral refund without receiver delay must greater than 0");\n        }\n        if (unilateralRefundWithoutReceiverDelay.type === "seconds" &&\n            unilateralRefundWithoutReceiverDelay.value % 512n !== 0n) {\n            throw new Error("seconds timelock must be multiple of 512");\n        }\n        if (unilateralRefundWithoutReceiverDelay.type === "seconds" &&\n            unilateralRefundWithoutReceiverDelay.value < 512n) {\n            throw new Error("seconds timelock must be greater or equal to 512");\n        }\n    }\n})(VHTLC || (exports.VHTLC = VHTLC = {}));\nfunction preimageConditionScript(preimageHash) {\n    return btc_signer_1.Script.encode(["HASH160", preimageHash, "EQUAL"]);\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/script/vhtlc.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/tree/signingSession.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.TreeSignerSession = exports.ErrMissingAggregateKey = exports.ErrMissingVtxoGraph = void 0;\nexports.validateTreeSigs = validateTreeSigs;\nconst musig2 = __importStar(__webpack_require__(/*! ../musig2 */ "./node_modules/@arkade-os/sdk/dist/cjs/musig2/index.js"));\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\nconst base_1 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nconst secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ "./node_modules/@noble/curves/secp256k1.js");\nconst utils_1 = __webpack_require__(/*! @scure/btc-signer/utils */ "./node_modules/@scure/btc-signer/utils.js");\nconst unknownFields_1 = __webpack_require__(/*! ../utils/unknownFields */ "./node_modules/@arkade-os/sdk/dist/cjs/utils/unknownFields.js");\nexports.ErrMissingVtxoGraph = new Error("missing vtxo graph");\nexports.ErrMissingAggregateKey = new Error("missing aggregate key");\nclass TreeSignerSession {\n    constructor(secretKey) {\n        this.secretKey = secretKey;\n        this.myNonces = null;\n        this.aggregateNonces = null;\n        this.graph = null;\n        this.scriptRoot = null;\n        this.rootSharedOutputAmount = null;\n    }\n    static random() {\n        const secretKey = (0, utils_1.randomPrivateKeyBytes)();\n        return new TreeSignerSession(secretKey);\n    }\n    init(tree, scriptRoot, rootInputAmount) {\n        this.graph = tree;\n        this.scriptRoot = scriptRoot;\n        this.rootSharedOutputAmount = rootInputAmount;\n    }\n    getPublicKey() {\n        return secp256k1_1.secp256k1.getPublicKey(this.secretKey);\n    }\n    getNonces() {\n        if (!this.graph)\n            throw exports.ErrMissingVtxoGraph;\n        if (!this.myNonces) {\n            this.myNonces = this.generateNonces();\n        }\n        const publicNonces = new Map();\n        for (const [txid, nonces] of this.myNonces) {\n            publicNonces.set(txid, { pubNonce: nonces.pubNonce });\n        }\n        return publicNonces;\n    }\n    setAggregatedNonces(nonces) {\n        if (this.aggregateNonces)\n            throw new Error("nonces already set");\n        this.aggregateNonces = nonces;\n    }\n    sign() {\n        if (!this.graph)\n            throw exports.ErrMissingVtxoGraph;\n        if (!this.aggregateNonces)\n            throw new Error("nonces not set");\n        if (!this.myNonces)\n            throw new Error("nonces not generated");\n        const sigs = new Map();\n        for (const g of this.graph) {\n            const sig = this.signPartial(g);\n            sigs.set(g.txid, sig);\n        }\n        return sigs;\n    }\n    generateNonces() {\n        if (!this.graph)\n            throw exports.ErrMissingVtxoGraph;\n        const myNonces = new Map();\n        const publicKey = secp256k1_1.secp256k1.getPublicKey(this.secretKey);\n        for (const g of this.graph) {\n            const nonces = musig2.generateNonces(publicKey);\n            myNonces.set(g.txid, nonces);\n        }\n        return myNonces;\n    }\n    signPartial(g) {\n        if (!this.graph || !this.scriptRoot || !this.rootSharedOutputAmount) {\n            throw TreeSignerSession.NOT_INITIALIZED;\n        }\n        if (!this.myNonces || !this.aggregateNonces) {\n            throw new Error("session not properly initialized");\n        }\n        const myNonce = this.myNonces.get(g.txid);\n        if (!myNonce)\n            throw new Error("missing private nonce");\n        const aggNonce = this.aggregateNonces.get(g.txid);\n        if (!aggNonce)\n            throw new Error("missing aggregate nonce");\n        const prevoutAmounts = [];\n        const prevoutScripts = [];\n        const cosigners = (0, unknownFields_1.getArkPsbtFields)(g.root, 0, unknownFields_1.CosignerPublicKey).map((c) => c.key);\n        const { finalKey } = musig2.aggregateKeys(cosigners, true, {\n            taprootTweak: this.scriptRoot,\n        });\n        for (let inputIndex = 0; inputIndex < g.root.inputsLength; inputIndex++) {\n            const prevout = getPrevOutput(finalKey, this.graph, this.rootSharedOutputAmount, g.root);\n            prevoutAmounts.push(prevout.amount);\n            prevoutScripts.push(prevout.script);\n        }\n        const message = g.root.preimageWitnessV1(0, // always first input\n        prevoutScripts, btc_signer_1.SigHash.DEFAULT, prevoutAmounts);\n        return musig2.sign(myNonce.secNonce, this.secretKey, aggNonce.pubNonce, cosigners, message, {\n            taprootTweak: this.scriptRoot,\n            sortKeys: true,\n        });\n    }\n}\nexports.TreeSignerSession = TreeSignerSession;\nTreeSignerSession.NOT_INITIALIZED = new Error("session not initialized, call init method");\n// Helper function to validate tree signatures\nasync function validateTreeSigs(finalAggregatedKey, sharedOutputAmount, vtxoTree) {\n    // Iterate through each level of the tree\n    for (const g of vtxoTree) {\n        // Parse the transaction\n        const input = g.root.getInput(0);\n        // Check if input has signature\n        if (!input.tapKeySig) {\n            throw new Error("unsigned tree input");\n        }\n        // Get the previous output information\n        const prevout = getPrevOutput(finalAggregatedKey, vtxoTree, sharedOutputAmount, g.root);\n        // Calculate the message that was signed\n        const message = g.root.preimageWitnessV1(0, // always first input\n        [prevout.script], btc_signer_1.SigHash.DEFAULT, [prevout.amount]);\n        // Verify the signature\n        const isValid = secp256k1_1.schnorr.verify(input.tapKeySig, message, finalAggregatedKey);\n        if (!isValid) {\n            throw new Error("invalid signature");\n        }\n    }\n}\nfunction getPrevOutput(finalKey, graph, sharedOutputAmount, tx) {\n    // generate P2TR script from musig2 final key\n    const pkScript = btc_signer_1.Script.encode(["OP_1", finalKey.slice(1)]);\n    const txid = base_1.hex.encode((0, utils_1.sha256x2)(tx.toBytes(true)).reverse());\n    // if the input is the root input, return the shared output amount\n    if (txid === graph.txid) {\n        return {\n            amount: sharedOutputAmount,\n            script: pkScript,\n        };\n    }\n    // find the parent transaction\n    const parentInput = tx.getInput(0);\n    if (!parentInput.txid)\n        throw new Error("missing parent input txid");\n    const parentTxid = base_1.hex.encode(new Uint8Array(parentInput.txid));\n    const parent = graph.find(parentTxid);\n    if (!parent)\n        throw new Error("parent  tx not found");\n    if (parentInput.index === undefined)\n        throw new Error("missing input index");\n    const parentOutput = parent.root.getOutput(parentInput.index);\n    if (!parentOutput)\n        throw new Error("parent output not found");\n    if (!parentOutput.amount)\n        throw new Error("parent output amount not found");\n    return {\n        amount: parentOutput.amount,\n        script: pkScript,\n    };\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/tree/signingSession.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/tree/txTree.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.TxTree = void 0;\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\nconst base_1 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nconst base_2 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nconst utils_1 = __webpack_require__(/*! @scure/btc-signer/utils */ "./node_modules/@scure/btc-signer/utils.js");\n/**\n * TxTree is a graph of bitcoin transactions.\n * It is used to represent batch tree created during settlement session\n */\nclass TxTree {\n    constructor(root, children = new Map()) {\n        this.root = root;\n        this.children = children;\n    }\n    static create(chunks) {\n        if (chunks.length === 0) {\n            throw new Error("empty chunks");\n        }\n        // Create a map to store all chunks by their txid for easy lookup\n        const chunksByTxid = new Map();\n        for (const chunk of chunks) {\n            const decodedChunk = decodeNode(chunk);\n            const txid = base_2.hex.encode((0, utils_1.sha256x2)(decodedChunk.tx.toBytes(true)).reverse());\n            chunksByTxid.set(txid, decodedChunk);\n        }\n        // Find the root chunks (the ones that aren\'t referenced as a child)\n        const rootTxids = [];\n        for (const [txid] of chunksByTxid) {\n            let isChild = false;\n            for (const [otherTxid, otherChunk] of chunksByTxid) {\n                if (otherTxid === txid) {\n                    // skip self\n                    continue;\n                }\n                // check if the current chunk is a child of the other chunk\n                isChild = hasChild(otherChunk, txid);\n                if (isChild) {\n                    break;\n                }\n            }\n            // if the chunk is not a child of any other chunk, it is a root\n            if (!isChild) {\n                rootTxids.push(txid);\n                continue;\n            }\n        }\n        if (rootTxids.length === 0) {\n            throw new Error("no root chunk found");\n        }\n        if (rootTxids.length > 1) {\n            throw new Error(`multiple root chunks found: ${rootTxids.join(", ")}`);\n        }\n        const graph = buildGraph(rootTxids[0], chunksByTxid);\n        if (!graph) {\n            throw new Error(`chunk not found for root txid: ${rootTxids[0]}`);\n        }\n        // verify that the number of chunks is equal to the number node in the graph\n        if (graph.nbOfNodes() !== chunks.length) {\n            throw new Error(`number of chunks (${chunks.length}) is not equal to the number of nodes in the graph (${graph.nbOfNodes()})`);\n        }\n        return graph;\n    }\n    nbOfNodes() {\n        let count = 1; // count this node\n        for (const child of this.children.values()) {\n            count += child.nbOfNodes();\n        }\n        return count;\n    }\n    validate() {\n        if (!this.root) {\n            throw new Error("unexpected nil root");\n        }\n        const nbOfOutputs = this.root.outputsLength;\n        const nbOfInputs = this.root.inputsLength;\n        if (nbOfInputs !== 1) {\n            throw new Error(`unexpected number of inputs: ${nbOfInputs}, expected 1`);\n        }\n        // the children map can\'t be bigger than the number of outputs (excluding the P2A)\n        // a graph can be "partial" and specify only some of the outputs as children,\n        // that\'s why we allow len(g.Children) to be less than nbOfOutputs-1\n        if (this.children.size > nbOfOutputs - 1) {\n            throw new Error(`unexpected number of children: ${this.children.size}, expected maximum ${nbOfOutputs - 1}`);\n        }\n        // validate each child\n        for (const [outputIndex, child] of this.children) {\n            if (outputIndex >= nbOfOutputs) {\n                throw new Error(`output index ${outputIndex} is out of bounds (nb of outputs: ${nbOfOutputs})`);\n            }\n            child.validate();\n            const childInput = child.root.getInput(0);\n            const parentTxid = base_2.hex.encode((0, utils_1.sha256x2)(this.root.toBytes(true)).reverse());\n            // verify the input of the child is the output of the parent\n            if (!childInput.txid ||\n                base_2.hex.encode(childInput.txid) !== parentTxid ||\n                childInput.index !== outputIndex) {\n                throw new Error(`input of child ${outputIndex} is not the output of the parent`);\n            }\n            // verify the sum of the child\'s outputs is equal to the output of the parent\n            let childOutputsSum = 0n;\n            for (let i = 0; i < child.root.outputsLength; i++) {\n                const output = child.root.getOutput(i);\n                if (output?.amount) {\n                    childOutputsSum += output.amount;\n                }\n            }\n            const parentOutput = this.root.getOutput(outputIndex);\n            if (!parentOutput?.amount) {\n                throw new Error(`parent output ${outputIndex} has no amount`);\n            }\n            if (childOutputsSum !== parentOutput.amount) {\n                throw new Error(`sum of child\'s outputs is not equal to the output of the parent: ${childOutputsSum} != ${parentOutput.amount}`);\n            }\n        }\n    }\n    leaves() {\n        if (this.children.size === 0) {\n            return [this.root];\n        }\n        const leaves = [];\n        for (const child of this.children.values()) {\n            leaves.push(...child.leaves());\n        }\n        return leaves;\n    }\n    get txid() {\n        return base_2.hex.encode((0, utils_1.sha256x2)(this.root.toBytes(true)).reverse());\n    }\n    find(txid) {\n        if (txid === this.txid) {\n            return this;\n        }\n        for (const child of this.children.values()) {\n            const found = child.find(txid);\n            if (found) {\n                return found;\n            }\n        }\n        return null;\n    }\n    update(txid, fn) {\n        if (txid === this.txid) {\n            fn(this.root);\n            return;\n        }\n        for (const child of this.children.values()) {\n            try {\n                child.update(txid, fn);\n                return;\n            }\n            catch (error) {\n                // Continue searching in other children if not found\n                continue;\n            }\n        }\n        throw new Error(`tx not found: ${txid}`);\n    }\n    *[Symbol.iterator]() {\n        yield this;\n        for (const child of this.children.values()) {\n            yield* child;\n        }\n    }\n}\nexports.TxTree = TxTree;\n// Helper function to check if a chunk has a specific child\nfunction hasChild(chunk, childTxid) {\n    return Object.values(chunk.children).includes(childTxid);\n}\n// buildGraph recursively builds the TxGraph starting from the given txid\nfunction buildGraph(rootTxid, chunksByTxid) {\n    const chunk = chunksByTxid.get(rootTxid);\n    if (!chunk) {\n        return null;\n    }\n    const rootTx = chunk.tx;\n    const children = new Map();\n    // Recursively build children graphs\n    for (const [outputIndexStr, childTxid] of Object.entries(chunk.children)) {\n        const outputIndex = parseInt(outputIndexStr);\n        const childGraph = buildGraph(childTxid, chunksByTxid);\n        if (childGraph) {\n            children.set(outputIndex, childGraph);\n        }\n    }\n    return new TxTree(rootTx, children);\n}\nfunction decodeNode(chunk) {\n    const tx = btc_signer_1.Transaction.fromPSBT(base_1.base64.decode(chunk.tx));\n    return { tx, children: chunk.children };\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/tree/txTree.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/tree/validation.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ErrMissingCosignersPublicKeys = exports.ErrWrongCommitmentTxid = exports.ErrInvalidRoundTxOutputs = exports.ErrInvalidTaprootScript = exports.ErrNoLeaves = exports.ErrInvalidAmount = exports.ErrWrongSettlementTxid = exports.ErrNumberOfInputs = exports.ErrEmptyTree = exports.ErrInvalidSettlementTxOutputs = exports.ErrInvalidSettlementTx = void 0;\nexports.validateConnectorsTxGraph = validateConnectorsTxGraph;\nexports.validateVtxoTxGraph = validateVtxoTxGraph;\nconst base_1 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\nconst base_2 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nconst utils_1 = __webpack_require__(/*! @scure/btc-signer/utils */ "./node_modules/@scure/btc-signer/utils.js");\nconst musig2_1 = __webpack_require__(/*! ../musig2 */ "./node_modules/@arkade-os/sdk/dist/cjs/musig2/index.js");\nconst unknownFields_1 = __webpack_require__(/*! ../utils/unknownFields */ "./node_modules/@arkade-os/sdk/dist/cjs/utils/unknownFields.js");\nconst ErrInvalidSettlementTx = (tx) => new Error(`invalid settlement transaction: ${tx}`);\nexports.ErrInvalidSettlementTx = ErrInvalidSettlementTx;\nexports.ErrInvalidSettlementTxOutputs = new Error("invalid settlement transaction outputs");\nexports.ErrEmptyTree = new Error("empty tree");\nexports.ErrNumberOfInputs = new Error("invalid number of inputs");\nexports.ErrWrongSettlementTxid = new Error("wrong settlement txid");\nexports.ErrInvalidAmount = new Error("invalid amount");\nexports.ErrNoLeaves = new Error("no leaves");\nexports.ErrInvalidTaprootScript = new Error("invalid taproot script");\nexports.ErrInvalidRoundTxOutputs = new Error("invalid round transaction outputs");\nexports.ErrWrongCommitmentTxid = new Error("wrong commitment txid");\nexports.ErrMissingCosignersPublicKeys = new Error("missing cosigners public keys");\nconst BATCH_OUTPUT_VTXO_INDEX = 0;\nconst BATCH_OUTPUT_CONNECTORS_INDEX = 1;\nfunction validateConnectorsTxGraph(settlementTxB64, connectorsGraph) {\n    connectorsGraph.validate();\n    if (connectorsGraph.root.inputsLength !== 1)\n        throw exports.ErrNumberOfInputs;\n    const rootInput = connectorsGraph.root.getInput(0);\n    const settlementTx = btc_signer_1.Transaction.fromPSBT(base_2.base64.decode(settlementTxB64));\n    if (settlementTx.outputsLength <= BATCH_OUTPUT_CONNECTORS_INDEX)\n        throw exports.ErrInvalidSettlementTxOutputs;\n    const expectedRootTxid = base_1.hex.encode((0, utils_1.sha256x2)(settlementTx.toBytes(true)).reverse());\n    if (!rootInput.txid)\n        throw exports.ErrWrongSettlementTxid;\n    if (base_1.hex.encode(rootInput.txid) !== expectedRootTxid)\n        throw exports.ErrWrongSettlementTxid;\n    if (rootInput.index !== BATCH_OUTPUT_CONNECTORS_INDEX)\n        throw exports.ErrWrongSettlementTxid;\n}\n// ValidateVtxoTxGraph checks if the given vtxo graph is valid.\n// The function validates:\n// - the number of nodes\n// - the number of leaves\n// - children coherence with parent.\n// - every control block and taproot output scripts.\n// - input and output amounts.\nfunction validateVtxoTxGraph(graph, roundTransaction, sweepTapTreeRoot) {\n    if (roundTransaction.outputsLength < BATCH_OUTPUT_VTXO_INDEX + 1) {\n        throw exports.ErrInvalidRoundTxOutputs;\n    }\n    const batchOutputAmount = roundTransaction.getOutput(BATCH_OUTPUT_VTXO_INDEX)?.amount;\n    if (!batchOutputAmount) {\n        throw exports.ErrInvalidRoundTxOutputs;\n    }\n    if (!graph.root) {\n        throw exports.ErrEmptyTree;\n    }\n    const rootInput = graph.root.getInput(0);\n    const commitmentTxid = base_1.hex.encode((0, utils_1.sha256x2)(roundTransaction.toBytes(true)).reverse());\n    if (!rootInput.txid ||\n        base_1.hex.encode(rootInput.txid) !== commitmentTxid ||\n        rootInput.index !== BATCH_OUTPUT_VTXO_INDEX) {\n        throw exports.ErrWrongCommitmentTxid;\n    }\n    let sumRootValue = 0n;\n    for (let i = 0; i < graph.root.outputsLength; i++) {\n        const output = graph.root.getOutput(i);\n        if (output?.amount) {\n            sumRootValue += output.amount;\n        }\n    }\n    if (sumRootValue !== batchOutputAmount) {\n        throw exports.ErrInvalidAmount;\n    }\n    const leaves = graph.leaves();\n    if (leaves.length === 0) {\n        throw exports.ErrNoLeaves;\n    }\n    // validate the graph structure\n    graph.validate();\n    // iterates over all the nodes of the graph to verify that cosigners public keys are corresponding to the parent output\n    for (const g of graph) {\n        for (const [childIndex, child] of g.children) {\n            const parentOutput = g.root.getOutput(childIndex);\n            if (!parentOutput?.script) {\n                throw new Error(`parent output ${childIndex} not found`);\n            }\n            const previousScriptKey = parentOutput.script.slice(2);\n            if (previousScriptKey.length !== 32) {\n                throw new Error(`parent output ${childIndex} has invalid script`);\n            }\n            const cosigners = (0, unknownFields_1.getArkPsbtFields)(child.root, 0, unknownFields_1.CosignerPublicKey);\n            if (cosigners.length === 0) {\n                throw exports.ErrMissingCosignersPublicKeys;\n            }\n            const cosignerKeys = cosigners.map((c) => c.key);\n            const { finalKey } = (0, musig2_1.aggregateKeys)(cosignerKeys, true, {\n                taprootTweak: sweepTapTreeRoot,\n            });\n            if (!finalKey ||\n                base_1.hex.encode(finalKey.slice(1)) !== base_1.hex.encode(previousScriptKey)) {\n                throw exports.ErrInvalidTaprootScript;\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/tree/validation.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/utils/anchor.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.P2A = exports.ANCHOR_PKSCRIPT = exports.ANCHOR_VALUE = void 0;\nexports.findP2AOutput = findP2AOutput;\nconst base_1 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nexports.ANCHOR_VALUE = 0n;\nexports.ANCHOR_PKSCRIPT = new Uint8Array([0x51, 0x02, 0x4e, 0x73]);\n/**\n * A zero-value anchor output.\n */\nexports.P2A = {\n    script: exports.ANCHOR_PKSCRIPT,\n    amount: exports.ANCHOR_VALUE,\n};\nconst hexP2Ascript = base_1.hex.encode(exports.P2A.script);\n/**\n * search for anchor in the given transaction.\n * @throws {Error} if the anchor is not found or has the wrong amount\n */\nfunction findP2AOutput(tx) {\n    for (let i = 0; i < tx.outputsLength; i++) {\n        const output = tx.getOutput(i);\n        if (output.script && base_1.hex.encode(output.script) === hexP2Ascript) {\n            if (output.amount !== exports.P2A.amount) {\n                throw new Error(`P2A output has wrong amount, expected ${exports.P2A.amount} got ${output.amount}`);\n            }\n            return {\n                txid: tx.id,\n                index: i,\n                witnessUtxo: exports.P2A,\n            };\n        }\n    }\n    throw new Error("P2A output not found");\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/utils/anchor.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/utils/arkTransaction.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.buildOffchainTx = buildOffchainTx;\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\nconst tapscript_1 = __webpack_require__(/*! ../script/tapscript */ "./node_modules/@arkade-os/sdk/dist/cjs/script/tapscript.js");\nconst base_1 = __webpack_require__(/*! ../script/base */ "./node_modules/@arkade-os/sdk/dist/cjs/script/base.js");\nconst anchor_1 = __webpack_require__(/*! ./anchor */ "./node_modules/@arkade-os/sdk/dist/cjs/utils/anchor.js");\nconst base_2 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nconst utils_1 = __webpack_require__(/*! @scure/btc-signer/utils */ "./node_modules/@scure/btc-signer/utils.js");\nconst unknownFields_1 = __webpack_require__(/*! ./unknownFields */ "./node_modules/@arkade-os/sdk/dist/cjs/utils/unknownFields.js");\n/**\n * Builds an offchain transaction with checkpoint transactions.\n *\n * Creates one checkpoint transaction per input and a virtual transaction that\n * combines all the checkpoints, sending to the specified outputs. This is the\n * core function for creating Ark transactions.\n *\n * @param inputs - Array of virtual transaction inputs\n * @param outputs - Array of transaction outputs\n * @param serverUnrollScript - Server unroll script for checkpoint transactions\n * @returns Object containing the virtual transaction and checkpoint transactions\n */\nfunction buildOffchainTx(inputs, outputs, serverUnrollScript) {\n    const checkpoints = inputs.map((input) => buildCheckpointTx(input, serverUnrollScript));\n    const arkTx = buildVirtualTx(checkpoints.map((c) => c.input), outputs);\n    return {\n        arkTx,\n        checkpoints: checkpoints.map((c) => c.tx),\n    };\n}\nfunction buildVirtualTx(inputs, outputs) {\n    let lockTime = 0n;\n    for (const input of inputs) {\n        const tapscript = (0, tapscript_1.decodeTapscript)((0, base_1.scriptFromTapLeafScript)(input.tapLeafScript));\n        if (tapscript_1.CLTVMultisigTapscript.is(tapscript)) {\n            if (lockTime !== 0n) {\n                // if a locktime is already set, check if the new locktime is in the same unit\n                if (isSeconds(lockTime) !==\n                    isSeconds(tapscript.params.absoluteTimelock)) {\n                    throw new Error("cannot mix seconds and blocks locktime");\n                }\n            }\n            if (tapscript.params.absoluteTimelock > lockTime) {\n                lockTime = tapscript.params.absoluteTimelock;\n            }\n        }\n    }\n    const tx = new btc_signer_1.Transaction({\n        version: 3,\n        allowUnknown: true,\n        allowUnknownOutputs: true,\n        lockTime: Number(lockTime),\n    });\n    for (const [i, input] of inputs.entries()) {\n        tx.addInput({\n            txid: input.txid,\n            index: input.vout,\n            sequence: lockTime ? btc_signer_1.DEFAULT_SEQUENCE - 1 : undefined,\n            witnessUtxo: {\n                script: base_1.VtxoScript.decode(input.tapTree).pkScript,\n                amount: BigInt(input.value),\n            },\n            tapLeafScript: [input.tapLeafScript],\n        });\n        (0, unknownFields_1.setArkPsbtField)(tx, i, unknownFields_1.VtxoTaprootTree, input.tapTree);\n    }\n    for (const output of outputs) {\n        tx.addOutput(output);\n    }\n    // add the anchor output\n    tx.addOutput(anchor_1.P2A);\n    return tx;\n}\nfunction buildCheckpointTx(vtxo, serverUnrollScript) {\n    // create the checkpoint vtxo script from collaborative closure\n    const collaborativeClosure = (0, tapscript_1.decodeTapscript)(vtxo.checkpointTapLeafScript ??\n        (0, base_1.scriptFromTapLeafScript)(vtxo.tapLeafScript));\n    // create the checkpoint vtxo script combining collaborative closure and server unroll script\n    const checkpointVtxoScript = new base_1.VtxoScript([\n        serverUnrollScript.script,\n        collaborativeClosure.script,\n    ]);\n    // build the checkpoint virtual tx\n    const checkpointTx = buildVirtualTx([vtxo], [\n        {\n            amount: BigInt(vtxo.value),\n            script: checkpointVtxoScript.pkScript,\n        },\n    ]);\n    // get the collaborative leaf proof\n    const collaborativeLeafProof = checkpointVtxoScript.findLeaf(base_2.hex.encode(collaborativeClosure.script));\n    // create the checkpoint input that will be used as input of the virtual tx\n    const checkpointInput = {\n        txid: base_2.hex.encode((0, utils_1.sha256x2)(checkpointTx.toBytes(true)).reverse()),\n        vout: 0,\n        value: vtxo.value,\n        tapLeafScript: collaborativeLeafProof,\n        tapTree: checkpointVtxoScript.encode(),\n    };\n    return {\n        tx: checkpointTx,\n        input: checkpointInput,\n    };\n}\nconst nLocktimeMinSeconds = 500000000n;\nfunction isSeconds(locktime) {\n    return locktime >= nLocktimeMinSeconds;\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/utils/arkTransaction.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/utils/transactionHistory.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.vtxosToTxs = vtxosToTxs;\nconst wallet_1 = __webpack_require__(/*! ../wallet */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/index.js");\n/**\n * @param spendable - Vtxos that are spendable\n * @param spent - Vtxos that are spent\n * @param boardingBatchTxids - Set of boarding batch txids\n * @returns Ark transactions\n */\nfunction vtxosToTxs(spendable, spent, boardingBatchTxids) {\n    const txs = [];\n    // Receive case\n    // All vtxos are received unless:\n    // - they resulted from a settlement (either boarding or refresh)\n    // - they are the change of a spend tx\n    let vtxosLeftToCheck = [...spent];\n    for (const vtxo of [...spendable, ...spent]) {\n        if (vtxo.virtualStatus.state !== "preconfirmed" &&\n            vtxo.virtualStatus.commitmentTxIds &&\n            vtxo.virtualStatus.commitmentTxIds.some((txid) => boardingBatchTxids.has(txid))) {\n            continue;\n        }\n        const settleVtxos = findVtxosSpentInSettlement(vtxosLeftToCheck, vtxo);\n        vtxosLeftToCheck = removeVtxosFromList(vtxosLeftToCheck, settleVtxos);\n        const settleAmount = reduceVtxosAmount(settleVtxos);\n        if (vtxo.value <= settleAmount) {\n            continue; // settlement or change, ignore\n        }\n        const spentVtxos = findVtxosSpentInPayment(vtxosLeftToCheck, vtxo);\n        vtxosLeftToCheck = removeVtxosFromList(vtxosLeftToCheck, spentVtxos);\n        const spentAmount = reduceVtxosAmount(spentVtxos);\n        if (vtxo.value <= spentAmount) {\n            continue; // settlement or change, ignore\n        }\n        const txKey = {\n            commitmentTxid: vtxo.spentBy || "",\n            boardingTxid: "",\n            arkTxid: "",\n        };\n        let settled = vtxo.virtualStatus.state !== "preconfirmed";\n        if (vtxo.virtualStatus.state === "preconfirmed") {\n            txKey.arkTxid = vtxo.txid;\n            if (vtxo.spentBy) {\n                settled = true;\n            }\n        }\n        txs.push({\n            key: txKey,\n            amount: vtxo.value - settleAmount - spentAmount,\n            type: wallet_1.TxType.TxReceived,\n            createdAt: vtxo.createdAt.getTime(),\n            settled,\n        });\n    }\n    // vtxos by settled by or ark txid\n    const vtxosByTxid = new Map();\n    for (const v of spent) {\n        if (v.settledBy) {\n            if (!vtxosByTxid.has(v.settledBy)) {\n                vtxosByTxid.set(v.settledBy, []);\n            }\n            const currentVtxos = vtxosByTxid.get(v.settledBy);\n            vtxosByTxid.set(v.settledBy, [...currentVtxos, v]);\n        }\n        if (!v.arkTxId) {\n            continue;\n        }\n        if (!vtxosByTxid.has(v.arkTxId)) {\n            vtxosByTxid.set(v.arkTxId, []);\n        }\n        const currentVtxos = vtxosByTxid.get(v.arkTxId);\n        vtxosByTxid.set(v.arkTxId, [...currentVtxos, v]);\n    }\n    for (const [sb, vtxos] of vtxosByTxid) {\n        const resultedVtxos = findVtxosResultedFromTxid([...spendable, ...spent], sb);\n        const resultedAmount = reduceVtxosAmount(resultedVtxos);\n        const spentAmount = reduceVtxosAmount(vtxos);\n        if (spentAmount <= resultedAmount) {\n            continue; // settlement or change, ignore\n        }\n        const vtxo = getVtxo(resultedVtxos, vtxos);\n        const txKey = {\n            commitmentTxid: vtxo.virtualStatus.commitmentTxIds?.[0] || "",\n            boardingTxid: "",\n            arkTxid: "",\n        };\n        if (vtxo.virtualStatus.state === "preconfirmed") {\n            txKey.arkTxid = vtxo.txid;\n        }\n        txs.push({\n            key: txKey,\n            amount: spentAmount - resultedAmount,\n            type: wallet_1.TxType.TxSent,\n            createdAt: vtxo.createdAt.getTime(),\n            settled: true,\n        });\n    }\n    return txs;\n}\n/**\n * Helper function to find vtxos that were spent in a settlement\n */\nfunction findVtxosSpentInSettlement(vtxos, vtxo) {\n    if (vtxo.virtualStatus.state === "preconfirmed") {\n        return [];\n    }\n    return vtxos.filter((v) => {\n        if (!v.settledBy)\n            return false;\n        return (vtxo.virtualStatus.commitmentTxIds?.includes(v.settledBy) ?? false);\n    });\n}\n/**\n * Helper function to find vtxos that were spent in a payment\n */\nfunction findVtxosSpentInPayment(vtxos, vtxo) {\n    return vtxos.filter((v) => {\n        if (!v.arkTxId)\n            return false;\n        return v.arkTxId === vtxo.txid;\n    });\n}\n/**\n * Helper function to find vtxos that resulted from a spentBy transaction\n */\nfunction findVtxosResultedFromTxid(vtxos, txid) {\n    return vtxos.filter((v) => {\n        if (v.virtualStatus.state !== "preconfirmed" &&\n            v.virtualStatus.commitmentTxIds?.includes(txid)) {\n            return true;\n        }\n        return v.txid === txid;\n    });\n}\n/**\n * Helper function to reduce vtxos to their total amount\n */\nfunction reduceVtxosAmount(vtxos) {\n    return vtxos.reduce((sum, v) => sum + v.value, 0);\n}\n/**\n * Helper function to get a vtxo from a list of vtxos\n */\nfunction getVtxo(resultedVtxos, spentVtxos) {\n    if (resultedVtxos.length === 0) {\n        return spentVtxos[0];\n    }\n    return resultedVtxos[0];\n}\nfunction removeVtxosFromList(vtxos, vtxosToRemove) {\n    return vtxos.filter((v) => {\n        for (const vtxoToRemove of vtxosToRemove) {\n            if (v.txid === vtxoToRemove.txid && v.vout === vtxoToRemove.vout) {\n                return false;\n            }\n        }\n        return true;\n    });\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/utils/transactionHistory.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/utils/txSizeEstimator.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.TxWeightEstimator = void 0;\nclass TxWeightEstimator {\n    constructor(hasWitness, inputCount, outputCount, inputSize, inputWitnessSize, outputSize) {\n        this.hasWitness = hasWitness;\n        this.inputCount = inputCount;\n        this.outputCount = outputCount;\n        this.inputSize = inputSize;\n        this.inputWitnessSize = inputWitnessSize;\n        this.outputSize = outputSize;\n    }\n    static create() {\n        return new TxWeightEstimator(false, 0, 0, 0, 0, 0);\n    }\n    addP2AInput() {\n        this.inputCount++;\n        this.inputSize += TxWeightEstimator.INPUT_SIZE;\n        return this;\n    }\n    addKeySpendInput(isDefault = true) {\n        this.inputCount++;\n        this.inputWitnessSize += 64 + 1 + (isDefault ? 0 : 1);\n        this.inputSize += TxWeightEstimator.INPUT_SIZE;\n        this.hasWitness = true;\n        return this;\n    }\n    addP2PKHInput() {\n        this.inputCount++;\n        this.inputWitnessSize++;\n        this.inputSize +=\n            TxWeightEstimator.INPUT_SIZE +\n                TxWeightEstimator.P2PKH_SCRIPT_SIG_SIZE;\n        return this;\n    }\n    addTapscriptInput(leafWitnessSize, leafScriptSize, leafControlBlockSize) {\n        const controlBlockWitnessSize = 1 +\n            TxWeightEstimator.BASE_CONTROL_BLOCK_SIZE +\n            1 +\n            leafScriptSize +\n            1 +\n            leafControlBlockSize;\n        this.inputCount++;\n        this.inputWitnessSize += leafWitnessSize + controlBlockWitnessSize;\n        this.inputSize += TxWeightEstimator.INPUT_SIZE;\n        this.hasWitness = true;\n        this.inputCount++;\n        return this;\n    }\n    addP2WKHOutput() {\n        this.outputCount++;\n        this.outputSize +=\n            TxWeightEstimator.OUTPUT_SIZE + TxWeightEstimator.P2WKH_OUTPUT_SIZE;\n        return this;\n    }\n    addP2TROutput() {\n        this.outputCount++;\n        this.outputSize +=\n            TxWeightEstimator.OUTPUT_SIZE + TxWeightEstimator.P2TR_OUTPUT_SIZE;\n        return this;\n    }\n    vsize() {\n        const getVarIntSize = (n) => {\n            if (n < 0xfd)\n                return 1;\n            if (n < 0xffff)\n                return 3;\n            if (n < 0xffffffff)\n                return 5;\n            return 9;\n        };\n        const inputCount = getVarIntSize(this.inputCount);\n        const outputCount = getVarIntSize(this.outputCount);\n        // Calculate the size of the transaction without witness data\n        const txSizeStripped = TxWeightEstimator.BASE_TX_SIZE +\n            inputCount +\n            this.inputSize +\n            outputCount +\n            this.outputSize;\n        // Calculate the total weight\n        let weight = txSizeStripped * TxWeightEstimator.WITNESS_SCALE_FACTOR;\n        // Add witness data if present\n        if (this.hasWitness) {\n            weight +=\n                TxWeightEstimator.WITNESS_HEADER_SIZE + this.inputWitnessSize;\n        }\n        // Convert weight to vsize (weight / 4, rounded up)\n        return vsize(weight);\n    }\n}\nexports.TxWeightEstimator = TxWeightEstimator;\nTxWeightEstimator.P2PKH_SCRIPT_SIG_SIZE = 1 + 73 + 1 + 33;\nTxWeightEstimator.INPUT_SIZE = 32 + 4 + 1 + 4;\nTxWeightEstimator.BASE_CONTROL_BLOCK_SIZE = 1 + 32;\nTxWeightEstimator.OUTPUT_SIZE = 8 + 1;\nTxWeightEstimator.P2WKH_OUTPUT_SIZE = 1 + 1 + 20;\nTxWeightEstimator.BASE_TX_SIZE = 8 + 2; // Version + LockTime\nTxWeightEstimator.WITNESS_HEADER_SIZE = 2; // Flag + Marker\nTxWeightEstimator.WITNESS_SCALE_FACTOR = 4;\nTxWeightEstimator.P2TR_OUTPUT_SIZE = 1 + 1 + 32;\nconst vsize = (weight) => {\n    const value = BigInt(Math.ceil(weight / TxWeightEstimator.WITNESS_SCALE_FACTOR));\n    return {\n        value,\n        fee: (feeRate) => feeRate * value,\n    };\n};\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/utils/txSizeEstimator.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/utils/unknownFields.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.VtxoTreeExpiry = exports.CosignerPublicKey = exports.ConditionWitness = exports.VtxoTaprootTree = exports.ArkPsbtFieldKeyType = exports.ArkPsbtFieldKey = void 0;\nexports.setArkPsbtField = setArkPsbtField;\nexports.getArkPsbtFields = getArkPsbtFields;\nconst bip68 = __importStar(__webpack_require__(/*! bip68 */ "./node_modules/bip68/index.js"));\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\nconst base_1 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\n/**\n * ArkPsbtFieldKey is the key values for ark psbt fields.\n */\nvar ArkPsbtFieldKey;\n(function (ArkPsbtFieldKey) {\n    ArkPsbtFieldKey["VtxoTaprootTree"] = "taptree";\n    ArkPsbtFieldKey["VtxoTreeExpiry"] = "expiry";\n    ArkPsbtFieldKey["Cosigner"] = "cosigner";\n    ArkPsbtFieldKey["ConditionWitness"] = "condition";\n})(ArkPsbtFieldKey || (exports.ArkPsbtFieldKey = ArkPsbtFieldKey = {}));\n/**\n * ArkPsbtFieldKeyType is the type of the ark psbt field key.\n * Every ark psbt field has key type 255.\n */\nexports.ArkPsbtFieldKeyType = 255;\n/**\n * setArkPsbtField appends a new unknown field to the input at inputIndex\n *\n * @example\n * ```typescript\n * setArkPsbtField(tx, 0, VtxoTaprootTree, myTaprootTree);\n * setArkPsbtField(tx, 0, VtxoTreeExpiry, myVtxoTreeExpiry);\n * ```\n */\nfunction setArkPsbtField(tx, inputIndex, coder, value) {\n    tx.updateInput(inputIndex, {\n        unknown: [\n            ...(tx.getInput(inputIndex)?.unknown ?? []),\n            coder.encode(value),\n        ],\n    });\n}\n/**\n * getArkPsbtFields returns all the values of the given coder for the input at inputIndex\n * Multiple fields of the same type can exist in a single input.\n *\n * @example\n * ```typescript\n * const vtxoTaprootTreeFields = getArkPsbtFields(tx, 0, VtxoTaprootTree);\n * console.log(`input has ${vtxoTaprootTreeFields.length} vtxoTaprootTree fields`);\n */\nfunction getArkPsbtFields(tx, inputIndex, coder) {\n    const unknown = tx.getInput(inputIndex)?.unknown ?? [];\n    const fields = [];\n    for (const u of unknown) {\n        const v = coder.decode(u);\n        if (v)\n            fields.push(v);\n    }\n    return fields;\n}\n/**\n * VtxoTaprootTree is set to pass all spending leaves of the vtxo input\n *\n * @example\n * ```typescript\n * const vtxoTaprootTree = VtxoTaprootTree.encode(myTaprootTree);\n */\nexports.VtxoTaprootTree = {\n    key: ArkPsbtFieldKey.VtxoTaprootTree,\n    encode: (value) => [\n        {\n            type: exports.ArkPsbtFieldKeyType,\n            key: encodedPsbtFieldKey[ArkPsbtFieldKey.VtxoTaprootTree],\n        },\n        value,\n    ],\n    decode: (value) => nullIfCatch(() => {\n        if (!checkKeyIncludes(value[0], ArkPsbtFieldKey.VtxoTaprootTree))\n            return null;\n        return value[1];\n    }),\n};\n/**\n * ConditionWitness is set to pass the witness data used to finalize the conditionMultisigClosure\n *\n * @example\n * ```typescript\n * const conditionWitness = ConditionWitness.encode(myConditionWitness);\n */\nexports.ConditionWitness = {\n    key: ArkPsbtFieldKey.ConditionWitness,\n    encode: (value) => [\n        {\n            type: exports.ArkPsbtFieldKeyType,\n            key: encodedPsbtFieldKey[ArkPsbtFieldKey.ConditionWitness],\n        },\n        btc_signer_1.RawWitness.encode(value),\n    ],\n    decode: (value) => nullIfCatch(() => {\n        if (!checkKeyIncludes(value[0], ArkPsbtFieldKey.ConditionWitness))\n            return null;\n        return btc_signer_1.RawWitness.decode(value[1]);\n    }),\n};\n/**\n * CosignerPublicKey is set on every TxGraph transactions to identify the musig2 public keys\n *\n * @example\n * ```typescript\n * const cosignerPublicKey = CosignerPublicKey.encode(myCosignerPublicKey);\n */\nexports.CosignerPublicKey = {\n    key: ArkPsbtFieldKey.Cosigner,\n    encode: (value) => [\n        {\n            type: exports.ArkPsbtFieldKeyType,\n            key: new Uint8Array([\n                ...encodedPsbtFieldKey[ArkPsbtFieldKey.Cosigner],\n                value.index,\n            ]),\n        },\n        value.key,\n    ],\n    decode: (unknown) => nullIfCatch(() => {\n        if (!checkKeyIncludes(unknown[0], ArkPsbtFieldKey.Cosigner))\n            return null;\n        return {\n            index: unknown[0].key[unknown[0].key.length - 1],\n            key: unknown[1],\n        };\n    }),\n};\n/**\n * VtxoTreeExpiry is set to pass the expiry time of the input\n *\n * @example\n * ```typescript\n * const vtxoTreeExpiry = VtxoTreeExpiry.encode(myVtxoTreeExpiry);\n */\nexports.VtxoTreeExpiry = {\n    key: ArkPsbtFieldKey.VtxoTreeExpiry,\n    encode: (value) => [\n        {\n            type: exports.ArkPsbtFieldKeyType,\n            key: encodedPsbtFieldKey[ArkPsbtFieldKey.VtxoTreeExpiry],\n        },\n        (0, btc_signer_1.ScriptNum)(6, true).encode(value.value === 0n ? 0n : value.value),\n    ],\n    decode: (unknown) => nullIfCatch(() => {\n        if (!checkKeyIncludes(unknown[0], ArkPsbtFieldKey.VtxoTreeExpiry))\n            return null;\n        const v = (0, btc_signer_1.ScriptNum)(6, true).decode(unknown[1]);\n        if (!v)\n            return null;\n        const { blocks, seconds } = bip68.decode(Number(v));\n        return {\n            type: blocks ? "blocks" : "seconds",\n            value: BigInt(blocks ?? seconds ?? 0),\n        };\n    }),\n};\nconst encodedPsbtFieldKey = Object.fromEntries(Object.values(ArkPsbtFieldKey).map((key) => [\n    key,\n    new TextEncoder().encode(key),\n]));\nconst nullIfCatch = (fn) => {\n    try {\n        return fn();\n    }\n    catch (err) {\n        return null;\n    }\n};\nfunction checkKeyIncludes(key, arkPsbtFieldKey) {\n    const expected = base_1.hex.encode(encodedPsbtFieldKey[arkPsbtFieldKey]);\n    return base_1.hex\n        .encode(new Uint8Array([key.type, ...key.key]))\n        .includes(expected);\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/utils/unknownFields.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/wallet/index.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.TxType = void 0;\nexports.isSpendable = isSpendable;\nexports.isRecoverable = isRecoverable;\nexports.isSubdust = isSubdust;\nvar TxType;\n(function (TxType) {\n    TxType["TxSent"] = "SENT";\n    TxType["TxReceived"] = "RECEIVED";\n})(TxType || (exports.TxType = TxType = {}));\nfunction isSpendable(vtxo) {\n    return vtxo.spentBy === undefined || vtxo.spentBy === "";\n}\nfunction isRecoverable(vtxo) {\n    return vtxo.virtualStatus.state === "swept" && isSpendable(vtxo);\n}\nfunction isSubdust(vtxo, dust) {\n    return vtxo.value < dust;\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/wallet/index.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/wallet/onchain.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.OnchainWallet = void 0;\nexports.selectCoins = selectCoins;\nconst payment_1 = __webpack_require__(/*! @scure/btc-signer/payment */ "./node_modules/@scure/btc-signer/payment.js");\nconst networks_1 = __webpack_require__(/*! ../networks */ "./node_modules/@arkade-os/sdk/dist/cjs/networks.js");\nconst onchain_1 = __webpack_require__(/*! ../providers/onchain */ "./node_modules/@arkade-os/sdk/dist/cjs/providers/onchain.js");\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\nconst anchor_1 = __webpack_require__(/*! ../utils/anchor */ "./node_modules/@arkade-os/sdk/dist/cjs/utils/anchor.js");\nconst txSizeEstimator_1 = __webpack_require__(/*! ../utils/txSizeEstimator */ "./node_modules/@arkade-os/sdk/dist/cjs/utils/txSizeEstimator.js");\n/**\n * Onchain Bitcoin wallet implementation for traditional Bitcoin transactions.\n *\n * This wallet handles regular Bitcoin transactions on the blockchain without\n * using the Ark protocol. It supports P2TR (Pay-to-Taproot) addresses and\n * provides basic Bitcoin wallet functionality.\n *\n * @example\n * ```typescript\n * const wallet = new OnchainWallet(identity, \'mainnet\');\n * const balance = await wallet.getBalance();\n * const txid = await wallet.send({\n *   address: \'bc1...\',\n *   amount: 50000\n * });\n * ```\n */\nclass OnchainWallet {\n    constructor(identity, network, provider) {\n        this.identity = identity;\n        const pubkey = identity.xOnlyPublicKey();\n        if (!pubkey) {\n            throw new Error("Invalid configured public key");\n        }\n        this.provider = provider || new onchain_1.EsploraProvider(onchain_1.ESPLORA_URL[network]);\n        this.network = (0, networks_1.getNetwork)(network);\n        this.onchainP2TR = (0, payment_1.p2tr)(pubkey, undefined, this.network);\n    }\n    get address() {\n        return this.onchainP2TR.address || "";\n    }\n    async getCoins() {\n        return this.provider.getCoins(this.address);\n    }\n    async getBalance() {\n        const coins = await this.getCoins();\n        const onchainConfirmed = coins\n            .filter((coin) => coin.status.confirmed)\n            .reduce((sum, coin) => sum + coin.value, 0);\n        const onchainUnconfirmed = coins\n            .filter((coin) => !coin.status.confirmed)\n            .reduce((sum, coin) => sum + coin.value, 0);\n        const onchainTotal = onchainConfirmed + onchainUnconfirmed;\n        return onchainTotal;\n    }\n    async send(params) {\n        if (params.amount <= 0) {\n            throw new Error("Amount must be positive");\n        }\n        if (params.amount < OnchainWallet.DUST_AMOUNT) {\n            throw new Error("Amount is below dust limit");\n        }\n        const coins = await this.getCoins();\n        let feeRate = params.feeRate;\n        if (!feeRate) {\n            feeRate = await this.provider.getFeeRate();\n        }\n        if (!feeRate || feeRate < OnchainWallet.MIN_FEE_RATE) {\n            feeRate = OnchainWallet.MIN_FEE_RATE;\n        }\n        // Ensure fee is an integer by rounding up\n        const estimatedFee = Math.ceil(174 * feeRate);\n        const totalNeeded = params.amount + estimatedFee;\n        // Select coins\n        const selected = selectCoins(coins, totalNeeded);\n        // Create transaction\n        let tx = new btc_signer_1.Transaction();\n        // Add inputs\n        for (const input of selected.inputs) {\n            tx.addInput({\n                txid: input.txid,\n                index: input.vout,\n                witnessUtxo: {\n                    script: this.onchainP2TR.script,\n                    amount: BigInt(input.value),\n                },\n                tapInternalKey: this.onchainP2TR.tapInternalKey,\n            });\n        }\n        // Add payment output\n        tx.addOutputAddress(params.address, BigInt(params.amount), this.network);\n        // Add change output if needed\n        if (selected.changeAmount > 0n) {\n            tx.addOutputAddress(this.address, selected.changeAmount, this.network);\n        }\n        // Sign inputs and Finalize\n        tx = await this.identity.sign(tx);\n        tx.finalize();\n        // Broadcast\n        const txid = await this.provider.broadcastTransaction(tx.hex);\n        return txid;\n    }\n    async bumpP2A(parent) {\n        const parentVsize = parent.vsize;\n        let child = new btc_signer_1.Transaction({\n            allowUnknownInputs: true,\n            allowLegacyWitnessUtxo: true,\n            version: 3,\n        });\n        child.addInput((0, anchor_1.findP2AOutput)(parent)); // throws if not found\n        const childVsize = txSizeEstimator_1.TxWeightEstimator.create()\n            .addKeySpendInput(true)\n            .addP2AInput()\n            .addP2TROutput()\n            .vsize().value;\n        const packageVSize = parentVsize + Number(childVsize);\n        let feeRate = await this.provider.getFeeRate();\n        if (!feeRate || feeRate < OnchainWallet.MIN_FEE_RATE) {\n            feeRate = OnchainWallet.MIN_FEE_RATE;\n        }\n        const fee = Math.ceil(feeRate * packageVSize);\n        if (!fee) {\n            throw new Error(`invalid fee, got ${fee} with vsize ${packageVSize}, feeRate ${feeRate}`);\n        }\n        // Select coins\n        const coins = await this.getCoins();\n        const selected = selectCoins(coins, fee, true);\n        for (const input of selected.inputs) {\n            child.addInput({\n                txid: input.txid,\n                index: input.vout,\n                witnessUtxo: {\n                    script: this.onchainP2TR.script,\n                    amount: BigInt(input.value),\n                },\n                tapInternalKey: this.onchainP2TR.tapInternalKey,\n            });\n        }\n        child.addOutputAddress(this.address, anchor_1.P2A.amount + selected.changeAmount, this.network);\n        // Sign inputs and Finalize\n        child = await this.identity.sign(child);\n        for (let i = 1; i < child.inputsLength; i++) {\n            child.finalizeIdx(i);\n        }\n        try {\n            await this.provider.broadcastTransaction(parent.hex, child.hex);\n        }\n        catch (error) {\n            console.error(error);\n        }\n        finally {\n            return [parent.hex, child.hex];\n        }\n    }\n}\nexports.OnchainWallet = OnchainWallet;\nOnchainWallet.MIN_FEE_RATE = 1; // sat/vbyte\nOnchainWallet.DUST_AMOUNT = 546; // sats\n/**\n * Select coins to reach a target amount, prioritizing those closer to expiry\n * @param coins List of coins to select from\n * @param targetAmount Target amount to reach in satoshis\n * @param forceChange If true, ensure the coin selection will require a change output\n * @returns Selected coins and change amount, or null if insufficient funds\n */\nfunction selectCoins(coins, targetAmount, forceChange = false) {\n    if (isNaN(targetAmount)) {\n        throw new Error("Target amount is NaN, got " + targetAmount);\n    }\n    if (targetAmount < 0) {\n        throw new Error("Target amount is negative, got " + targetAmount);\n    }\n    if (targetAmount === 0) {\n        return { inputs: [], changeAmount: 0n };\n    }\n    // Sort coins by amount (descending)\n    const sortedCoins = [...coins].sort((a, b) => b.value - a.value);\n    const selectedCoins = [];\n    let selectedAmount = 0;\n    // Select coins until we have enough\n    for (const coin of sortedCoins) {\n        selectedCoins.push(coin);\n        selectedAmount += coin.value;\n        if (forceChange\n            ? selectedAmount > targetAmount\n            : selectedAmount >= targetAmount) {\n            break;\n        }\n    }\n    if (selectedAmount === targetAmount) {\n        return { inputs: selectedCoins, changeAmount: 0n };\n    }\n    if (selectedAmount < targetAmount) {\n        throw new Error("Insufficient funds");\n    }\n    const changeAmount = BigInt(selectedAmount - targetAmount);\n    return {\n        inputs: selectedCoins,\n        changeAmount,\n    };\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/wallet/onchain.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/wallet/ramps.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Ramps = void 0;\n/**\n * Ramps is a class wrapping IWallet.settle method to provide a more convenient interface for onboarding and offboarding operations.\n *\n * @example\n * ```typescript\n * const ramps = new Ramps(wallet);\n * await ramps.onboard(); // onboard all boarding utxos\n * await ramps.offboard(myOnchainAddress); // collaborative exit all vtxos to onchain address\n * ```\n */\nclass Ramps {\n    constructor(wallet) {\n        this.wallet = wallet;\n    }\n    /**\n     * Onboard boarding utxos.\n     *\n     * @param boardingUtxos - The boarding utxos to onboard. If not provided, all boarding utxos will be used.\n     * @param amount - The amount to onboard. If not provided, the total amount of boarding utxos will be onboarded.\n     * @param eventCallback - The callback to receive settlement events. optional.\n     */\n    async onboard(boardingUtxos, amount, eventCallback) {\n        boardingUtxos = boardingUtxos ?? (await this.wallet.getBoardingUtxos());\n        const totalAmount = boardingUtxos.reduce((acc, coin) => acc + BigInt(coin.value), 0n);\n        let change = 0n;\n        if (amount) {\n            if (amount > totalAmount) {\n                throw new Error("Amount is greater than total amount of boarding utxos");\n            }\n            change = totalAmount - amount;\n        }\n        amount = amount ?? totalAmount;\n        const offchainAddress = await this.wallet.getAddress();\n        const outputs = [\n            {\n                address: offchainAddress,\n                amount,\n            },\n        ];\n        if (change > 0n) {\n            const boardingAddress = await this.wallet.getBoardingAddress();\n            outputs.push({\n                address: boardingAddress,\n                amount: change,\n            });\n        }\n        return this.wallet.settle({\n            inputs: boardingUtxos,\n            outputs,\n        }, eventCallback);\n    }\n    /**\n     * Offboard vtxos, or "collaborative exit" vtxos to onchain address.\n     *\n     * @param destinationAddress - The destination address to offboard to.\n     * @param amount - The amount to offboard. If not provided, the total amount of vtxos will be offboarded.\n     * @param eventCallback - The callback to receive settlement events. optional.\n     */\n    async offboard(destinationAddress, amount, eventCallback) {\n        const vtxos = await this.wallet.getVtxos({\n            withRecoverable: true,\n            withUnrolled: false,\n        });\n        const totalAmount = vtxos.reduce((acc, coin) => acc + BigInt(coin.value), 0n);\n        let change = 0n;\n        if (amount) {\n            if (amount > totalAmount) {\n                throw new Error("Amount is greater than total amount of vtxos");\n            }\n            change = totalAmount - amount;\n        }\n        amount = amount ?? totalAmount;\n        const outputs = [\n            {\n                address: destinationAddress,\n                amount,\n            },\n        ];\n        if (change > 0n) {\n            const offchainAddress = await this.wallet.getAddress();\n            outputs.push({\n                address: offchainAddress,\n                amount: change,\n            });\n        }\n        return this.wallet.settle({\n            inputs: vtxos,\n            outputs,\n        }, eventCallback);\n    }\n}\nexports.Ramps = Ramps;\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/wallet/ramps.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/db/vtxo/idb.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.IndexedDBVtxoRepository = void 0;\nclass IndexedDBVtxoRepository {\n    constructor() {\n        this.db = null;\n    }\n    static delete() {\n        return new Promise((resolve, reject) => {\n            try {\n                const request = indexedDB.deleteDatabase(IndexedDBVtxoRepository.DB_NAME);\n                request.onblocked = () => {\n                    // If blocked, wait a bit and try again\n                    setTimeout(() => {\n                        const retryRequest = indexedDB.deleteDatabase(IndexedDBVtxoRepository.DB_NAME);\n                        retryRequest.onsuccess = () => resolve();\n                        retryRequest.onerror = () => reject(retryRequest.error ||\n                            new Error("Failed to delete database"));\n                    }, 100);\n                };\n                request.onsuccess = () => {\n                    resolve();\n                };\n                request.onerror = () => {\n                    reject(request.error || new Error("Failed to delete database"));\n                };\n            }\n            catch (error) {\n                reject(error instanceof Error\n                    ? error\n                    : new Error("Failed to delete database"));\n            }\n        });\n    }\n    async close() {\n        if (this.db) {\n            this.db.close();\n            this.db = null;\n        }\n    }\n    async open() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(IndexedDBVtxoRepository.DB_NAME, IndexedDBVtxoRepository.DB_VERSION);\n            request.onerror = () => {\n                reject(request.error);\n            };\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve();\n            };\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n                if (!db.objectStoreNames.contains(IndexedDBVtxoRepository.STORE_NAME)) {\n                    const store = db.createObjectStore(IndexedDBVtxoRepository.STORE_NAME, {\n                        keyPath: ["txid", "vout"],\n                    });\n                    store.createIndex("state", "virtualStatus.state", {\n                        unique: false,\n                    });\n                    store.createIndex("spentBy", "spentBy", {\n                        unique: false,\n                    });\n                }\n            };\n        });\n    }\n    async addOrUpdate(vtxos) {\n        if (!this.db) {\n            throw new Error("Database not opened");\n        }\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(IndexedDBVtxoRepository.STORE_NAME, "readwrite");\n            const store = transaction.objectStore(IndexedDBVtxoRepository.STORE_NAME);\n            const requests = vtxos.map((vtxo) => {\n                return new Promise((resolveRequest, rejectRequest) => {\n                    const request = store.put(vtxo);\n                    request.onsuccess = () => resolveRequest();\n                    request.onerror = () => rejectRequest(request.error);\n                });\n            });\n            Promise.all(requests)\n                .then(() => resolve())\n                .catch(reject);\n        });\n    }\n    async deleteAll() {\n        if (!this.db) {\n            throw new Error("Database not opened");\n        }\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(IndexedDBVtxoRepository.STORE_NAME, "readwrite");\n            const store = transaction.objectStore(IndexedDBVtxoRepository.STORE_NAME);\n            const request = store.clear();\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n    async getSpendableVtxos() {\n        if (!this.db) {\n            throw new Error("Database not opened");\n        }\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(IndexedDBVtxoRepository.STORE_NAME, "readonly");\n            const store = transaction.objectStore(IndexedDBVtxoRepository.STORE_NAME);\n            const spentByIndex = store.index("spentBy");\n            // Get vtxos where spentBy is empty string\n            const request = spentByIndex.getAll(IDBKeyRange.only(""));\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n            request.onerror = () => reject(request.error);\n        });\n    }\n    async getSweptVtxos() {\n        if (!this.db) {\n            throw new Error("Database not opened");\n        }\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(IndexedDBVtxoRepository.STORE_NAME, "readonly");\n            const store = transaction.objectStore(IndexedDBVtxoRepository.STORE_NAME);\n            const stateIndex = store.index("state");\n            // Get vtxos where state is "swept"\n            const request = stateIndex.getAll(IDBKeyRange.only("swept"));\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n            request.onerror = () => reject(request.error);\n        });\n    }\n    async getSpentVtxos() {\n        if (!this.db) {\n            throw new Error("Database not opened");\n        }\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(IndexedDBVtxoRepository.STORE_NAME, "readonly");\n            const store = transaction.objectStore(IndexedDBVtxoRepository.STORE_NAME);\n            const spentByIndex = store.index("spentBy");\n            // Get vtxos where spentBy is not empty string\n            const request = spentByIndex.getAll(IDBKeyRange.lowerBound("", true));\n            request.onsuccess = () => {\n                resolve(request.result);\n            };\n            request.onerror = () => reject(request.error);\n        });\n    }\n    async getAllVtxos() {\n        if (!this.db) {\n            throw new Error("Database not opened");\n        }\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(IndexedDBVtxoRepository.STORE_NAME, "readonly");\n            const store = transaction.objectStore(IndexedDBVtxoRepository.STORE_NAME);\n            const spentByIndex = store.index("spentBy");\n            // Get vtxos where spentBy is empty string\n            const spendableRequest = spentByIndex.getAll(IDBKeyRange.only(""));\n            // Get all vtxos where spentBy is populated\n            const spentRequest = spentByIndex.getAll(IDBKeyRange.lowerBound("", true));\n            Promise.all([\n                new Promise((resolveSpendable, rejectSpendable) => {\n                    spendableRequest.onsuccess = () => {\n                        resolveSpendable(spendableRequest.result);\n                    };\n                    spendableRequest.onerror = () => rejectSpendable(spendableRequest.error);\n                }),\n                new Promise((resolveSpent, rejectSpent) => {\n                    spentRequest.onsuccess = () => {\n                        resolveSpent(spentRequest.result);\n                    };\n                    spentRequest.onerror = () => rejectSpent(spentRequest.error);\n                }),\n            ])\n                .then(([spendableVtxos, spentVtxos]) => {\n                resolve({\n                    spendable: spendableVtxos,\n                    spent: spentVtxos,\n                });\n            })\n                .catch(reject);\n        });\n    }\n}\nexports.IndexedDBVtxoRepository = IndexedDBVtxoRepository;\nIndexedDBVtxoRepository.DB_NAME = "wallet-db";\nIndexedDBVtxoRepository.STORE_NAME = "vtxos";\nIndexedDBVtxoRepository.DB_VERSION = 1;\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/db/vtxo/idb.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/request.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Request = void 0;\n/**\n * Request is the namespace that contains the request types for the service worker.\n */\nvar Request;\n(function (Request) {\n    function isBase(message) {\n        return (typeof message === "object" && message !== null && "type" in message);\n    }\n    Request.isBase = isBase;\n    function isInitWallet(message) {\n        return (message.type === "INIT_WALLET" &&\n            "privateKey" in message &&\n            typeof message.privateKey === "string" &&\n            "arkServerUrl" in message &&\n            typeof message.arkServerUrl === "string" &&\n            ("arkServerPublicKey" in message\n                ? typeof message.arkServerPublicKey === "string" ||\n                    message.arkServerPublicKey === undefined\n                : true));\n    }\n    Request.isInitWallet = isInitWallet;\n    function isSettle(message) {\n        return message.type === "SETTLE";\n    }\n    Request.isSettle = isSettle;\n    function isGetAddress(message) {\n        return message.type === "GET_ADDRESS";\n    }\n    Request.isGetAddress = isGetAddress;\n    function isGetBoardingAddress(message) {\n        return message.type === "GET_BOARDING_ADDRESS";\n    }\n    Request.isGetBoardingAddress = isGetBoardingAddress;\n    function isGetBalance(message) {\n        return message.type === "GET_BALANCE";\n    }\n    Request.isGetBalance = isGetBalance;\n    function isGetVtxos(message) {\n        return message.type === "GET_VTXOS";\n    }\n    Request.isGetVtxos = isGetVtxos;\n    function isGetVirtualCoins(message) {\n        return message.type === "GET_VIRTUAL_COINS";\n    }\n    Request.isGetVirtualCoins = isGetVirtualCoins;\n    function isGetBoardingUtxos(message) {\n        return message.type === "GET_BOARDING_UTXOS";\n    }\n    Request.isGetBoardingUtxos = isGetBoardingUtxos;\n    function isSendBitcoin(message) {\n        return (message.type === "SEND_BITCOIN" &&\n            "params" in message &&\n            message.params !== null &&\n            typeof message.params === "object" &&\n            "address" in message.params &&\n            typeof message.params.address === "string" &&\n            "amount" in message.params &&\n            typeof message.params.amount === "number");\n    }\n    Request.isSendBitcoin = isSendBitcoin;\n    function isGetTransactionHistory(message) {\n        return message.type === "GET_TRANSACTION_HISTORY";\n    }\n    Request.isGetTransactionHistory = isGetTransactionHistory;\n    function isGetStatus(message) {\n        return message.type === "GET_STATUS";\n    }\n    Request.isGetStatus = isGetStatus;\n    function isSign(message) {\n        return (message.type === "SIGN" &&\n            "tx" in message &&\n            typeof message.tx === "string" &&\n            ("inputIndexes" in message && message.inputIndexes != undefined\n                ? Array.isArray(message.inputIndexes) &&\n                    message.inputIndexes.every((index) => typeof index === "number")\n                : true));\n    }\n    Request.isSign = isSign;\n})(Request || (exports.Request = Request = {}));\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/request.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/response.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Response = void 0;\n/**\n * Response is the namespace that contains the response types for the service worker.\n */\nvar Response;\n(function (Response) {\n    Response.walletInitialized = (id) => ({\n        type: "WALLET_INITIALIZED",\n        success: true,\n        id,\n    });\n    function error(id, message) {\n        return {\n            type: "ERROR",\n            success: false,\n            message,\n            id,\n        };\n    }\n    Response.error = error;\n    function settleEvent(id, event) {\n        return {\n            type: "SETTLE_EVENT",\n            success: true,\n            event,\n            id,\n        };\n    }\n    Response.settleEvent = settleEvent;\n    function settleSuccess(id, txid) {\n        return {\n            type: "SETTLE_SUCCESS",\n            success: true,\n            txid,\n            id,\n        };\n    }\n    Response.settleSuccess = settleSuccess;\n    function isSettleSuccess(response) {\n        return response.type === "SETTLE_SUCCESS" && response.success;\n    }\n    Response.isSettleSuccess = isSettleSuccess;\n    function isAddress(response) {\n        return response.type === "ADDRESS" && response.success === true;\n    }\n    Response.isAddress = isAddress;\n    function isBoardingAddress(response) {\n        return (response.type === "BOARDING_ADDRESS" && response.success === true);\n    }\n    Response.isBoardingAddress = isBoardingAddress;\n    function address(id, address) {\n        return {\n            type: "ADDRESS",\n            success: true,\n            address,\n            id,\n        };\n    }\n    Response.address = address;\n    function boardingAddress(id, address) {\n        return {\n            type: "BOARDING_ADDRESS",\n            success: true,\n            address,\n            id,\n        };\n    }\n    Response.boardingAddress = boardingAddress;\n    function isBalance(response) {\n        return response.type === "BALANCE" && response.success === true;\n    }\n    Response.isBalance = isBalance;\n    function balance(id, balance) {\n        return {\n            type: "BALANCE",\n            success: true,\n            balance,\n            id,\n        };\n    }\n    Response.balance = balance;\n    function isVtxos(response) {\n        return response.type === "VTXOS" && response.success === true;\n    }\n    Response.isVtxos = isVtxos;\n    function vtxos(id, vtxos) {\n        return {\n            type: "VTXOS",\n            success: true,\n            vtxos,\n            id,\n        };\n    }\n    Response.vtxos = vtxos;\n    function isVirtualCoins(response) {\n        return response.type === "VIRTUAL_COINS" && response.success === true;\n    }\n    Response.isVirtualCoins = isVirtualCoins;\n    function virtualCoins(id, virtualCoins) {\n        return {\n            type: "VIRTUAL_COINS",\n            success: true,\n            virtualCoins,\n            id,\n        };\n    }\n    Response.virtualCoins = virtualCoins;\n    function isBoardingUtxos(response) {\n        return response.type === "BOARDING_UTXOS" && response.success === true;\n    }\n    Response.isBoardingUtxos = isBoardingUtxos;\n    function boardingUtxos(id, boardingUtxos) {\n        return {\n            type: "BOARDING_UTXOS",\n            success: true,\n            boardingUtxos,\n            id,\n        };\n    }\n    Response.boardingUtxos = boardingUtxos;\n    function isSendBitcoinSuccess(response) {\n        return (response.type === "SEND_BITCOIN_SUCCESS" &&\n            response.success === true);\n    }\n    Response.isSendBitcoinSuccess = isSendBitcoinSuccess;\n    function sendBitcoinSuccess(id, txid) {\n        return {\n            type: "SEND_BITCOIN_SUCCESS",\n            success: true,\n            txid,\n            id,\n        };\n    }\n    Response.sendBitcoinSuccess = sendBitcoinSuccess;\n    function isTransactionHistory(response) {\n        return (response.type === "TRANSACTION_HISTORY" && response.success === true);\n    }\n    Response.isTransactionHistory = isTransactionHistory;\n    function transactionHistory(id, transactions) {\n        return {\n            type: "TRANSACTION_HISTORY",\n            success: true,\n            transactions,\n            id,\n        };\n    }\n    Response.transactionHistory = transactionHistory;\n    function isWalletStatus(response) {\n        return response.type === "WALLET_STATUS" && response.success === true;\n    }\n    Response.isWalletStatus = isWalletStatus;\n    function walletStatus(id, walletInitialized, xOnlyPublicKey) {\n        return {\n            type: "WALLET_STATUS",\n            success: true,\n            status: {\n                walletInitialized,\n                xOnlyPublicKey,\n            },\n            id,\n        };\n    }\n    Response.walletStatus = walletStatus;\n    function isClearResponse(response) {\n        return response.type === "CLEAR_RESPONSE";\n    }\n    Response.isClearResponse = isClearResponse;\n    function clearResponse(id, success) {\n        return {\n            type: "CLEAR_RESPONSE",\n            success,\n            id,\n        };\n    }\n    Response.clearResponse = clearResponse;\n    function signSuccess(id, tx) {\n        return {\n            type: "SIGN_SUCCESS",\n            success: true,\n            tx,\n            id,\n        };\n    }\n    Response.signSuccess = signSuccess;\n    function isSignSuccess(response) {\n        return response.type === "SIGN_SUCCESS" && response.success === true;\n    }\n    Response.isSignSuccess = isSignSuccess;\n})(Response || (exports.Response = Response = {}));\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/response.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/utils.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.setupServiceWorker = setupServiceWorker;\n/**\n * setupServiceWorker sets up the service worker.\n * @param path - the path to the service worker script\n * @example\n * ```typescript\n * const serviceWorker = await setupServiceWorker("/service-worker.js");\n * ```\n */\nasync function setupServiceWorker(path) {\n    // check if service workers are supported\n    if (!("serviceWorker" in navigator)) {\n        throw new Error("Service workers are not supported in this browser");\n    }\n    // register service worker\n    const registration = await navigator.serviceWorker.register(path);\n    // force update to ensure the service worker is active\n    registration.update();\n    const serviceWorker = registration.active || registration.waiting || registration.installing;\n    if (!serviceWorker) {\n        throw new Error("Failed to get service worker instance");\n    }\n    // wait for the service worker to be ready\n    return new Promise((resolve, reject) => {\n        if (serviceWorker.state === "activated")\n            return resolve(serviceWorker);\n        const onActivate = () => {\n            cleanup();\n            resolve(serviceWorker);\n        };\n        const onError = () => {\n            cleanup();\n            reject(new Error("Service worker failed to activate"));\n        };\n        const timeout = setTimeout(() => {\n            cleanup();\n            reject(new Error("Service worker activation timed out"));\n        }, 10000);\n        const cleanup = () => {\n            serviceWorker.removeEventListener("activate", onActivate);\n            serviceWorker.removeEventListener("error", onError);\n            clearTimeout(timeout);\n        };\n        serviceWorker.addEventListener("activate", onActivate);\n        serviceWorker.addEventListener("error", onError);\n    });\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/utils.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/wallet.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ServiceWorkerWallet = void 0;\nconst response_1 = __webpack_require__(/*! ./response */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/response.js");\nconst base_1 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nconst singleKey_1 = __webpack_require__(/*! ../../identity/singleKey */ "./node_modules/@arkade-os/sdk/dist/cjs/identity/singleKey.js");\nconst signingSession_1 = __webpack_require__(/*! ../../tree/signingSession */ "./node_modules/@arkade-os/sdk/dist/cjs/tree/signingSession.js");\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\nclass UnexpectedResponseError extends Error {\n    constructor(response) {\n        super(`Unexpected response type. Got: ${JSON.stringify(response, null, 2)}`);\n        this.name = "UnexpectedResponseError";\n    }\n}\n/**\n * Service Worker-based wallet implementation for browser environments.\n *\n * This wallet uses a service worker as a backend to handle wallet logic,\n * providing secure key storage and transaction signing in web applications.\n * The service worker runs in a separate thread and can persist data between\n * browser sessions.\n *\n * @example\n * ```typescript\n * // Create and initialize the service worker wallet\n * const serviceWorker = await setupServiceWorker("/service-worker.js");\n * const wallet = new ServiceWorkerWallet(serviceWorker);\n * await wallet.init({\n *   privateKey: \'your_private_key_hex\',\n *   arkServerUrl: \'https://ark.example.com\'\n * });\n *\n * // Use like any other wallet\n * const address = await wallet.getAddress();\n * const balance = await wallet.getBalance();\n * ```\n */\nclass ServiceWorkerWallet {\n    constructor(serviceWorker) {\n        this.serviceWorker = serviceWorker;\n    }\n    async getStatus() {\n        const message = {\n            type: "GET_STATUS",\n            id: getRandomId(),\n        };\n        const response = await this.sendMessage(message);\n        if (response_1.Response.isWalletStatus(response)) {\n            const { walletInitialized, xOnlyPublicKey } = response.status;\n            if (walletInitialized)\n                this.cachedXOnlyPublicKey = xOnlyPublicKey;\n            return response.status;\n        }\n        throw new UnexpectedResponseError(response);\n    }\n    async init(config, failIfInitialized = false) {\n        // Check if wallet is already initialized\n        const statusMessage = {\n            type: "GET_STATUS",\n            id: getRandomId(),\n        };\n        const response = await this.sendMessage(statusMessage);\n        if (response_1.Response.isWalletStatus(response) &&\n            response.status.walletInitialized) {\n            if (failIfInitialized) {\n                throw new Error("Wallet already initialized");\n            }\n            this.cachedXOnlyPublicKey = response.status.xOnlyPublicKey;\n            return;\n        }\n        // If not initialized, proceed with initialization\n        const message = {\n            type: "INIT_WALLET",\n            id: getRandomId(),\n            privateKey: config.privateKey,\n            arkServerUrl: config.arkServerUrl,\n            arkServerPublicKey: config.arkServerPublicKey,\n        };\n        await this.sendMessage(message);\n        const privKeyBytes = base_1.hex.decode(config.privateKey);\n        // cache the identity xOnlyPublicKey\n        this.cachedXOnlyPublicKey =\n            singleKey_1.SingleKey.fromPrivateKey(privKeyBytes).xOnlyPublicKey();\n    }\n    async clear() {\n        const message = {\n            type: "CLEAR",\n            id: getRandomId(),\n        };\n        await this.sendMessage(message);\n        // clear the cached xOnlyPublicKey\n        this.cachedXOnlyPublicKey = undefined;\n    }\n    // send a message and wait for a response\n    async sendMessage(message) {\n        return new Promise((resolve, reject) => {\n            const messageHandler = (event) => {\n                const response = event.data;\n                if (response.id === "") {\n                    reject(new Error("Invalid response id"));\n                    return;\n                }\n                if (response.id !== message.id) {\n                    return;\n                }\n                navigator.serviceWorker.removeEventListener("message", messageHandler);\n                if (!response.success) {\n                    reject(new Error(response.message));\n                }\n                else {\n                    resolve(response);\n                }\n            };\n            navigator.serviceWorker.addEventListener("message", messageHandler);\n            this.serviceWorker.postMessage(message);\n        });\n    }\n    async getAddress() {\n        const message = {\n            type: "GET_ADDRESS",\n            id: getRandomId(),\n        };\n        try {\n            const response = await this.sendMessage(message);\n            if (response_1.Response.isAddress(response)) {\n                return response.address;\n            }\n            throw new UnexpectedResponseError(response);\n        }\n        catch (error) {\n            throw new Error(`Failed to get address: ${error}`);\n        }\n    }\n    async getBoardingAddress() {\n        const message = {\n            type: "GET_BOARDING_ADDRESS",\n            id: getRandomId(),\n        };\n        try {\n            const response = await this.sendMessage(message);\n            if (response_1.Response.isBoardingAddress(response)) {\n                return response.address;\n            }\n            throw new UnexpectedResponseError(response);\n        }\n        catch (error) {\n            throw new Error(`Failed to get boarding address: ${error}`);\n        }\n    }\n    async getBalance() {\n        const message = {\n            type: "GET_BALANCE",\n            id: getRandomId(),\n        };\n        try {\n            const response = await this.sendMessage(message);\n            if (response_1.Response.isBalance(response)) {\n                return response.balance;\n            }\n            throw new UnexpectedResponseError(response);\n        }\n        catch (error) {\n            throw new Error(`Failed to get balance: ${error}`);\n        }\n    }\n    async getVtxos(filter) {\n        const message = {\n            type: "GET_VTXOS",\n            id: getRandomId(),\n            filter,\n        };\n        try {\n            const response = await this.sendMessage(message);\n            if (response_1.Response.isVtxos(response)) {\n                return response.vtxos;\n            }\n            throw new UnexpectedResponseError(response);\n        }\n        catch (error) {\n            throw new Error(`Failed to get vtxos: ${error}`);\n        }\n    }\n    async getBoardingUtxos() {\n        const message = {\n            type: "GET_BOARDING_UTXOS",\n            id: getRandomId(),\n        };\n        try {\n            const response = await this.sendMessage(message);\n            if (response_1.Response.isBoardingUtxos(response)) {\n                return response.boardingUtxos;\n            }\n            throw new UnexpectedResponseError(response);\n        }\n        catch (error) {\n            throw new Error(`Failed to get boarding UTXOs: ${error}`);\n        }\n    }\n    async sendBitcoin(params) {\n        const message = {\n            type: "SEND_BITCOIN",\n            params,\n            id: getRandomId(),\n        };\n        try {\n            const response = await this.sendMessage(message);\n            if (response_1.Response.isSendBitcoinSuccess(response)) {\n                return response.txid;\n            }\n            throw new UnexpectedResponseError(response);\n        }\n        catch (error) {\n            throw new Error(`Failed to send bitcoin: ${error}`);\n        }\n    }\n    async settle(params, callback) {\n        const message = {\n            type: "SETTLE",\n            params,\n            id: getRandomId(),\n        };\n        try {\n            return new Promise((resolve, reject) => {\n                const messageHandler = (event) => {\n                    const response = event.data;\n                    if (!response.success) {\n                        navigator.serviceWorker.removeEventListener("message", messageHandler);\n                        reject(new Error(response.message));\n                        return;\n                    }\n                    switch (response.type) {\n                        case "SETTLE_EVENT":\n                            if (callback) {\n                                callback(response.event);\n                            }\n                            break;\n                        case "SETTLE_SUCCESS":\n                            navigator.serviceWorker.removeEventListener("message", messageHandler);\n                            resolve(response.txid);\n                            break;\n                        default:\n                            break;\n                    }\n                };\n                navigator.serviceWorker.addEventListener("message", messageHandler);\n                this.serviceWorker.postMessage(message);\n            });\n        }\n        catch (error) {\n            throw new Error(`Settlement failed: ${error}`);\n        }\n    }\n    async getTransactionHistory() {\n        const message = {\n            type: "GET_TRANSACTION_HISTORY",\n            id: getRandomId(),\n        };\n        try {\n            const response = await this.sendMessage(message);\n            if (response_1.Response.isTransactionHistory(response)) {\n                return response.transactions;\n            }\n            throw new UnexpectedResponseError(response);\n        }\n        catch (error) {\n            throw new Error(`Failed to get transaction history: ${error}`);\n        }\n    }\n    xOnlyPublicKey() {\n        if (!this.cachedXOnlyPublicKey) {\n            throw new Error("Wallet not initialized");\n        }\n        return this.cachedXOnlyPublicKey;\n    }\n    signerSession() {\n        return signingSession_1.TreeSignerSession.random();\n    }\n    async sign(tx, inputIndexes) {\n        const message = {\n            type: "SIGN",\n            tx: base_1.base64.encode(tx.toPSBT()),\n            inputIndexes,\n            id: getRandomId(),\n        };\n        try {\n            const response = await this.sendMessage(message);\n            if (response_1.Response.isSignSuccess(response)) {\n                return btc_signer_1.Transaction.fromPSBT(base_1.base64.decode(response.tx), {\n                    allowUnknown: true,\n                    allowUnknownInputs: true,\n                });\n            }\n            throw new UnexpectedResponseError(response);\n        }\n        catch (error) {\n            throw new Error(`Failed to sign: ${error}`);\n        }\n    }\n}\nexports.ServiceWorkerWallet = ServiceWorkerWallet;\nfunction getRandomId() {\n    const randomValue = crypto.getRandomValues(new Uint8Array(16));\n    return base_1.hex.encode(randomValue);\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/wallet.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/worker.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Worker = void 0;\n/// <reference lib="webworker" />\nconst singleKey_1 = __webpack_require__(/*! ../../identity/singleKey */ "./node_modules/@arkade-os/sdk/dist/cjs/identity/singleKey.js");\nconst __1 = __webpack_require__(/*! .. */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/index.js");\nconst wallet_1 = __webpack_require__(/*! ../wallet */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/wallet.js");\nconst request_1 = __webpack_require__(/*! ./request */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/request.js");\nconst response_1 = __webpack_require__(/*! ./response */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/response.js");\nconst ark_1 = __webpack_require__(/*! ../../providers/ark */ "./node_modules/@arkade-os/sdk/dist/cjs/providers/ark.js");\nconst idb_1 = __webpack_require__(/*! ./db/vtxo/idb */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/db/vtxo/idb.js");\nconst transactionHistory_1 = __webpack_require__(/*! ../../utils/transactionHistory */ "./node_modules/@arkade-os/sdk/dist/cjs/utils/transactionHistory.js");\nconst indexer_1 = __webpack_require__(/*! ../../providers/indexer */ "./node_modules/@arkade-os/sdk/dist/cjs/providers/indexer.js");\nconst base_1 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\n/**\n * Worker is a class letting to interact with ServiceWorkerWallet from the client\n * it aims to be run in a service worker context\n */\nclass Worker {\n    constructor(vtxoRepository = new idb_1.IndexedDBVtxoRepository(), messageCallback = () => { }) {\n        this.vtxoRepository = vtxoRepository;\n        this.messageCallback = messageCallback;\n    }\n    async start(withServiceWorkerUpdate = true) {\n        self.addEventListener("message", async (event) => {\n            await this.handleMessage(event);\n        });\n        if (withServiceWorkerUpdate) {\n            // activate service worker immediately\n            self.addEventListener("install", () => {\n                self.skipWaiting();\n            });\n            // take control of clients immediately\n            self.addEventListener("activate", () => {\n                self.clients.claim();\n            });\n        }\n    }\n    async clear() {\n        if (this.vtxoSubscription) {\n            this.vtxoSubscription.abort();\n        }\n        await this.vtxoRepository.close();\n        this.wallet = undefined;\n        this.arkProvider = undefined;\n        this.indexerProvider = undefined;\n        this.vtxoSubscription = undefined;\n    }\n    async onWalletInitialized() {\n        if (!this.wallet ||\n            !this.arkProvider ||\n            !this.indexerProvider ||\n            !this.wallet.offchainTapscript ||\n            !this.wallet.boardingTapscript) {\n            return;\n        }\n        // subscribe to address updates\n        await this.vtxoRepository.open();\n        const encodedOffchainTapscript = this.wallet.offchainTapscript.encode();\n        const forfeit = this.wallet.offchainTapscript.forfeit();\n        const exit = this.wallet.offchainTapscript.exit();\n        const script = base_1.hex.encode(this.wallet.offchainTapscript.pkScript);\n        // set the initial vtxos state\n        const response = await this.indexerProvider.getVtxos({\n            scripts: [script],\n        });\n        const vtxos = response.vtxos.map((vtxo) => ({\n            ...vtxo,\n            forfeitTapLeafScript: forfeit,\n            intentTapLeafScript: exit,\n            tapTree: encodedOffchainTapscript,\n        }));\n        await this.vtxoRepository.addOrUpdate(vtxos);\n        this.processVtxoSubscription({\n            script,\n            vtxoScript: this.wallet.offchainTapscript,\n        });\n    }\n    async processVtxoSubscription({ script, vtxoScript, }) {\n        try {\n            const forfeitTapLeafScript = vtxoScript.forfeit();\n            const intentTapLeafScript = vtxoScript.exit();\n            const abortController = new AbortController();\n            const subscriptionId = await this.indexerProvider.subscribeForScripts([script]);\n            const subscription = this.indexerProvider.getSubscription(subscriptionId, abortController.signal);\n            this.vtxoSubscription = abortController;\n            const tapTree = vtxoScript.encode();\n            for await (const update of subscription) {\n                const vtxos = [...update.newVtxos, ...update.spentVtxos];\n                if (vtxos.length === 0) {\n                    continue;\n                }\n                const extendedVtxos = vtxos.map((vtxo) => ({\n                    ...vtxo,\n                    forfeitTapLeafScript,\n                    intentTapLeafScript,\n                    tapTree,\n                }));\n                await this.vtxoRepository.addOrUpdate(extendedVtxos);\n            }\n        }\n        catch (error) {\n            console.error("Error processing address updates:", error);\n        }\n    }\n    async handleClear(event) {\n        this.clear();\n        if (request_1.Request.isBase(event.data)) {\n            event.source?.postMessage(response_1.Response.clearResponse(event.data.id, true));\n        }\n    }\n    async handleInitWallet(event) {\n        const message = event.data;\n        if (!request_1.Request.isInitWallet(message)) {\n            console.error("Invalid INIT_WALLET message format", message);\n            event.source?.postMessage(response_1.Response.error(message.id, "Invalid INIT_WALLET message format"));\n            return;\n        }\n        try {\n            this.arkProvider = new ark_1.RestArkProvider(message.arkServerUrl);\n            this.indexerProvider = new indexer_1.RestIndexerProvider(message.arkServerUrl);\n            this.wallet = await wallet_1.Wallet.create({\n                identity: singleKey_1.SingleKey.fromHex(message.privateKey),\n                arkServerUrl: message.arkServerUrl,\n                arkServerPublicKey: message.arkServerPublicKey,\n            });\n            event.source?.postMessage(response_1.Response.walletInitialized(message.id));\n            await this.onWalletInitialized();\n        }\n        catch (error) {\n            console.error("Error initializing wallet:", error);\n            const errorMessage = error instanceof Error\n                ? error.message\n                : "Unknown error occurred";\n            event.source?.postMessage(response_1.Response.error(message.id, errorMessage));\n        }\n    }\n    async handleSettle(event) {\n        const message = event.data;\n        if (!request_1.Request.isSettle(message)) {\n            console.error("Invalid SETTLE message format", message);\n            event.source?.postMessage(response_1.Response.error(message.id, "Invalid SETTLE message format"));\n            return;\n        }\n        try {\n            if (!this.wallet) {\n                console.error("Wallet not initialized");\n                event.source?.postMessage(response_1.Response.error(message.id, "Wallet not initialized"));\n                return;\n            }\n            const txid = await this.wallet.settle(message.params, (e) => {\n                event.source?.postMessage(response_1.Response.settleEvent(message.id, e));\n            });\n            event.source?.postMessage(response_1.Response.settleSuccess(message.id, txid));\n        }\n        catch (error) {\n            console.error("Error settling:", error);\n            const errorMessage = error instanceof Error\n                ? error.message\n                : "Unknown error occurred";\n            event.source?.postMessage(response_1.Response.error(message.id, errorMessage));\n        }\n    }\n    async handleSendBitcoin(event) {\n        const message = event.data;\n        if (!request_1.Request.isSendBitcoin(message)) {\n            console.error("Invalid SEND_BITCOIN message format", message);\n            event.source?.postMessage(response_1.Response.error(message.id, "Invalid SEND_BITCOIN message format"));\n            return;\n        }\n        if (!this.wallet) {\n            console.error("Wallet not initialized");\n            event.source?.postMessage(response_1.Response.error(message.id, "Wallet not initialized"));\n            return;\n        }\n        try {\n            const txid = await this.wallet.sendBitcoin(message.params);\n            event.source?.postMessage(response_1.Response.sendBitcoinSuccess(message.id, txid));\n        }\n        catch (error) {\n            console.error("Error sending bitcoin:", error);\n            const errorMessage = error instanceof Error\n                ? error.message\n                : "Unknown error occurred";\n            event.source?.postMessage(response_1.Response.error(message.id, errorMessage));\n        }\n    }\n    async handleGetAddress(event) {\n        const message = event.data;\n        if (!request_1.Request.isGetAddress(message)) {\n            console.error("Invalid GET_ADDRESS message format", message);\n            event.source?.postMessage(response_1.Response.error(message.id, "Invalid GET_ADDRESS message format"));\n            return;\n        }\n        if (!this.wallet) {\n            console.error("Wallet not initialized");\n            event.source?.postMessage(response_1.Response.error(message.id, "Wallet not initialized"));\n            return;\n        }\n        try {\n            const address = await this.wallet.getAddress();\n            event.source?.postMessage(response_1.Response.address(message.id, address));\n        }\n        catch (error) {\n            console.error("Error getting address:", error);\n            const errorMessage = error instanceof Error\n                ? error.message\n                : "Unknown error occurred";\n            event.source?.postMessage(response_1.Response.error(message.id, errorMessage));\n        }\n    }\n    async handleGetBoardingAddress(event) {\n        const message = event.data;\n        if (!request_1.Request.isGetBoardingAddress(message)) {\n            console.error("Invalid GET_BOARDING_ADDRESS message format", message);\n            event.source?.postMessage(response_1.Response.error(message.id, "Invalid GET_BOARDING_ADDRESS message format"));\n            return;\n        }\n        if (!this.wallet) {\n            console.error("Wallet not initialized");\n            event.source?.postMessage(response_1.Response.error(message.id, "Wallet not initialized"));\n            return;\n        }\n        try {\n            const address = await this.wallet.getBoardingAddress();\n            event.source?.postMessage(response_1.Response.boardingAddress(message.id, address));\n        }\n        catch (error) {\n            console.error("Error getting boarding address:", error);\n            const errorMessage = error instanceof Error\n                ? error.message\n                : "Unknown error occurred";\n            event.source?.postMessage(response_1.Response.error(message.id, errorMessage));\n        }\n    }\n    async handleGetBalance(event) {\n        const message = event.data;\n        if (!request_1.Request.isGetBalance(message)) {\n            console.error("Invalid GET_BALANCE message format", message);\n            event.source?.postMessage(response_1.Response.error(message.id, "Invalid GET_BALANCE message format"));\n            return;\n        }\n        if (!this.wallet) {\n            console.error("Wallet not initialized");\n            event.source?.postMessage(response_1.Response.error(message.id, "Wallet not initialized"));\n            return;\n        }\n        try {\n            const [boardingUtxos, spendableVtxos, sweptVtxos] = await Promise.all([\n                this.wallet.getBoardingUtxos(),\n                this.vtxoRepository.getSpendableVtxos(),\n                this.vtxoRepository.getSweptVtxos(),\n            ]);\n            // boarding\n            let confirmed = 0;\n            let unconfirmed = 0;\n            for (const utxo of boardingUtxos) {\n                if (utxo.status.confirmed) {\n                    confirmed += utxo.value;\n                }\n                else {\n                    unconfirmed += utxo.value;\n                }\n            }\n            // offchain\n            let settled = 0;\n            let preconfirmed = 0;\n            let recoverable = 0;\n            for (const vtxo of spendableVtxos) {\n                if (vtxo.virtualStatus.state === "settled") {\n                    settled += vtxo.value;\n                }\n                else if (vtxo.virtualStatus.state === "preconfirmed") {\n                    preconfirmed += vtxo.value;\n                }\n            }\n            for (const vtxo of sweptVtxos) {\n                if ((0, __1.isSpendable)(vtxo)) {\n                    recoverable += vtxo.value;\n                }\n            }\n            const totalBoarding = confirmed + unconfirmed;\n            const totalOffchain = settled + preconfirmed + recoverable;\n            event.source?.postMessage(response_1.Response.balance(message.id, {\n                boarding: {\n                    confirmed,\n                    unconfirmed,\n                    total: totalBoarding,\n                },\n                settled,\n                preconfirmed,\n                available: settled + preconfirmed,\n                recoverable,\n                total: totalBoarding + totalOffchain,\n            }));\n        }\n        catch (error) {\n            console.error("Error getting balance:", error);\n            const errorMessage = error instanceof Error\n                ? error.message\n                : "Unknown error occurred";\n            event.source?.postMessage(response_1.Response.error(message.id, errorMessage));\n        }\n    }\n    async handleGetVtxos(event) {\n        const message = event.data;\n        if (!request_1.Request.isGetVtxos(message)) {\n            console.error("Invalid GET_VTXOS message format", message);\n            event.source?.postMessage(response_1.Response.error(message.id, "Invalid GET_VTXOS message format"));\n            return;\n        }\n        if (!this.wallet) {\n            console.error("Wallet not initialized");\n            event.source?.postMessage(response_1.Response.error(message.id, "Wallet not initialized"));\n            return;\n        }\n        try {\n            let vtxos = await this.vtxoRepository.getSpendableVtxos();\n            if (!message.filter?.withRecoverable) {\n                if (!this.wallet)\n                    throw new Error("Wallet not initialized");\n                // exclude subdust is we don\'t want recoverable\n                vtxos = vtxos.filter((v) => !(0, __1.isSubdust)(v, this.wallet.dustAmount));\n            }\n            if (message.filter?.withRecoverable) {\n                // get also swept and spendable vtxos\n                const sweptVtxos = await this.vtxoRepository.getSweptVtxos();\n                vtxos.push(...sweptVtxos.filter(__1.isSpendable));\n            }\n            event.source?.postMessage(response_1.Response.vtxos(message.id, vtxos));\n        }\n        catch (error) {\n            console.error("Error getting vtxos:", error);\n            const errorMessage = error instanceof Error\n                ? error.message\n                : "Unknown error occurred";\n            event.source?.postMessage(response_1.Response.error(message.id, errorMessage));\n        }\n    }\n    async handleGetBoardingUtxos(event) {\n        const message = event.data;\n        if (!request_1.Request.isGetBoardingUtxos(message)) {\n            console.error("Invalid GET_BOARDING_UTXOS message format", message);\n            event.source?.postMessage(response_1.Response.error(message.id, "Invalid GET_BOARDING_UTXOS message format"));\n            return;\n        }\n        if (!this.wallet) {\n            console.error("Wallet not initialized");\n            event.source?.postMessage(response_1.Response.error(message.id, "Wallet not initialized"));\n            return;\n        }\n        try {\n            const boardingUtxos = await this.wallet.getBoardingUtxos();\n            event.source?.postMessage(response_1.Response.boardingUtxos(message.id, boardingUtxos));\n        }\n        catch (error) {\n            console.error("Error getting boarding utxos:", error);\n            const errorMessage = error instanceof Error\n                ? error.message\n                : "Unknown error occurred";\n            event.source?.postMessage(response_1.Response.error(message.id, errorMessage));\n        }\n    }\n    async handleGetTransactionHistory(event) {\n        const message = event.data;\n        if (!request_1.Request.isGetTransactionHistory(message)) {\n            console.error("Invalid GET_TRANSACTION_HISTORY message format", message);\n            event.source?.postMessage(response_1.Response.error(message.id, "Invalid GET_TRANSACTION_HISTORY message format"));\n            return;\n        }\n        if (!this.wallet) {\n            console.error("Wallet not initialized");\n            event.source?.postMessage(response_1.Response.error(message.id, "Wallet not initialized"));\n            return;\n        }\n        try {\n            const { boardingTxs, commitmentsToIgnore: roundsToIgnore } = await this.wallet.getBoardingTxs();\n            const { spendable, spent } = await this.vtxoRepository.getAllVtxos();\n            // convert VTXOs to offchain transactions\n            const offchainTxs = (0, transactionHistory_1.vtxosToTxs)(spendable, spent, roundsToIgnore);\n            const txs = [...boardingTxs, ...offchainTxs];\n            // sort transactions by creation time in descending order (newest first)\n            txs.sort(\n            // place createdAt = 0 (unconfirmed txs) first, then descending\n            (a, b) => {\n                if (a.createdAt === 0)\n                    return -1;\n                if (b.createdAt === 0)\n                    return 1;\n                return b.createdAt - a.createdAt;\n            });\n            event.source?.postMessage(response_1.Response.transactionHistory(message.id, txs));\n        }\n        catch (error) {\n            console.error("Error getting transaction history:", error);\n            const errorMessage = error instanceof Error\n                ? error.message\n                : "Unknown error occurred";\n            event.source?.postMessage(response_1.Response.error(message.id, errorMessage));\n        }\n    }\n    async handleGetStatus(event) {\n        const message = event.data;\n        if (!request_1.Request.isGetStatus(message)) {\n            console.error("Invalid GET_STATUS message format", message);\n            event.source?.postMessage(response_1.Response.error(message.id, "Invalid GET_STATUS message format"));\n            return;\n        }\n        event.source?.postMessage(response_1.Response.walletStatus(message.id, this.wallet !== undefined, this.wallet?.identity.xOnlyPublicKey()));\n    }\n    async handleSign(event) {\n        const message = event.data;\n        if (!request_1.Request.isSign(message)) {\n            console.error("Invalid SIGN message format", message);\n            event.source?.postMessage(response_1.Response.error(message.id, "Invalid SIGN message format"));\n            return;\n        }\n        if (!this.wallet) {\n            console.error("Wallet not initialized");\n            event.source?.postMessage(response_1.Response.error(message.id, "Wallet not initialized"));\n            return;\n        }\n        try {\n            const tx = btc_signer_1.Transaction.fromPSBT(base_1.base64.decode(message.tx), {\n                allowUnknown: true,\n                allowUnknownInputs: true,\n            });\n            const signedTx = await this.wallet.identity.sign(tx, message.inputIndexes);\n            event.source?.postMessage(response_1.Response.signSuccess(message.id, base_1.base64.encode(signedTx.toPSBT())));\n        }\n        catch (error) {\n            console.error("Error signing:", error);\n            const errorMessage = error instanceof Error\n                ? error.message\n                : "Unknown error occurred";\n            event.source?.postMessage(response_1.Response.error(message.id, errorMessage));\n        }\n    }\n    async handleMessage(event) {\n        this.messageCallback(event);\n        const message = event.data;\n        if (!request_1.Request.isBase(message)) {\n            console.warn("Invalid message format", JSON.stringify(message));\n            // ignore invalid messages\n            return;\n        }\n        switch (message.type) {\n            case "INIT_WALLET": {\n                await this.handleInitWallet(event);\n                break;\n            }\n            case "SETTLE": {\n                await this.handleSettle(event);\n                break;\n            }\n            case "SEND_BITCOIN": {\n                await this.handleSendBitcoin(event);\n                break;\n            }\n            case "GET_ADDRESS": {\n                await this.handleGetAddress(event);\n                break;\n            }\n            case "GET_BOARDING_ADDRESS": {\n                await this.handleGetBoardingAddress(event);\n                break;\n            }\n            case "GET_BALANCE": {\n                await this.handleGetBalance(event);\n                break;\n            }\n            case "GET_VTXOS": {\n                await this.handleGetVtxos(event);\n                break;\n            }\n            case "GET_BOARDING_UTXOS": {\n                await this.handleGetBoardingUtxos(event);\n                break;\n            }\n            case "GET_TRANSACTION_HISTORY": {\n                await this.handleGetTransactionHistory(event);\n                break;\n            }\n            case "GET_STATUS": {\n                await this.handleGetStatus(event);\n                break;\n            }\n            case "CLEAR": {\n                await this.handleClear(event);\n                break;\n            }\n            case "SIGN": {\n                await this.handleSign(event);\n                break;\n            }\n            default:\n                event.source?.postMessage(response_1.Response.error(message.id, "Unknown message type"));\n        }\n    }\n}\nexports.Worker = Worker;\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/wallet/serviceWorker/worker.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/wallet/unroll.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Unroll = void 0;\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\nconst indexer_1 = __webpack_require__(/*! ../providers/indexer */ "./node_modules/@arkade-os/sdk/dist/cjs/providers/indexer.js");\nconst base_1 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nconst base_2 = __webpack_require__(/*! ../script/base */ "./node_modules/@arkade-os/sdk/dist/cjs/script/base.js");\nconst psbt_1 = __webpack_require__(/*! @scure/btc-signer/psbt */ "./node_modules/@scure/btc-signer/psbt.js");\nconst txSizeEstimator_1 = __webpack_require__(/*! ../utils/txSizeEstimator */ "./node_modules/@arkade-os/sdk/dist/cjs/utils/txSizeEstimator.js");\nconst wallet_1 = __webpack_require__(/*! ./wallet */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/wallet.js");\nvar Unroll;\n(function (Unroll) {\n    let StepType;\n    (function (StepType) {\n        StepType[StepType["UNROLL"] = 0] = "UNROLL";\n        StepType[StepType["WAIT"] = 1] = "WAIT";\n        StepType[StepType["DONE"] = 2] = "DONE";\n    })(StepType = Unroll.StepType || (Unroll.StepType = {}));\n    /**\n     * Manages the unrolling process of a VTXO back to the Bitcoin blockchain.\n     *\n     * The Session class implements an async iterator that processes the unrolling steps:\n     * 1. **WAIT**: Waits for a transaction to be confirmed onchain (if it\'s in mempool)\n     * 2. **UNROLL**: Broadcasts the next transaction in the chain to the blockchain\n     * 3. **DONE**: Indicates the unrolling process is complete\n     *\n     * The unrolling process works by traversing the transaction chain from the root (most recent)\n     * to the leaf (oldest), broadcasting each transaction that isn\'t already onchain.\n     *\n     * @example\n     * ```typescript\n     * const session = await Unroll.Session.create(vtxoOutpoint, bumper, explorer, indexer);\n     *\n     * // iterate over the steps\n     * for await (const doneStep of session) {\n     *   switch (doneStep.type) {\n     *     case Unroll.StepType.WAIT:\n     *       console.log(`Transaction ${doneStep.txid} confirmed`);\n     *       break;\n     *     case Unroll.StepType.UNROLL:\n     *       console.log(`Broadcasting transaction ${doneStep.tx.id}`);\n     *       break;\n     *     case Unroll.StepType.DONE:\n     *       console.log(`Unrolling complete for VTXO ${doneStep.vtxoTxid}`);\n     *       break;\n     *   }\n     * }\n     * ```\n     **/\n    class Session {\n        constructor(toUnroll, bumper, explorer, indexer) {\n            this.toUnroll = toUnroll;\n            this.bumper = bumper;\n            this.explorer = explorer;\n            this.indexer = indexer;\n        }\n        static async create(toUnroll, bumper, explorer, indexer) {\n            const { chain } = await indexer.getVtxoChain(toUnroll);\n            return new Session({ ...toUnroll, chain }, bumper, explorer, indexer);\n        }\n        /**\n         * Get the next step to be executed\n         * @returns The next step to be executed + the function to execute it\n         */\n        async next() {\n            let nextTxToBroadcast;\n            const chain = this.toUnroll.chain;\n            // Iterate through the chain from the end (root) to the beginning (leaf)\n            for (let i = chain.length - 1; i >= 0; i--) {\n                const chainTx = chain[i];\n                // Skip commitment transactions as they are always onchain\n                if (chainTx.type === indexer_1.ChainTxType.COMMITMENT ||\n                    chainTx.type === indexer_1.ChainTxType.UNSPECIFIED) {\n                    continue;\n                }\n                try {\n                    // Check if the transaction is confirmed onchain\n                    const txInfo = await this.explorer.getTxStatus(chainTx.txid);\n                    // If found but not confirmed, it means the tx is in the mempool\n                    // An unilateral exit is running, we must wait for it to be confirmed\n                    if (!txInfo.confirmed) {\n                        return {\n                            type: StepType.WAIT,\n                            txid: chainTx.txid,\n                            do: doWait(this.explorer, chainTx.txid),\n                        };\n                    }\n                }\n                catch (e) {\n                    // If the tx is not found, it\'s offchain, let\'s break\n                    nextTxToBroadcast = chainTx;\n                    break;\n                }\n            }\n            if (!nextTxToBroadcast) {\n                return {\n                    type: StepType.DONE,\n                    vtxoTxid: this.toUnroll.txid,\n                    do: () => Promise.resolve(),\n                };\n            }\n            // Get the virtual transaction data\n            const virtualTxs = await this.indexer.getVirtualTxs([\n                nextTxToBroadcast.txid,\n            ]);\n            if (virtualTxs.txs.length === 0) {\n                throw new Error(`Tx ${nextTxToBroadcast.txid} not found`);\n            }\n            const tx = btc_signer_1.Transaction.fromPSBT(base_1.base64.decode(virtualTxs.txs[0]), {\n                allowUnknownInputs: true,\n            });\n            // finalize the tree transaction\n            if (nextTxToBroadcast.type === indexer_1.ChainTxType.TREE) {\n                const input = tx.getInput(0);\n                if (!input) {\n                    throw new Error("Input not found");\n                }\n                const tapKeySig = input.tapKeySig;\n                if (!tapKeySig) {\n                    throw new Error("Tap key sig not found");\n                }\n                tx.updateInput(0, {\n                    finalScriptWitness: [tapKeySig],\n                });\n            }\n            else {\n                // finalize ark transaction\n                tx.finalize();\n            }\n            return {\n                type: StepType.UNROLL,\n                tx,\n                do: doUnroll(this.bumper, this.explorer, tx),\n            };\n        }\n        /**\n         * Iterate over the steps to be executed and execute them\n         * @returns An async iterator over the executed steps\n         */\n        async *[Symbol.asyncIterator]() {\n            let lastStep;\n            do {\n                if (lastStep !== undefined) {\n                    // wait 1 second before trying the next step in order to give time to the\n                    // explorer to update the tx status\n                    await sleep(1000);\n                }\n                const step = await this.next();\n                await step.do();\n                yield step;\n                lastStep = step.type;\n            } while (lastStep !== StepType.DONE);\n        }\n    }\n    Unroll.Session = Session;\n    /**\n     * Complete the unroll of a VTXO by broadcasting the transaction that spends the CSV path.\n     * @param wallet the wallet owning the VTXO(s)\n     * @param vtxoTxids the txids of the VTXO(s) to complete unroll\n     * @param outputAddress the address to send the unrolled funds to\n     * @throws if the VTXO(s) are not fully unrolled, if the txids are not found, if the tx is not confirmed, if no exit path is found or not available\n     * @returns the txid of the transaction spending the unrolled funds\n     */\n    async function completeUnroll(wallet, vtxoTxids, outputAddress) {\n        const chainTip = await wallet.onchainProvider.getChainTip();\n        let vtxos = await wallet.getVtxos({ withUnrolled: true });\n        vtxos = vtxos.filter((vtxo) => vtxoTxids.includes(vtxo.txid));\n        if (vtxos.length === 0) {\n            throw new Error("No vtxos to complete unroll");\n        }\n        const inputs = [];\n        let totalAmount = 0n;\n        const txWeightEstimator = txSizeEstimator_1.TxWeightEstimator.create();\n        for (const vtxo of vtxos) {\n            if (!vtxo.isUnrolled) {\n                throw new Error(`Vtxo ${vtxo.txid}:${vtxo.vout} is not fully unrolled, use unroll first`);\n            }\n            const txStatus = await wallet.onchainProvider.getTxStatus(vtxo.txid);\n            if (!txStatus.confirmed) {\n                throw new Error(`tx ${vtxo.txid} is not confirmed`);\n            }\n            const exit = availableExitPath({ height: txStatus.blockHeight, time: txStatus.blockTime }, chainTip, vtxo);\n            if (!exit) {\n                throw new Error(`no available exit path found for vtxo ${vtxo.txid}:${vtxo.vout}`);\n            }\n            const spendingLeaf = base_2.VtxoScript.decode(vtxo.tapTree).findLeaf(base_1.hex.encode(exit.script));\n            if (!spendingLeaf) {\n                throw new Error(`spending leaf not found for vtxo ${vtxo.txid}:${vtxo.vout}`);\n            }\n            totalAmount += BigInt(vtxo.value);\n            inputs.push({\n                txid: vtxo.txid,\n                index: vtxo.vout,\n                tapLeafScript: [spendingLeaf],\n                sequence: 0xffffffff - 1,\n                witnessUtxo: {\n                    amount: BigInt(vtxo.value),\n                    script: base_2.VtxoScript.decode(vtxo.tapTree).pkScript,\n                },\n                sighashType: btc_signer_1.SigHash.DEFAULT,\n            });\n            txWeightEstimator.addTapscriptInput(64, spendingLeaf[1].length, psbt_1.TaprootControlBlock.encode(spendingLeaf[0]).length);\n        }\n        const tx = new btc_signer_1.Transaction({ allowUnknownInputs: true, version: 2 });\n        for (const input of inputs) {\n            tx.addInput(input);\n        }\n        txWeightEstimator.addP2TROutput();\n        let feeRate = await wallet.onchainProvider.getFeeRate();\n        if (!feeRate || feeRate < wallet_1.Wallet.MIN_FEE_RATE) {\n            feeRate = wallet_1.Wallet.MIN_FEE_RATE;\n        }\n        const feeAmount = txWeightEstimator.vsize().fee(BigInt(feeRate));\n        if (feeAmount > totalAmount) {\n            throw new Error("fee amount is greater than the total amount");\n        }\n        tx.addOutputAddress(outputAddress, totalAmount - feeAmount);\n        const signedTx = await wallet.identity.sign(tx);\n        signedTx.finalize();\n        await wallet.onchainProvider.broadcastTransaction(signedTx.hex);\n        return signedTx.id;\n    }\n    Unroll.completeUnroll = completeUnroll;\n})(Unroll || (exports.Unroll = Unroll = {}));\nfunction sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction doUnroll(bumper, onchainProvider, tx) {\n    return async () => {\n        const [parent, child] = await bumper.bumpP2A(tx);\n        await onchainProvider.broadcastTransaction(parent, child);\n    };\n}\nfunction doWait(onchainProvider, txid) {\n    return () => {\n        return new Promise((resolve, reject) => {\n            const interval = setInterval(async () => {\n                try {\n                    const txInfo = await onchainProvider.getTxStatus(txid);\n                    if (txInfo.confirmed) {\n                        clearInterval(interval);\n                        resolve();\n                    }\n                }\n                catch (e) {\n                    clearInterval(interval);\n                    reject(e);\n                }\n            }, 5000);\n        });\n    };\n}\nfunction availableExitPath(confirmedAt, current, vtxo) {\n    const exits = base_2.VtxoScript.decode(vtxo.tapTree).exitPaths();\n    for (const exit of exits) {\n        if (exit.params.timelock.type === "blocks") {\n            if (current.height >=\n                confirmedAt.height + Number(exit.params.timelock.value)) {\n                return exit;\n            }\n        }\n        else {\n            if (current.time >=\n                confirmedAt.time + Number(exit.params.timelock.value)) {\n                return exit;\n            }\n        }\n    }\n    return undefined;\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/wallet/unroll.js?\n}')},"./node_modules/@arkade-os/sdk/dist/cjs/wallet/wallet.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Wallet = void 0;\nexports.waitForIncomingFunds = waitForIncomingFunds;\nconst base_1 = __webpack_require__(/*! @scure/base */ "./node_modules/@scure/base/lib/index.js");\nconst bip68 = __importStar(__webpack_require__(/*! bip68 */ "./node_modules/bip68/index.js"));\nconst payment_1 = __webpack_require__(/*! @scure/btc-signer/payment */ "./node_modules/@scure/btc-signer/payment.js");\nconst btc_signer_1 = __webpack_require__(/*! @scure/btc-signer */ "./node_modules/@scure/btc-signer/index.js");\nconst psbt_1 = __webpack_require__(/*! @scure/btc-signer/psbt */ "./node_modules/@scure/btc-signer/psbt.js");\nconst transactionHistory_1 = __webpack_require__(/*! ../utils/transactionHistory */ "./node_modules/@arkade-os/sdk/dist/cjs/utils/transactionHistory.js");\nconst address_1 = __webpack_require__(/*! ../script/address */ "./node_modules/@arkade-os/sdk/dist/cjs/script/address.js");\nconst default_1 = __webpack_require__(/*! ../script/default */ "./node_modules/@arkade-os/sdk/dist/cjs/script/default.js");\nconst networks_1 = __webpack_require__(/*! ../networks */ "./node_modules/@arkade-os/sdk/dist/cjs/networks.js");\nconst onchain_1 = __webpack_require__(/*! ../providers/onchain */ "./node_modules/@arkade-os/sdk/dist/cjs/providers/onchain.js");\nconst ark_1 = __webpack_require__(/*! ../providers/ark */ "./node_modules/@arkade-os/sdk/dist/cjs/providers/ark.js");\nconst forfeit_1 = __webpack_require__(/*! ../forfeit */ "./node_modules/@arkade-os/sdk/dist/cjs/forfeit.js");\nconst validation_1 = __webpack_require__(/*! ../tree/validation */ "./node_modules/@arkade-os/sdk/dist/cjs/tree/validation.js");\nconst _1 = __webpack_require__(/*! . */ "./node_modules/@arkade-os/sdk/dist/cjs/wallet/index.js");\nconst utils_1 = __webpack_require__(/*! @scure/btc-signer/utils */ "./node_modules/@scure/btc-signer/utils.js");\nconst base_2 = __webpack_require__(/*! ../script/base */ "./node_modules/@arkade-os/sdk/dist/cjs/script/base.js");\nconst tapscript_1 = __webpack_require__(/*! ../script/tapscript */ "./node_modules/@arkade-os/sdk/dist/cjs/script/tapscript.js");\nconst arkTransaction_1 = __webpack_require__(/*! ../utils/arkTransaction */ "./node_modules/@arkade-os/sdk/dist/cjs/utils/arkTransaction.js");\nconst arknote_1 = __webpack_require__(/*! ../arknote */ "./node_modules/@arkade-os/sdk/dist/cjs/arknote/index.js");\nconst bip322_1 = __webpack_require__(/*! ../bip322 */ "./node_modules/@arkade-os/sdk/dist/cjs/bip322/index.js");\nconst indexer_1 = __webpack_require__(/*! ../providers/indexer */ "./node_modules/@arkade-os/sdk/dist/cjs/providers/indexer.js");\nconst txTree_1 = __webpack_require__(/*! ../tree/txTree */ "./node_modules/@arkade-os/sdk/dist/cjs/tree/txTree.js");\n/**\n * Main wallet implementation for Bitcoin transactions with Ark protocol support.\n * The wallet does not store any data locally and relies on Ark and onchain\n * providers to fetch UTXOs and VTXOs.\n *\n * @example\n * ```typescript\n * // Create a wallet\n * const wallet = await Wallet.create({\n *   identity: SingleKey.fromHex(\'your_private_key\'),\n *   arkServerUrl: \'https://ark.example.com\',\n *   esploraUrl: \'https://mempool.space/api\'\n * });\n *\n * // Get addresses\n * const arkAddress = await wallet.getAddress();\n * const boardingAddress = await wallet.getBoardingAddress();\n *\n * // Send bitcoin\n * const txid = await wallet.sendBitcoin({\n *   address: \'tb1...\',\n *   amount: 50000\n * });\n * ```\n */\nclass Wallet {\n    constructor(identity, network, networkName, onchainProvider, arkProvider, indexerProvider, arkServerPublicKey, offchainTapscript, boardingTapscript, serverUnrollScript, forfeitOutputScript, dustAmount) {\n        this.identity = identity;\n        this.network = network;\n        this.networkName = networkName;\n        this.onchainProvider = onchainProvider;\n        this.arkProvider = arkProvider;\n        this.indexerProvider = indexerProvider;\n        this.arkServerPublicKey = arkServerPublicKey;\n        this.offchainTapscript = offchainTapscript;\n        this.boardingTapscript = boardingTapscript;\n        this.serverUnrollScript = serverUnrollScript;\n        this.forfeitOutputScript = forfeitOutputScript;\n        this.dustAmount = dustAmount;\n    }\n    static async create(config) {\n        const pubkey = config.identity.xOnlyPublicKey();\n        if (!pubkey) {\n            throw new Error("Invalid configured public key");\n        }\n        const arkProvider = new ark_1.RestArkProvider(config.arkServerUrl);\n        const indexerProvider = new indexer_1.RestIndexerProvider(config.arkServerUrl);\n        const info = await arkProvider.getInfo();\n        const network = (0, networks_1.getNetwork)(info.network);\n        const onchainProvider = new onchain_1.EsploraProvider(config.esploraUrl || onchain_1.ESPLORA_URL[info.network]);\n        const exitTimelock = {\n            value: info.unilateralExitDelay,\n            type: info.unilateralExitDelay < 512n ? "blocks" : "seconds",\n        };\n        const boardingTimelock = {\n            value: info.boardingExitDelay,\n            type: info.boardingExitDelay < 512n ? "blocks" : "seconds",\n        };\n        // Generate tapscripts for offchain and boarding address\n        const serverPubKey = base_1.hex.decode(info.signerPubkey).slice(1);\n        const bareVtxoTapscript = new default_1.DefaultVtxo.Script({\n            pubKey: pubkey,\n            serverPubKey,\n            csvTimelock: exitTimelock,\n        });\n        const boardingTapscript = new default_1.DefaultVtxo.Script({\n            pubKey: pubkey,\n            serverPubKey,\n            csvTimelock: boardingTimelock,\n        });\n        // Save tapscripts\n        const offchainTapscript = bareVtxoTapscript;\n        // the serverUnrollScript is the one used to create output scripts of the checkpoint transactions\n        const serverUnrollScript = tapscript_1.CSVMultisigTapscript.encode({\n            timelock: exitTimelock,\n            pubkeys: [serverPubKey],\n        });\n        // parse the server forfeit address\n        // server is expecting funds to be sent to this address\n        const forfeitAddress = (0, payment_1.Address)(network).decode(info.forfeitAddress);\n        const forfeitOutputScript = payment_1.OutScript.encode(forfeitAddress);\n        return new Wallet(config.identity, network, info.network, onchainProvider, arkProvider, indexerProvider, serverPubKey, offchainTapscript, boardingTapscript, serverUnrollScript, forfeitOutputScript, info.dust);\n    }\n    get arkAddress() {\n        return this.offchainTapscript.address(this.network.hrp, this.arkServerPublicKey);\n    }\n    async getAddress() {\n        return this.arkAddress.encode();\n    }\n    async getBoardingAddress() {\n        return this.boardingTapscript.onchainAddress(this.network);\n    }\n    async getBalance() {\n        const [boardingUtxos, vtxos] = await Promise.all([\n            this.getBoardingUtxos(),\n            this.getVtxos(),\n        ]);\n        // boarding\n        let confirmed = 0;\n        let unconfirmed = 0;\n        for (const utxo of boardingUtxos) {\n            if (utxo.status.confirmed) {\n                confirmed += utxo.value;\n            }\n            else {\n                unconfirmed += utxo.value;\n            }\n        }\n        // offchain\n        let settled = 0;\n        let preconfirmed = 0;\n        let recoverable = 0;\n        settled = vtxos\n            .filter((coin) => coin.virtualStatus.state === "settled")\n            .reduce((sum, coin) => sum + coin.value, 0);\n        preconfirmed = vtxos\n            .filter((coin) => coin.virtualStatus.state === "preconfirmed")\n            .reduce((sum, coin) => sum + coin.value, 0);\n        recoverable = vtxos\n            .filter((coin) => (0, _1.isSpendable)(coin) && coin.virtualStatus.state === "swept")\n            .reduce((sum, coin) => sum + coin.value, 0);\n        const totalBoarding = confirmed + unconfirmed;\n        const totalOffchain = settled + preconfirmed + recoverable;\n        return {\n            boarding: {\n                confirmed,\n                unconfirmed,\n                total: totalBoarding,\n            },\n            settled,\n            preconfirmed,\n            available: settled + preconfirmed,\n            recoverable,\n            total: totalBoarding + totalOffchain,\n        };\n    }\n    async getVtxos(filter) {\n        const spendableVtxos = await this.getVirtualCoins(filter);\n        const encodedOffchainTapscript = this.offchainTapscript.encode();\n        const forfeit = this.offchainTapscript.forfeit();\n        const exit = this.offchainTapscript.exit();\n        return spendableVtxos.map((vtxo) => ({\n            ...vtxo,\n            forfeitTapLeafScript: forfeit,\n            intentTapLeafScript: exit,\n            tapTree: encodedOffchainTapscript,\n        }));\n    }\n    async getVirtualCoins(filter = { withRecoverable: true, withUnrolled: false }) {\n        const scripts = [base_1.hex.encode(this.offchainTapscript.pkScript)];\n        const response = await this.indexerProvider.getVtxos({\n            scripts,\n            spendableOnly: true,\n        });\n        const vtxos = response.vtxos;\n        if (filter.withRecoverable) {\n            const response = await this.indexerProvider.getVtxos({\n                scripts,\n                recoverableOnly: true,\n            });\n            vtxos.push(...response.vtxos);\n        }\n        if (filter.withUnrolled) {\n            const response = await this.indexerProvider.getVtxos({\n                scripts,\n                spentOnly: true,\n            });\n            vtxos.push(...response.vtxos.filter((vtxo) => vtxo.isUnrolled));\n        }\n        return vtxos;\n    }\n    async getTransactionHistory() {\n        if (!this.indexerProvider) {\n            return [];\n        }\n        const response = await this.indexerProvider.getVtxos({\n            scripts: [base_1.hex.encode(this.offchainTapscript.pkScript)],\n        });\n        const { boardingTxs, commitmentsToIgnore } = await this.getBoardingTxs();\n        const spendableVtxos = [];\n        const spentVtxos = [];\n        for (const vtxo of response.vtxos) {\n            if ((0, _1.isSpendable)(vtxo)) {\n                spendableVtxos.push(vtxo);\n            }\n            else {\n                spentVtxos.push(vtxo);\n            }\n        }\n        // convert VTXOs to offchain transactions\n        const offchainTxs = (0, transactionHistory_1.vtxosToTxs)(spendableVtxos, spentVtxos, commitmentsToIgnore);\n        const txs = [...boardingTxs, ...offchainTxs];\n        // sort transactions by creation time in descending order (newest first)\n        txs.sort(\n        // place createdAt = 0 (unconfirmed txs) first, then descending\n        (a, b) => {\n            if (a.createdAt === 0)\n                return -1;\n            if (b.createdAt === 0)\n                return 1;\n            return b.createdAt - a.createdAt;\n        });\n        return txs;\n    }\n    async getBoardingTxs() {\n        const boardingAddress = await this.getBoardingAddress();\n        const txs = await this.onchainProvider.getTransactions(boardingAddress);\n        const utxos = [];\n        const commitmentsToIgnore = new Set();\n        for (const tx of txs) {\n            for (let i = 0; i < tx.vout.length; i++) {\n                const vout = tx.vout[i];\n                if (vout.scriptpubkey_address === boardingAddress) {\n                    const spentStatuses = await this.onchainProvider.getTxOutspends(tx.txid);\n                    const spentStatus = spentStatuses[i];\n                    if (spentStatus?.spent) {\n                        commitmentsToIgnore.add(spentStatus.txid);\n                    }\n                    utxos.push({\n                        txid: tx.txid,\n                        vout: i,\n                        value: Number(vout.value),\n                        status: {\n                            confirmed: tx.status.confirmed,\n                            block_time: tx.status.block_time,\n                        },\n                        isUnrolled: true,\n                        virtualStatus: {\n                            state: spentStatus?.spent ? "spent" : "settled",\n                            commitmentTxIds: spentStatus?.spent\n                                ? [spentStatus.txid]\n                                : undefined,\n                        },\n                        createdAt: tx.status.confirmed\n                            ? new Date(tx.status.block_time * 1000)\n                            : new Date(0),\n                    });\n                }\n            }\n        }\n        const unconfirmedTxs = [];\n        const confirmedTxs = [];\n        for (const utxo of utxos) {\n            const tx = {\n                key: {\n                    boardingTxid: utxo.txid,\n                    commitmentTxid: "",\n                    arkTxid: "",\n                },\n                amount: utxo.value,\n                type: _1.TxType.TxReceived,\n                settled: utxo.virtualStatus.state === "spent",\n                createdAt: utxo.status.block_time\n                    ? new Date(utxo.status.block_time * 1000).getTime()\n                    : 0,\n            };\n            if (!utxo.status.block_time) {\n                unconfirmedTxs.push(tx);\n            }\n            else {\n                confirmedTxs.push(tx);\n            }\n        }\n        return {\n            boardingTxs: [...unconfirmedTxs, ...confirmedTxs],\n            commitmentsToIgnore,\n        };\n    }\n    async getBoardingUtxos() {\n        const boardingAddress = await this.getBoardingAddress();\n        const boardingUtxos = await this.onchainProvider.getCoins(boardingAddress);\n        const encodedBoardingTapscript = this.boardingTapscript.encode();\n        const forfeit = this.boardingTapscript.forfeit();\n        const exit = this.boardingTapscript.exit();\n        return boardingUtxos.map((utxo) => ({\n            ...utxo,\n            forfeitTapLeafScript: forfeit,\n            intentTapLeafScript: exit,\n            tapTree: encodedBoardingTapscript,\n        }));\n    }\n    async sendBitcoin(params) {\n        if (params.amount <= 0) {\n            throw new Error("Amount must be positive");\n        }\n        if (!isValidArkAddress(params.address)) {\n            throw new Error("Invalid Ark address " + params.address);\n        }\n        // recoverable and subdust coins can\'t be spent in offchain tx\n        const virtualCoins = await this.getVirtualCoins({\n            withRecoverable: false,\n        });\n        const selected = selectVirtualCoins(virtualCoins, params.amount);\n        const selectedLeaf = this.offchainTapscript.forfeit();\n        if (!selectedLeaf) {\n            throw new Error("Selected leaf not found");\n        }\n        const outputAddress = address_1.ArkAddress.decode(params.address);\n        const outputScript = BigInt(params.amount) < this.dustAmount\n            ? outputAddress.subdustPkScript\n            : outputAddress.pkScript;\n        const outputs = [\n            {\n                script: outputScript,\n                amount: BigInt(params.amount),\n            },\n        ];\n        // add change output if needed\n        if (selected.changeAmount > 0n) {\n            const changeOutputScript = selected.changeAmount < this.dustAmount\n                ? this.arkAddress.subdustPkScript\n                : this.arkAddress.pkScript;\n            outputs.push({\n                script: changeOutputScript,\n                amount: BigInt(selected.changeAmount),\n            });\n        }\n        const tapTree = this.offchainTapscript.encode();\n        let offchainTx = (0, arkTransaction_1.buildOffchainTx)(selected.inputs.map((input) => ({\n            ...input,\n            tapLeafScript: selectedLeaf,\n            tapTree,\n        })), outputs, this.serverUnrollScript);\n        const signedVirtualTx = await this.identity.sign(offchainTx.arkTx);\n        const { arkTxid, signedCheckpointTxs } = await this.arkProvider.submitTx(base_1.base64.encode(signedVirtualTx.toPSBT()), offchainTx.checkpoints.map((c) => base_1.base64.encode(c.toPSBT())));\n        // TODO persist final virtual tx and checkpoints to repository\n        // sign the checkpoints\n        const finalCheckpoints = await Promise.all(signedCheckpointTxs.map(async (c) => {\n            const tx = btc_signer_1.Transaction.fromPSBT(base_1.base64.decode(c));\n            const signedCheckpoint = await this.identity.sign(tx);\n            return base_1.base64.encode(signedCheckpoint.toPSBT());\n        }));\n        await this.arkProvider.finalizeTx(arkTxid, finalCheckpoints);\n        return arkTxid;\n    }\n    async settle(params, eventCallback) {\n        if (params?.inputs) {\n            for (const input of params.inputs) {\n                // validate arknotes inputs\n                if (typeof input === "string") {\n                    try {\n                        arknote_1.ArkNote.fromString(input);\n                    }\n                    catch (e) {\n                        throw new Error(`Invalid arknote "${input}"`);\n                    }\n                }\n            }\n        }\n        // if no params are provided, use all boarding and offchain utxos as inputs\n        // and send all to the offchain address\n        if (!params) {\n            let amount = 0;\n            const boardingUtxos = await this.getBoardingUtxos();\n            amount += boardingUtxos.reduce((sum, input) => sum + input.value, 0);\n            const vtxos = await this.getVtxos();\n            amount += vtxos.reduce((sum, input) => sum + input.value, 0);\n            const inputs = [...boardingUtxos, ...vtxos];\n            if (inputs.length === 0) {\n                throw new Error("No inputs found");\n            }\n            params = {\n                inputs,\n                outputs: [\n                    {\n                        address: await this.getAddress(),\n                        amount: BigInt(amount),\n                    },\n                ],\n            };\n        }\n        const onchainOutputIndexes = [];\n        const outputs = [];\n        let hasOffchainOutputs = false;\n        for (const [index, output] of params.outputs.entries()) {\n            let script;\n            try {\n                // offchain\n                const addr = address_1.ArkAddress.decode(output.address);\n                script = addr.pkScript;\n                hasOffchainOutputs = true;\n            }\n            catch {\n                // onchain\n                const addr = (0, payment_1.Address)(this.network).decode(output.address);\n                script = payment_1.OutScript.encode(addr);\n                onchainOutputIndexes.push(index);\n            }\n            outputs.push({\n                amount: output.amount,\n                script,\n            });\n        }\n        // session holds the state of the musig2 signing process of the vtxo tree\n        let session;\n        const signingPublicKeys = [];\n        if (hasOffchainOutputs) {\n            session = this.identity.signerSession();\n            signingPublicKeys.push(base_1.hex.encode(session.getPublicKey()));\n        }\n        const [intent, deleteIntent] = await Promise.all([\n            this.makeRegisterIntentSignature(params.inputs, outputs, onchainOutputIndexes, signingPublicKeys),\n            this.makeDeleteIntentSignature(params.inputs),\n        ]);\n        const intentId = await this.arkProvider.registerIntent(intent);\n        const abortController = new AbortController();\n        // listen to settlement events\n        try {\n            let step;\n            const topics = [\n                ...signingPublicKeys,\n                ...params.inputs.map((input) => `${input.txid}:${input.vout}`),\n            ];\n            const settlementStream = this.arkProvider.getEventStream(abortController.signal, topics);\n            // roundId, sweepTapTreeRoot and forfeitOutputScript are set once the BatchStarted event is received\n            let roundId;\n            let sweepTapTreeRoot;\n            const vtxoChunks = [];\n            const connectorsChunks = [];\n            let vtxoGraph;\n            let connectorsGraph;\n            for await (const event of settlementStream) {\n                if (eventCallback) {\n                    eventCallback(event);\n                }\n                switch (event.type) {\n                    // the settlement failed\n                    case ark_1.SettlementEventType.BatchFailed:\n                        // fail if the roundId is the one joined\n                        if (event.id === roundId) {\n                            throw new Error(event.reason);\n                        }\n                        break;\n                    case ark_1.SettlementEventType.BatchStarted:\n                        if (step !== undefined) {\n                            continue;\n                        }\n                        const res = await this.handleBatchStartedEvent(event, intentId, this.arkServerPublicKey, this.forfeitOutputScript);\n                        if (!res.skip) {\n                            step = event.type;\n                            sweepTapTreeRoot = res.sweepTapTreeRoot;\n                            roundId = res.roundId;\n                            if (!hasOffchainOutputs) {\n                                // if there are no offchain outputs, we don\'t have to handle musig2 tree signatures\n                                // we can directly advance to the finalization step\n                                step = ark_1.SettlementEventType.TreeNoncesAggregated;\n                            }\n                        }\n                        break;\n                    case ark_1.SettlementEventType.TreeTx:\n                        if (step !== ark_1.SettlementEventType.BatchStarted &&\n                            step !== ark_1.SettlementEventType.TreeNoncesAggregated) {\n                            continue;\n                        }\n                        // index 0 = vtxo tree\n                        if (event.batchIndex === 0) {\n                            vtxoChunks.push(event.chunk);\n                            // index 1 = connectors tree\n                        }\n                        else if (event.batchIndex === 1) {\n                            connectorsChunks.push(event.chunk);\n                        }\n                        else {\n                            throw new Error(`Invalid batch index: ${event.batchIndex}`);\n                        }\n                        break;\n                    case ark_1.SettlementEventType.TreeSignature:\n                        if (step !== ark_1.SettlementEventType.TreeNoncesAggregated) {\n                            continue;\n                        }\n                        if (!hasOffchainOutputs) {\n                            continue;\n                        }\n                        if (!vtxoGraph) {\n                            throw new Error("Vtxo graph not set, something went wrong");\n                        }\n                        // index 0 = vtxo graph\n                        if (event.batchIndex === 0) {\n                            const tapKeySig = base_1.hex.decode(event.signature);\n                            vtxoGraph.update(event.txid, (tx) => {\n                                tx.updateInput(0, {\n                                    tapKeySig,\n                                });\n                            });\n                        }\n                        break;\n                    // the server has started the signing process of the vtxo tree transactions\n                    // the server expects the partial musig2 nonces for each tx\n                    case ark_1.SettlementEventType.TreeSigningStarted:\n                        if (step !== ark_1.SettlementEventType.BatchStarted) {\n                            continue;\n                        }\n                        if (hasOffchainOutputs) {\n                            if (!session) {\n                                throw new Error("Signing session not set");\n                            }\n                            if (!sweepTapTreeRoot) {\n                                throw new Error("Sweep tap tree root not set");\n                            }\n                            if (vtxoChunks.length === 0) {\n                                throw new Error("unsigned vtxo graph not received");\n                            }\n                            vtxoGraph = txTree_1.TxTree.create(vtxoChunks);\n                            await this.handleSettlementSigningEvent(event, sweepTapTreeRoot, session, vtxoGraph);\n                        }\n                        step = event.type;\n                        break;\n                    // the musig2 nonces of the vtxo tree transactions are generated\n                    // the server expects now the partial musig2 signatures\n                    case ark_1.SettlementEventType.TreeNoncesAggregated:\n                        if (step !== ark_1.SettlementEventType.TreeSigningStarted) {\n                            continue;\n                        }\n                        if (hasOffchainOutputs) {\n                            if (!session) {\n                                throw new Error("Signing session not set");\n                            }\n                            await this.handleSettlementSigningNoncesGeneratedEvent(event, session);\n                        }\n                        step = event.type;\n                        break;\n                    // the vtxo tree is signed, craft, sign and submit forfeit transactions\n                    // if any boarding utxos are involved, the settlement tx is also signed\n                    case ark_1.SettlementEventType.BatchFinalization:\n                        if (step !== ark_1.SettlementEventType.TreeNoncesAggregated) {\n                            continue;\n                        }\n                        if (!this.forfeitOutputScript) {\n                            throw new Error("Forfeit output script not set");\n                        }\n                        if (connectorsChunks.length > 0) {\n                            connectorsGraph = txTree_1.TxTree.create(connectorsChunks);\n                            (0, validation_1.validateConnectorsTxGraph)(event.commitmentTx, connectorsGraph);\n                        }\n                        await this.handleSettlementFinalizationEvent(event, params.inputs, this.forfeitOutputScript, connectorsGraph);\n                        step = event.type;\n                        break;\n                    // the settlement is done, last event to be received\n                    case ark_1.SettlementEventType.BatchFinalized:\n                        if (step !== ark_1.SettlementEventType.BatchFinalization) {\n                            continue;\n                        }\n                        abortController.abort();\n                        return event.commitmentTxid;\n                }\n            }\n        }\n        catch (error) {\n            // close the stream\n            abortController.abort();\n            try {\n                // delete the intent to not be stuck in the queue\n                await this.arkProvider.deleteIntent(deleteIntent);\n            }\n            catch { }\n            throw error;\n        }\n        throw new Error("Settlement failed");\n    }\n    async notifyIncomingFunds(eventCallback) {\n        const arkAddress = await this.getAddress();\n        const boardingAddress = await this.getBoardingAddress();\n        let onchainStopFunc;\n        let indexerStopFunc;\n        if (this.onchainProvider && boardingAddress) {\n            onchainStopFunc = await this.onchainProvider.watchAddresses([boardingAddress], (txs) => {\n                const coins = txs\n                    .map((tx) => {\n                    const vout = tx.vout.findIndex((v) => v.scriptpubkey_address === boardingAddress);\n                    if (vout === -1) {\n                        console.warn(`No vout found for address ${boardingAddress} in transaction ${tx.txid}`);\n                        return null;\n                    }\n                    return {\n                        txid: tx.txid,\n                        vout,\n                        value: Number(tx.vout[vout].value),\n                        status: tx.status,\n                    };\n                })\n                    .filter((coin) => coin !== null);\n                eventCallback({\n                    type: "utxo",\n                    coins,\n                });\n            });\n        }\n        if (this.indexerProvider && arkAddress) {\n            const offchainScript = this.offchainTapscript;\n            const subscriptionId = await this.indexerProvider.subscribeForScripts([\n                base_1.hex.encode(offchainScript.pkScript),\n            ]);\n            const abortController = new AbortController();\n            const subscription = this.indexerProvider.getSubscription(subscriptionId, abortController.signal);\n            indexerStopFunc = async () => {\n                abortController.abort();\n                await this.indexerProvider?.unsubscribeForScripts(subscriptionId);\n            };\n            // Handle subscription updates asynchronously without blocking\n            (async () => {\n                try {\n                    for await (const update of subscription) {\n                        if (update.newVtxos?.length > 0) {\n                            eventCallback({\n                                type: "vtxo",\n                                vtxos: update.newVtxos,\n                            });\n                        }\n                    }\n                }\n                catch (error) {\n                    console.error("Subscription error:", error);\n                }\n            })();\n        }\n        const stopFunc = () => {\n            onchainStopFunc?.();\n            indexerStopFunc?.();\n        };\n        return stopFunc;\n    }\n    async handleBatchStartedEvent(event, intentId, serverPubKey, forfeitOutputScript) {\n        const utf8IntentId = new TextEncoder().encode(intentId);\n        const intentIdHash = (0, utils_1.sha256)(utf8IntentId);\n        const intentIdHashStr = base_1.hex.encode(new Uint8Array(intentIdHash));\n        let skip = true;\n        // check if our intent ID hash matches any in the event\n        for (const idHash of event.intentIdHashes) {\n            if (idHash === intentIdHashStr) {\n                if (!this.arkProvider) {\n                    throw new Error("Ark provider not configured");\n                }\n                await this.arkProvider.confirmRegistration(intentId);\n                skip = false;\n            }\n        }\n        if (skip) {\n            return { skip };\n        }\n        const sweepTapscript = tapscript_1.CSVMultisigTapscript.encode({\n            timelock: {\n                value: event.batchExpiry,\n                type: event.batchExpiry >= 512n ? "seconds" : "blocks",\n            },\n            pubkeys: [serverPubKey],\n        }).script;\n        const sweepTapTreeRoot = (0, payment_1.tapLeafHash)(sweepTapscript);\n        return {\n            roundId: event.id,\n            sweepTapTreeRoot,\n            forfeitOutputScript,\n            skip: false,\n        };\n    }\n    // validates the vtxo tree, creates a signing session and generates the musig2 nonces\n    async handleSettlementSigningEvent(event, sweepTapTreeRoot, session, vtxoGraph) {\n        // validate the unsigned vtxo tree\n        const commitmentTx = btc_signer_1.Transaction.fromPSBT(base_1.base64.decode(event.unsignedCommitmentTx));\n        (0, validation_1.validateVtxoTxGraph)(vtxoGraph, commitmentTx, sweepTapTreeRoot);\n        // TODO check if our registered outputs are in the vtxo tree\n        const sharedOutput = commitmentTx.getOutput(0);\n        if (!sharedOutput?.amount) {\n            throw new Error("Shared output not found");\n        }\n        session.init(vtxoGraph, sweepTapTreeRoot, sharedOutput.amount);\n        await this.arkProvider.submitTreeNonces(event.id, base_1.hex.encode(session.getPublicKey()), session.getNonces());\n    }\n    async handleSettlementSigningNoncesGeneratedEvent(event, session) {\n        session.setAggregatedNonces(event.treeNonces);\n        const signatures = session.sign();\n        await this.arkProvider.submitTreeSignatures(event.id, base_1.hex.encode(session.getPublicKey()), signatures);\n    }\n    async handleSettlementFinalizationEvent(event, inputs, forfeitOutputScript, connectorsGraph) {\n        // the signed forfeits transactions to submit\n        const signedForfeits = [];\n        const vtxos = await this.getVirtualCoins();\n        let settlementPsbt = btc_signer_1.Transaction.fromPSBT(base_1.base64.decode(event.commitmentTx));\n        let hasBoardingUtxos = false;\n        let connectorIndex = 0;\n        const connectorsLeaves = connectorsGraph?.leaves() || [];\n        for (const input of inputs) {\n            // check if the input is an offchain "virtual" coin\n            const vtxo = vtxos.find((vtxo) => vtxo.txid === input.txid && vtxo.vout === input.vout);\n            // boarding utxo, we need to sign the settlement tx\n            if (!vtxo) {\n                hasBoardingUtxos = true;\n                const inputIndexes = [];\n                for (let i = 0; i < settlementPsbt.inputsLength; i++) {\n                    const settlementInput = settlementPsbt.getInput(i);\n                    if (!settlementInput.txid ||\n                        settlementInput.index === undefined) {\n                        throw new Error("The server returned incomplete data. No settlement input found in the PSBT");\n                    }\n                    const inputTxId = base_1.hex.encode(settlementInput.txid);\n                    if (inputTxId !== input.txid)\n                        continue;\n                    if (settlementInput.index !== input.vout)\n                        continue;\n                    // input found in the settlement tx, sign it\n                    settlementPsbt.updateInput(i, {\n                        tapLeafScript: [input.forfeitTapLeafScript],\n                    });\n                    inputIndexes.push(i);\n                }\n                settlementPsbt = await this.identity.sign(settlementPsbt, inputIndexes);\n                continue;\n            }\n            if ((0, _1.isRecoverable)(vtxo) || (0, _1.isSubdust)(vtxo, this.dustAmount)) {\n                // recoverable or subdust coin, we don\'t need to create a forfeit tx\n                continue;\n            }\n            if (connectorsLeaves.length === 0) {\n                throw new Error("connectors not received");\n            }\n            if (connectorIndex >= connectorsLeaves.length) {\n                throw new Error("not enough connectors received");\n            }\n            const connectorLeaf = connectorsLeaves[connectorIndex];\n            const connectorTxId = base_1.hex.encode((0, utils_1.sha256x2)(connectorLeaf.toBytes(true)).reverse());\n            const connectorOutput = connectorLeaf.getOutput(0);\n            if (!connectorOutput) {\n                throw new Error("connector output not found");\n            }\n            const connectorAmount = connectorOutput.amount;\n            const connectorPkScript = connectorOutput.script;\n            if (!connectorAmount || !connectorPkScript) {\n                throw new Error("invalid connector output");\n            }\n            connectorIndex++;\n            let forfeitTx = (0, forfeit_1.buildForfeitTx)([\n                {\n                    txid: input.txid,\n                    index: input.vout,\n                    witnessUtxo: {\n                        amount: BigInt(vtxo.value),\n                        script: base_2.VtxoScript.decode(input.tapTree).pkScript,\n                    },\n                    sighashType: btc_signer_1.SigHash.DEFAULT,\n                    tapLeafScript: [input.forfeitTapLeafScript],\n                },\n                {\n                    txid: connectorTxId,\n                    index: 0,\n                    witnessUtxo: {\n                        amount: connectorAmount,\n                        script: connectorPkScript,\n                    },\n                },\n            ], forfeitOutputScript);\n            // do not sign the connector input\n            forfeitTx = await this.identity.sign(forfeitTx, [0]);\n            signedForfeits.push(base_1.base64.encode(forfeitTx.toPSBT()));\n        }\n        if (signedForfeits.length > 0 || hasBoardingUtxos) {\n            await this.arkProvider.submitSignedForfeitTxs(signedForfeits, hasBoardingUtxos\n                ? base_1.base64.encode(settlementPsbt.toPSBT())\n                : undefined);\n        }\n    }\n    async makeRegisterIntentSignature(bip322Inputs, outputs, onchainOutputsIndexes, cosignerPubKeys) {\n        const nowSeconds = Math.floor(Date.now() / 1000);\n        const { inputs, inputTapTrees, finalizer } = this.prepareBIP322Inputs(bip322Inputs);\n        const message = {\n            type: "register",\n            input_tap_trees: inputTapTrees,\n            onchain_output_indexes: onchainOutputsIndexes,\n            valid_at: nowSeconds,\n            expire_at: nowSeconds + 2 * 60, // valid for 2 minutes\n            cosigners_public_keys: cosignerPubKeys,\n        };\n        const encodedMessage = JSON.stringify(message, null, 0);\n        const signature = await this.makeBIP322Signature(encodedMessage, inputs, finalizer, outputs);\n        return {\n            signature,\n            message: encodedMessage,\n        };\n    }\n    async makeDeleteIntentSignature(bip322Inputs) {\n        const nowSeconds = Math.floor(Date.now() / 1000);\n        const { inputs, finalizer } = this.prepareBIP322Inputs(bip322Inputs);\n        const message = {\n            type: "delete",\n            expire_at: nowSeconds + 2 * 60, // valid for 2 minutes\n        };\n        const encodedMessage = JSON.stringify(message, null, 0);\n        const signature = await this.makeBIP322Signature(encodedMessage, inputs, finalizer);\n        return {\n            signature,\n            message: encodedMessage,\n        };\n    }\n    prepareBIP322Inputs(bip322Inputs) {\n        const inputs = [];\n        const inputTapTrees = [];\n        const inputExtraWitnesses = [];\n        for (const bip322Input of bip322Inputs) {\n            const vtxoScript = base_2.VtxoScript.decode(bip322Input.tapTree);\n            const sequence = getSequence(bip322Input);\n            inputs.push({\n                txid: base_1.hex.decode(bip322Input.txid),\n                index: bip322Input.vout,\n                witnessUtxo: {\n                    amount: BigInt(bip322Input.value),\n                    script: vtxoScript.pkScript,\n                },\n                sequence,\n                tapLeafScript: [bip322Input.intentTapLeafScript],\n            });\n            inputTapTrees.push(base_1.hex.encode(bip322Input.tapTree));\n            inputExtraWitnesses.push(bip322Input.extraWitness || []);\n        }\n        return {\n            inputs,\n            inputTapTrees,\n            finalizer: finalizeWithExtraWitnesses(inputExtraWitnesses),\n        };\n    }\n    async makeBIP322Signature(message, inputs, finalizer, outputs) {\n        const proof = bip322_1.BIP322.create(message, inputs, outputs);\n        const signedProof = await this.identity.sign(proof);\n        return bip322_1.BIP322.signature(signedProof, finalizer);\n    }\n}\nexports.Wallet = Wallet;\nWallet.MIN_FEE_RATE = 1; // sats/vbyte\nfunction finalizeWithExtraWitnesses(inputExtraWitnesses) {\n    return function (tx) {\n        for (let i = 0; i < tx.inputsLength; i++) {\n            try {\n                tx.finalizeIdx(i);\n            }\n            catch (e) {\n                // handle empty witness error\n                if (e instanceof Error &&\n                    e.message.includes("finalize/taproot: empty witness")) {\n                    const tapLeaves = tx.getInput(i).tapLeafScript;\n                    if (!tapLeaves || tapLeaves.length <= 0)\n                        throw e;\n                    const [cb, s] = tapLeaves[0];\n                    const script = s.slice(0, -1);\n                    tx.updateInput(i, {\n                        finalScriptWitness: [\n                            script,\n                            psbt_1.TaprootControlBlock.encode(cb),\n                        ],\n                    });\n                }\n            }\n            const finalScriptWitness = tx.getInput(i).finalScriptWitness;\n            if (!finalScriptWitness)\n                throw new Error("input not finalized");\n            // input 0 and 1 spend the same pkscript\n            const extra = inputExtraWitnesses[i === 0 ? 0 : i - 1];\n            if (extra && extra.length > 0) {\n                tx.updateInput(i, {\n                    finalScriptWitness: [...extra, ...finalScriptWitness],\n                });\n            }\n        }\n    };\n}\nfunction getSequence(bip322Input) {\n    let sequence = undefined;\n    try {\n        const scriptWithLeafVersion = bip322Input.intentTapLeafScript[1];\n        const script = scriptWithLeafVersion.subarray(0, scriptWithLeafVersion.length - 1);\n        const params = tapscript_1.CSVMultisigTapscript.decode(script).params;\n        sequence = bip68.encode(params.timelock.type === "blocks"\n            ? { blocks: Number(params.timelock.value) }\n            : { seconds: Number(params.timelock.value) });\n    }\n    catch { }\n    return sequence;\n}\nfunction isValidArkAddress(address) {\n    try {\n        address_1.ArkAddress.decode(address);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * Select virtual coins to reach a target amount, prioritizing those closer to expiry\n * @param coins List of virtual coins to select from\n * @param targetAmount Target amount to reach in satoshis\n * @returns Selected coins and change amount\n */\nfunction selectVirtualCoins(coins, targetAmount) {\n    // Sort VTXOs by expiry (ascending) and amount (descending)\n    const sortedCoins = [...coins].sort((a, b) => {\n        // First sort by expiry if available\n        const expiryA = a.virtualStatus.batchExpiry || Number.MAX_SAFE_INTEGER;\n        const expiryB = b.virtualStatus.batchExpiry || Number.MAX_SAFE_INTEGER;\n        if (expiryA !== expiryB) {\n            return expiryA - expiryB; // Earlier expiry first\n        }\n        // Then sort by amount\n        return b.value - a.value; // Larger amount first\n    });\n    const selectedCoins = [];\n    let selectedAmount = 0;\n    // Select coins until we have enough\n    for (const coin of sortedCoins) {\n        selectedCoins.push(coin);\n        selectedAmount += coin.value;\n        if (selectedAmount >= targetAmount) {\n            break;\n        }\n    }\n    if (selectedAmount === targetAmount) {\n        return { inputs: selectedCoins, changeAmount: 0n };\n    }\n    // Check if we have enough\n    if (selectedAmount < targetAmount) {\n        throw new Error("Insufficient funds");\n    }\n    const changeAmount = BigInt(selectedAmount - targetAmount);\n    return {\n        inputs: selectedCoins,\n        changeAmount,\n    };\n}\n/**\n * Wait for incoming funds to the wallet\n * @param wallet - The wallet to wait for incoming funds\n * @returns A promise that resolves the next new coins received by the wallet\'s address\n */\nasync function waitForIncomingFunds(wallet) {\n    let stopFunc;\n    const promise = new Promise((resolve) => {\n        wallet\n            .notifyIncomingFunds((coins) => {\n            resolve(coins);\n            if (stopFunc)\n                stopFunc();\n        })\n            .then((stop) => {\n            stopFunc = stop;\n        });\n    });\n    return promise;\n}\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@arkade-os/sdk/dist/cjs/wallet/wallet.js?\n}')},"./node_modules/@noble/curves/_shortw_utils.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.getHash = getHash;\nexports.createCurve = createCurve;\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ "./node_modules/@noble/hashes/hmac.js");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ "./node_modules/@noble/hashes/utils.js");\nconst weierstrass_ts_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ "./node_modules/@noble/curves/abstract/weierstrass.js");\n/** connects noble-curves to noble-hashes */\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),\n        randomBytes: utils_1.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return { ...create(defHash), create };\n}\n//# sourceMappingURL=_shortw_utils.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@noble/curves/_shortw_utils.js?\n}')},"./node_modules/@noble/curves/abstract/curve.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wNAF = wNAF;\nexports.pippenger = pippenger;\nexports.precomputeMSMUnsafe = precomputeMSMUnsafe;\nexports.validateBasic = validateBasic;\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst modular_ts_1 = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/abstract/modular.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/abstract/utils.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = (0, utils_ts_1.bitMask)(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return { windows, windowSize, mask, maxNumber, shiftBy };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nfunction wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes(elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n, p = c.ZERO) {\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // i=1, bc we skip 0\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // Smaller version:\n            // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n            // TODO: check the scalar is less than group order?\n            // wNAF behavior is undefined otherwise. But have to carefully remove\n            // other checks before wNAF. ORDER == bits here.\n            // Accumulators\n            let p = c.ZERO;\n            let f = c.BASE;\n            // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n            // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n            // there is negate now: it is possible that negated element from low value\n            // would be the same as high element, which will create carry into next window.\n            // It's not obvious how this can fail, but still worth investigating later.\n            const wo = calcWOpts(W, bits);\n            for (let window = 0; window < wo.windows; window++) {\n                // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n                const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // bits are 0: add garbage to fake point\n                    // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                    f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));\n                }\n                else {\n                    // bits are 1: add to result point\n                    p = p.add(constTimeNegate(isNeg, precomputes[offset]));\n                }\n            }\n            // Return both real and fake points: JIT won't eliminate f.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */\n        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\n            const wo = calcWOpts(W, bits);\n            for (let window = 0; window < wo.windows; window++) {\n                if (n === _0n)\n                    break; // Early-exit, skip 0 value\n                const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // Window bits are 0: skip processing.\n                    // Move to next window.\n                    continue;\n                }\n                else {\n                    const item = precomputes[offset];\n                    acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n                }\n            }\n            return acc;\n        },\n        getPrecomputes(W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1)\n                    pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached(P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe(P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1)\n                return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize(P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        },\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nfunction pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength)\n        throw new Error('arrays of points and scalars must have equal length');\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12)\n        windowSize = wbits - 3;\n    else if (wbits > 4)\n        windowSize = wbits - 2;\n    else if (wbits > 0)\n        windowSize = 2;\n    const MASK = (0, utils_ts_1.bitMask)(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < slength; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nfunction precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar  256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255  32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16  255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = (0, utils_ts_1.bitMask)(windowSize);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction validateBasic(curve) {\n    (0, modular_ts_1.validateField)(curve.Fp);\n    (0, utils_ts_1.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@noble/curves/abstract/curve.js?\n}")},"./node_modules/@noble/curves/abstract/hash-to-curve.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.expand_message_xmd = expand_message_xmd;\nexports.expand_message_xof = expand_message_xof;\nexports.hash_to_field = hash_to_field;\nexports.isogenyMap = isogenyMap;\nexports.createHasher = createHasher;\nconst modular_ts_1 = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/abstract/modular.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/abstract/utils.js\");\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = utils_ts_1.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << (8 * length))\n        throw new Error('invalid I2OSP input: ' + value);\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0, utils_ts_1.abytes)(msg);\n    (0, utils_ts_1.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255)\n        throw new Error('expand_message_xmd: invalid lenInBytes');\n    const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0, utils_ts_1.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0, utils_ts_1.abytes)(msg);\n    (0, utils_ts_1.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0, utils_ts_1.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0, utils_ts_1.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? (0, utils_ts_1.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const coeff = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        // 6.6.3\n        // Exceptional cases of iso_map are inputs that cause the denominator of\n        // either rational function to evaluate to zero; such cases MUST return\n        // the identity point on E.\n        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);\n        x = field.mul(xn, xd_inv); // xNum / xDen\n        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. */\nfunction createHasher(Point, mapToCurve, defaults) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    function map(num) {\n        return Point.fromAffine(mapToCurve(num));\n    }\n    function clear(initial) {\n        const P = initial.clearCofactor();\n        if (P.equals(Point.ZERO))\n            return Point.ZERO; // zero will throw in assert\n        P.assertValidity();\n        return P;\n    }\n    return {\n        defaults,\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...defaults, DST: defaults.DST, ...options });\n            const u0 = map(u[0]);\n            const u1 = map(u[1]);\n            return clear(u0.add(u1));\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...defaults, DST: defaults.encodeDST, ...options });\n            return clear(map(u[0]));\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve(scalars) {\n            if (!Array.isArray(scalars))\n                throw new Error('expected array of bigints');\n            for (const i of scalars)\n                if (typeof i !== 'bigint')\n                    throw new Error('expected array of bigints');\n            return clear(map(scalars));\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@noble/curves/abstract/hash-to-curve.js?\n}")},"./node_modules/@noble/curves/abstract/modular.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isNegativeLE = void 0;\nexports.mod = mod;\nexports.pow = pow;\nexports.pow2 = pow2;\nexports.invert = invert;\nexports.tonelliShanks = tonelliShanks;\nexports.FpSqrt = FpSqrt;\nexports.validateField = validateField;\nexports.FpPow = FpPow;\nexports.FpInvertBatch = FpInvertBatch;\nexports.FpDiv = FpDiv;\nexports.FpLegendre = FpLegendre;\nexports.FpIsSquare = FpIsSquare;\nexports.nLength = nLength;\nexports.Field = Field;\nexports.FpSqrtOdd = FpSqrtOdd;\nexports.FpSqrtEven = FpSqrtEven;\nexports.hashToPrivateScalar = hashToPrivateScalar;\nexports.getFieldBytesLength = getFieldBytesLength;\nexports.getMinHashLength = getMinHashLength;\nexports.mapHashToField = mapHashToField;\n/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/@noble/hashes/utils.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/abstract/utils.js\");\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * TODO: remove.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nfunction pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nfunction invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    // Throw if root^2 != n\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n    return root;\n}\n// TODO: Commented-out for now. Provide test vectors.\n// Tonelli is too slow for extension fields Fp2.\n// That means we can't use sqrt (c1, c2...) even for initialization constants.\n// if (P % _16n === _9n) return sqrt9mod16;\n// // prettier-ignore\n// function sqrt9mod16<T>(Fp: IField<T>, n: T, p7div16?: bigint) {\n//   if (p7div16 === undefined) p7div16 = (Fp.ORDER + BigInt(7)) / _16n;\n//   const c1 = Fp.sqrt(Fp.neg(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n//   const c2 = Fp.sqrt(c1);             //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n//   const c3 = Fp.sqrt(Fp.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n//   const c4 = p7div16;                 //  4. c4 = (q + 7) / 16        # Integer arithmetic\n//   let tv1 = Fp.pow(n, c4);            //  1. tv1 = x^c4\n//   let tv2 = Fp.mul(c1, tv1);          //  2. tv2 = c1 * tv1\n//   const tv3 = Fp.mul(c2, tv1);        //  3. tv3 = c2 * tv1\n//   let tv4 = Fp.mul(c3, tv1);          //  4. tv4 = c3 * tv1\n//   const e1 = Fp.eql(Fp.sqr(tv2), n);  //  5.  e1 = (tv2^2) == x\n//   const e2 = Fp.eql(Fp.sqr(tv3), n);  //  6.  e2 = (tv3^2) == x\n//   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n//   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n//   const e3 = Fp.eql(Fp.sqr(tv2), n);  //  9.  e3 = (tv2^2) == x\n//   return Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3) # Select the sqrt from tv1 and tv2\n// }\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Initialization (precomputation).\n    if (P < BigInt(3))\n        throw new Error('sqrt is not defined for small field');\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while (Q % _2n === _0n) {\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while (FpLegendre(_Fp, Z) === 1) {\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000)\n            throw new Error('Cannot find square root: probably non-prime P');\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1)\n        return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n))\n            return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1)\n            throw new Error('Cannot find square root');\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while (!Fp.eql(t, Fp.ONE)) {\n            if (Fp.is0(t))\n                return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while (!Fp.eql(t_tmp, Fp.ONE)) {\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M)\n                    throw new Error('Cannot find square root');\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P  3 (mod 4)\n * 2. P  5 (mod 8)\n * 3. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nfunction FpSqrt(P) {\n    // P  3 (mod 4) => n = n^((P+1)/4)\n    if (P % _4n === _3n)\n        return sqrt3mod4;\n    // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n)\n        return sqrt5mod8;\n    // P  9 (mod 16) not implemented, see above\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\nexports.isNegativeLE = isNegativeLE;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0, utils_ts_1.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(Fp, num, power) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return Fp.ONE;\n    if (power === _1n)\n        return num;\n    let p = Fp.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nfunction FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nfunction FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p)  1    if a is a square (mod p), quadratic residue\n * * (a | p)  -1   if a is not a square (mod p), quadratic non residue\n * * (a | p)  0    if a  0 (mod p)\n */\nfunction FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no)\n        throw new Error('invalid Legendre symbol result');\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined)\n        (0, utils_1.anumber)(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0, utils_ts_1.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        toBytes: (num) => (isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            return isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c) => (c ? b : a),\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0, utils_ts_1.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash) : (0, utils_ts_1.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@noble/curves/abstract/modular.js?\n}")},"./node_modules/@noble/curves/abstract/utils.js":(__unused_webpack_module,exports)=>{"use strict";eval("{\n/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.notImplemented = exports.bitMask = void 0;\nexports.isBytes = isBytes;\nexports.abytes = abytes;\nexports.abool = abool;\nexports.numberToHexUnpadded = numberToHexUnpadded;\nexports.hexToNumber = hexToNumber;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.bytesToNumberBE = bytesToNumberBE;\nexports.bytesToNumberLE = bytesToNumberLE;\nexports.numberToBytesBE = numberToBytesBE;\nexports.numberToBytesLE = numberToBytesLE;\nexports.numberToVarBytesBE = numberToVarBytesBE;\nexports.ensureBytes = ensureBytes;\nexports.concatBytes = concatBytes;\nexports.equalBytes = equalBytes;\nexports.utf8ToBytes = utf8ToBytes;\nexports.inRange = inRange;\nexports.aInRange = aInRange;\nexports.bitLen = bitLen;\nexports.bitGet = bitGet;\nexports.bitSet = bitSet;\nexports.createHmacDrbg = createHmacDrbg;\nexports.validateObject = validateObject;\nexports.memoized = memoized;\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\nfunction abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function';\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nfunction aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_1n << BigInt(n)) - _1n;\nexports.bitMask = bitMask;\n// DRBG\nconst u8n = (len) => new Uint8Array(len); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0)) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */\nconst notImplemented = () => {\n    throw new Error('not implemented');\n};\nexports.notImplemented = notImplemented;\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nfunction memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@noble/curves/abstract/utils.js?\n}")},"./node_modules/@noble/curves/abstract/weierstrass.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DER = exports.DERErr = void 0;\nexports.weierstrassPoints = weierstrassPoints;\nexports.weierstrass = weierstrass;\nexports.SWUFpSqrtRatio = SWUFpSqrtRatio;\nexports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;\n/**\n * Short Weierstrass curve methods. The formula is: y = x + ax + b.\n *\n * ### Parameters\n *\n * To initialize a weierstrass curve, one needs to pass following params:\n *\n * * a: formula param\n * * b: formula param\n * * Fp: finite field of prime characteristic P; may be complex (Fp2). Arithmetics is done in field\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * Gx: Base point (x, y) aka generator point. Gx = x coordinate\n * * Gy: ...y coordinate\n * * h: cofactor, usually 1. h*n = curve group order (n is only subgroup order)\n * * lowS: whether to enable (default) or disable \"low-s\" non-malleable signatures\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// prettier-ignore\nconst curve_ts_1 = __webpack_require__(/*! ./curve.js */ \"./node_modules/@noble/curves/abstract/curve.js\");\n// prettier-ignore\nconst modular_ts_1 = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/abstract/modular.js\");\n// prettier-ignore\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/abstract/utils.js\");\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined)\n        (0, utils_ts_1.abool)('lowS', opts.lowS);\n    if (opts.prehash !== undefined)\n        (0, utils_ts_1.abool)('prehash', opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = (0, curve_ts_1.validateBasic)(curve);\n    (0, utils_ts_1.validateObject)(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowInfinityPoint: 'boolean',\n        allowedPrivateKeyLengths: 'array',\n        clearCofactor: 'function',\n        fromBytes: 'function',\n        isTorsionFree: 'function',\n        toBytes: 'function',\n        wrapPrivateKey: 'boolean',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('invalid endo: CURVE.a must be 0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"splitScalar\": function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\nclass DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\nexports.DERErr = DERErr;\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexports.DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = exports.DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)((len.length / 2) | 128) : '';\n            const t = (0, utils_ts_1.numberToHexUnpadded)(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = exports.DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = exports.DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = (0, utils_ts_1.numberToHexUnpadded)(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = exports.DER;\n            if (data[0] & 128)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return (0, utils_ts_1.bytesToNumberBE)(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = exports.DER;\n        const data = (0, utils_ts_1.ensureBytes)('signature', hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = exports.DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\nfunction numToSizedHex(num, size) {\n    return (0, utils_ts_1.bytesToHex)((0, utils_ts_1.numberToBytesBE)(num, size));\n}\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = (0, modular_ts_1.Field)(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return (0, utils_ts_1.concatBytes)(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula. Takes x, returns y.\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x + a * x + b\n    }\n    function isValidXY(x, y) {\n        const left = Fp.sqr(y); // y\n        const right = weierstrassEquation(x); // x + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation y = x + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy))\n        throw new Error('bad curve params: generator point');\n    // Test 2: discriminant  part should be non-zero: 4a + 27b != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2)))\n        throw new Error('bad curve params: a or b');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return (0, utils_ts_1.inRange)(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if ((0, utils_ts_1.isBytes)(key))\n                key = (0, utils_ts_1.bytesToHex)(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('invalid private key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : (0, utils_ts_1.bytesToNumberBE)((0, utils_ts_1.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error('invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key);\n        }\n        if (wrapPrivateKey)\n            num = (0, modular_ts_1.mod)(num, N); // disabled by default, enabled for BLS\n        (0, utils_ts_1.aInRange)('private key', num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z)  (x=X/Z, y=Y/Z)\n    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE))\n            return { x, y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0, utils_ts_1.memoized)((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not FE');\n        if (!isValidXY(x, y))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (X, Y, Z)  (x=X/Z, y=Y/Z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py) || Fp.is0(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = (0, modular_ts_1.FpInvertBatch)(Fp, points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0, utils_ts_1.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            (0, utils_ts_1.aInRange)('scalar', sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n)\n                return I;\n            if (this.is0() || sc === _1n)\n                return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this))\n                return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            /** See docs for {@link EndomorphismOpts} */\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            (0, utils_ts_1.aInRange)('scalar', scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            /** See docs for {@link EndomorphismOpts} */\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            (0, utils_ts_1.abool)('isCompressed', isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            (0, utils_ts_1.abool)('isCompressed', isCompressed);\n            return (0, utils_ts_1.bytesToHex)(this.toRawBytes(isCompressed));\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    const { endo, nBitLength } = CURVE;\n    const wnaf = (0, curve_ts_1.wNAF)(Point, endo ? Math.ceil(nBitLength / 2) : nBitLength);\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0, curve_ts_1.validateBasic)(curve);\n    (0, utils_ts_1.validateObject)(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, nByteLength, nBitLength } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return (0, modular_ts_1.mod)(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return (0, modular_ts_1.invert)(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = utils_ts_1.concatBytes;\n            (0, utils_ts_1.abool)('isCompressed', isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = (0, utils_ts_1.bytesToNumberBE)(tail);\n                if (!(0, utils_ts_1.inRange)(x, _1n, Fp.ORDER))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error('invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len);\n            }\n        },\n    });\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => (0, utils_ts_1.bytesToNumberBE)(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            (0, utils_ts_1.aInRange)('r', r, _1n, CURVE_ORDER); // r in [1..N]\n            (0, utils_ts_1.aInRange)('s', s, _1n, CURVE_ORDER); // s in [1..N]\n            this.r = r;\n            this.s = s;\n            if (recovery != null)\n                this.recovery = recovery;\n            Object.freeze(this);\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = nByteLength;\n            hex = (0, utils_ts_1.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = exports.DER.toSig((0, utils_ts_1.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        /**\n         * @todo remove\n         * @deprecated\n         */\n        assertValidity() { }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0, utils_ts_1.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToSizedHex(radj, Fp.BYTES));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return (0, utils_ts_1.hexToBytes)(this.toDERHex());\n        }\n        toDERHex() {\n            return exports.DER.hexFromSig(this);\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return (0, utils_ts_1.hexToBytes)(this.toCompactHex());\n        }\n        toCompactHex() {\n            const l = nByteLength;\n            return numToSizedHex(this.r, l) + numToSizedHex(this.s, l);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = (0, modular_ts_1.getMinHashLength)(CURVE.n);\n            return (0, modular_ts_1.mapHashToField)(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        if (typeof item === 'bigint')\n            return false;\n        if (item instanceof Point)\n            return true;\n        const arr = (0, utils_ts_1.ensureBytes)('key', item);\n        const len = arr.length;\n        const fpl = Fp.BYTES;\n        const compLen = fpl + 1; // e.g. 33 for 32\n        const uncompLen = 2 * fpl + 1; // e.g. 65 for 32\n        if (CURVE.allowedPrivateKeyLengths || nByteLength === compLen) {\n            return undefined;\n        }\n        else {\n            return len === compLen || len === uncompLen;\n        }\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA) === true)\n            throw new Error('first arg must be private key');\n        if (isProbPub(publicB) === false)\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // Our custom check \"just in case\", for protection against DoS\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = (0, utils_ts_1.bytesToNumberBE)(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = (0, utils_ts_1.bitMask)(nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        (0, utils_ts_1.aInRange)('num < 2^' + nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return (0, utils_ts_1.numberToBytesBE)(num, nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0, utils_ts_1.ensureBytes)('msgHash', msgHash);\n        validateSigVerOpts(opts);\n        if (prehash)\n            msgHash = (0, utils_ts_1.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0, utils_ts_1.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = (0, utils_ts_1.concatBytes)(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = (0, utils_ts_1.createHmacDrbg)(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0, utils_ts_1.ensureBytes)('msgHash', msgHash);\n        publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        if (format !== undefined && format !== 'compact' && format !== 'der')\n            throw new Error('format must be compact or der');\n        const isHex = typeof sg === 'string' || (0, utils_ts_1.isBytes)(sg);\n        const isObj = !isHex &&\n            !format &&\n            typeof sg === 'object' &&\n            sg !== null &&\n            typeof sg.r === 'bigint' &&\n            typeof sg.s === 'bigint';\n        if (!isHex && !isObj)\n            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj)\n                _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== 'compact')\n                        _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof exports.DER.Err))\n                        throw derError;\n                }\n                if (!_sig && format !== 'der')\n                    _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n        if (!_sig)\n            return false;\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    (0, modular_ts_1.validateField)(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@noble/curves/abstract/weierstrass.js?\n}")},"./node_modules/@noble/curves/secp256k1.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;\n/**\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Seems to be rigid (not backdoored)\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n *\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst sha2_1 = __webpack_require__(/*! @noble/hashes/sha2 */ \"./node_modules/@noble/hashes/sha2.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/@noble/hashes/utils.js\");\nconst _shortw_utils_ts_1 = __webpack_require__(/*! ./_shortw_utils.js */ \"./node_modules/@noble/curves/_shortw_utils.js\");\nconst hash_to_curve_ts_1 = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"./node_modules/@noble/curves/abstract/hash-to-curve.js\");\nconst modular_ts_1 = __webpack_require__(/*! ./abstract/modular.js */ \"./node_modules/@noble/curves/abstract/modular.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./abstract/utils.js */ \"./node_modules/@noble/curves/abstract/utils.js\");\nconst weierstrass_ts_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ \"./node_modules/@noble/curves/abstract/weierstrass.js\");\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0, modular_ts_1.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0, modular_ts_1.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0, modular_ts_1.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0, modular_ts_1.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0, modular_ts_1.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0, modular_ts_1.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0, modular_ts_1.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0, modular_ts_1.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0, modular_ts_1.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0, modular_ts_1.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0, modular_ts_1.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0, modular_ts_1.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fpk1 = (0, modular_ts_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const priv = secp256k1.utils.randomPrivateKey();\n * const pub = secp256k1.getPublicKey(priv);\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\n * ```\n */\nexports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({\n    a: _0n,\n    b: BigInt(7),\n    Fp: Fpk1,\n    n: secp256k1N,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    endo: {\n        // Endomorphism, see above\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0, modular_ts_1.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0, modular_ts_1.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha2_1.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0, sha2_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0, sha2_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0, utils_ts_1.numberToBytesBE)(n, 32);\nconst modP = (x) => (0, modular_ts_1.mod)(x, secp256k1P);\nconst modN = (x) => (0, modular_ts_1.mod)(x, secp256k1N);\nconst Point = /* @__PURE__ */ (() => exports.secp256k1.ProjectivePoint)();\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    (0, utils_ts_1.aInRange)('x', x, _1n, secp256k1P); // Fail if x  p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = utils_ts_1.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN(num(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {\n    const m = (0, utils_ts_1.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0, utils_ts_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0, utils_ts_1.ensureBytes)('signature', signature, 64);\n    const m = (0, utils_ts_1.ensureBytes)('message', message);\n    const pub = (0, utils_ts_1.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!(0, utils_ts_1.inRange)(r, _1n, secp256k1P))\n            return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!(0, utils_ts_1.inRange)(s, _1n, secp256k1N))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const priv = schnorr.utils.randomPrivateKey();\n * const pub = schnorr.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, priv);\n * const isValid = schnorr.verify(sig, msg, pub);\n * ```\n */\nexports.schnorr = (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: utils_ts_1.numberToBytesBE,\n        bytesToNumberBE: utils_ts_1.bytesToNumberBE,\n        taggedHash,\n        mod: modular_ts_1.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n}))();\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */\nexports.secp256k1_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fpk1.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha2_1.sha256,\n}))();\nexports.hashToCurve = (() => exports.secp256k1_hasher.hashToCurve)();\nexports.encodeToCurve = (() => exports.secp256k1_hasher.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@noble/curves/secp256k1.js?\n}")},"./node_modules/@noble/hashes/_md.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;\nexports.setBigUint64 = setBigUint64;\nexports.Chi = Chi;\nexports.Maj = Maj;\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/utils.js\");\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nfunction Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nfunction Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends utils_ts_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_ts_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, utils_ts_1.aexists)(this);\n        data = (0, utils_ts_1.toBytes)(data);\n        (0, utils_ts_1.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_ts_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aexists)(this);\n        (0, utils_ts_1.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        (0, utils_ts_1.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_ts_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.HashMD = HashMD;\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexports.SHA256_IV = Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexports.SHA224_IV = Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexports.SHA384_IV = Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexports.SHA512_IV = Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@noble/hashes/_md.js?\n}")},"./node_modules/@noble/hashes/_u64.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;\nexports.add = add;\nexports.fromBig = fromBig;\nexports.split = split;\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nexports.shrSH = shrSH;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.shrSL = shrSL;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nexports.rotrSH = rotrSH;\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.rotrSL = rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nexports.rotrBH = rotrBH;\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\nexports.rotrBL = rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nexports.rotr32H = rotr32H;\nconst rotr32L = (h, _l) => h;\nexports.rotr32L = rotr32L;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nexports.rotlSH = rotlSH;\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\nexports.rotlSL = rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nexports.rotlBH = rotlBH;\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\nexports.rotlBL = rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexports.add3L = add3L;\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nexports.add3H = add3H;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexports.add4L = add4L;\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nexports.add4H = add4H;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexports.add5L = add5L;\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\nexports.add5H = add5H;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexports["default"] = u64;\n//# sourceMappingURL=_u64.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@noble/hashes/_u64.js?\n}')},"./node_modules/@noble/hashes/crypto.js":(__unused_webpack_module,exports)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.crypto = void 0;\nexports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@noble/hashes/crypto.js?\n}")},"./node_modules/@noble/hashes/hmac.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hmac = exports.HMAC = void 0;\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/utils.js\");\nclass HMAC extends utils_ts_1.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0, utils_ts_1.ahash)(hash);\n        const key = (0, utils_ts_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        (0, utils_ts_1.clean)(pad);\n    }\n    update(buf) {\n        (0, utils_ts_1.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aexists)(this);\n        (0, utils_ts_1.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@noble/hashes/hmac.js?\n}")},"./node_modules/@noble/hashes/legacy.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ripemd160 = exports.RIPEMD160 = exports.md5 = exports.MD5 = exports.sha1 = exports.SHA1 = void 0;\n/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon\'t use them in a new protocol. What "weak" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\nconst _md_ts_1 = __webpack_require__(/*! ./_md.js */ "./node_modules/@noble/hashes/_md.js");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/utils.js");\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n/** SHA1 legacy hash class. */\nclass SHA1 extends _md_ts_1.HashMD {\n    constructor() {\n        super(64, 20, 8, false);\n        this.A = SHA1_IV[0] | 0;\n        this.B = SHA1_IV[1] | 0;\n        this.C = SHA1_IV[2] | 0;\n        this.D = SHA1_IV[3] | 0;\n        this.E = SHA1_IV[4] | 0;\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [A, B, C, D, E];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA1_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 80; i++)\n            SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for (let i = 0; i < 80; i++) {\n            let F, K;\n            if (i < 20) {\n                F = (0, _md_ts_1.Chi)(B, C, D);\n                K = 0x5a827999;\n            }\n            else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            }\n            else if (i < 60) {\n                F = (0, _md_ts_1.Maj)(B, C, D);\n                K = 0x8f1bbcdc;\n            }\n            else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = ((0, utils_ts_1.rotl)(A, 5) + F + E + K + SHA1_W[i]) | 0;\n            E = D;\n            D = C;\n            C = (0, utils_ts_1.rotl)(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA1_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.SHA1 = SHA1;\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexports.sha1 = (0, utils_ts_1.createHasher)(() => new SHA1());\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nclass MD5 extends _md_ts_1.HashMD {\n    constructor() {\n        super(64, 16, 8, true);\n        this.A = MD5_IV[0] | 0;\n        this.B = MD5_IV[1] | 0;\n        this.C = MD5_IV[2] | 0;\n        this.D = MD5_IV[3] | 0;\n    }\n    get() {\n        const { A, B, C, D } = this;\n        return [A, B, C, D];\n    }\n    set(A, B, C, D) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            MD5_W[i] = view.getUint32(offset, true);\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D } = this;\n        for (let i = 0; i < 64; i++) {\n            let F, g, s;\n            if (i < 16) {\n                F = (0, _md_ts_1.Chi)(B, C, D);\n                g = i;\n                s = [7, 12, 17, 22];\n            }\n            else if (i < 32) {\n                F = (0, _md_ts_1.Chi)(D, B, C);\n                g = (5 * i + 1) % 16;\n                s = [5, 9, 14, 20];\n            }\n            else if (i < 48) {\n                F = B ^ C ^ D;\n                g = (3 * i + 5) % 16;\n                s = [4, 11, 16, 23];\n            }\n            else {\n                F = C ^ (B | ~D);\n                g = (7 * i) % 16;\n                s = [6, 10, 15, 21];\n            }\n            F = F + A + K[i] + MD5_W[g];\n            A = D;\n            D = C;\n            C = B;\n            B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        this.set(A, B, C, D);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(MD5_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.MD5 = MD5;\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexports.md5 = (0, utils_ts_1.createHasher)(() => new MD5());\n// RIPEMD-160\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n    const L = [Id160];\n    const R = [Pi160];\n    const res = [L, R];\n    for (let i = 0; i < 4; i++)\n        for (let j of res)\n            j.push(j[i].map((k) => Rho160[k]));\n    return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\nconst shifts160 = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It\'s called f() in spec.\nfunction ripemd_f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    if (group === 1)\n        return (x & y) | (~x & z);\n    if (group === 2)\n        return (x | ~y) ^ z;\n    if (group === 3)\n        return (x & z) | (y & ~z);\n    return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nclass RIPEMD160 extends _md_ts_1.HashMD {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF_160[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = ((0, utils_ts_1.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = (0, utils_ts_1.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = ((0, utils_ts_1.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = (0, utils_ts_1.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(BUF_160);\n    }\n    destroy() {\n        this.destroyed = true;\n        (0, utils_ts_1.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\nexports.RIPEMD160 = RIPEMD160;\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexports.ripemd160 = (0, utils_ts_1.createHasher)(() => new RIPEMD160());\n//# sourceMappingURL=legacy.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@noble/hashes/legacy.js?\n}')},"./node_modules/@noble/hashes/sha2.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nconst _md_ts_1 = __webpack_require__(/*! ./_md.js */ \"./node_modules/@noble/hashes/_md.js\");\nconst u64 = __webpack_require__(/*! ./_u64.js */ \"./node_modules/@noble/hashes/_u64.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/utils.js\");\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_ts_1.HashMD {\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = _md_ts_1.SHA256_IV[0] | 0;\n        this.B = _md_ts_1.SHA256_IV[1] | 0;\n        this.C = _md_ts_1.SHA256_IV[2] | 0;\n        this.D = _md_ts_1.SHA256_IV[3] | 0;\n        this.E = _md_ts_1.SHA256_IV[4] | 0;\n        this.F = _md_ts_1.SHA256_IV[5] | 0;\n        this.G = _md_ts_1.SHA256_IV[6] | 0;\n        this.H = _md_ts_1.SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);\n            const T2 = (sigma0 + (0, _md_ts_1.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.SHA256 = SHA256;\nclass SHA224 extends SHA256 {\n    constructor() {\n        super(28);\n        this.A = _md_ts_1.SHA224_IV[0] | 0;\n        this.B = _md_ts_1.SHA224_IV[1] | 0;\n        this.C = _md_ts_1.SHA224_IV[2] | 0;\n        this.D = _md_ts_1.SHA224_IV[3] | 0;\n        this.E = _md_ts_1.SHA224_IV[4] | 0;\n        this.F = _md_ts_1.SHA224_IV[5] | 0;\n        this.G = _md_ts_1.SHA224_IV[6] | 0;\n        this.H = _md_ts_1.SHA224_IV[7] | 0;\n    }\n}\nexports.SHA224 = SHA224;\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_ts_1.HashMD {\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = _md_ts_1.SHA512_IV[0] | 0;\n        this.Al = _md_ts_1.SHA512_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA512_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA512_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA512_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA512_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA512_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA512_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA512_IV[8] | 0;\n        this.El = _md_ts_1.SHA512_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA512_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA512_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA512_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA512_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA512_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0, utils_ts_1.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexports.SHA512 = SHA512;\nclass SHA384 extends SHA512 {\n    constructor() {\n        super(48);\n        this.Ah = _md_ts_1.SHA384_IV[0] | 0;\n        this.Al = _md_ts_1.SHA384_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA384_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA384_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA384_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA384_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA384_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA384_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA384_IV[8] | 0;\n        this.El = _md_ts_1.SHA384_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA384_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA384_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA384_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA384_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA384_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA384_IV[15] | 0;\n    }\n}\nexports.SHA384 = SHA384;\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nexports.SHA512_224 = SHA512_224;\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\nexports.SHA512_256 = SHA512_256;\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());\n/** SHA2-512 hash function from RFC 4634. */\nexports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());\n//# sourceMappingURL=sha2.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@noble/hashes/sha2.js?\n}")},"./node_modules/@noble/hashes/utils.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;\nexports.isBytes = isBytes;\nexports.anumber = anumber;\nexports.abytes = abytes;\nexports.ahash = ahash;\nexports.aexists = aexists;\nexports.aoutput = aoutput;\nexports.u8 = u8;\nexports.u32 = u32;\nexports.clean = clean;\nexports.createView = createView;\nexports.rotr = rotr;\nexports.rotl = rotl;\nexports.byteSwap = byteSwap;\nexports.byteSwap32 = byteSwap32;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.asyncLoop = asyncLoop;\nexports.utf8ToBytes = utf8ToBytes;\nexports.bytesToUtf8 = bytesToUtf8;\nexports.toBytes = toBytes;\nexports.kdfInputToBytes = kdfInputToBytes;\nexports.concatBytes = concatBytes;\nexports.checkOpts = checkOpts;\nexports.createHasher = createHasher;\nexports.createOptHasher = createOptHasher;\nexports.createXOFer = createXOFer;\nexports.randomBytes = randomBytes;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"./node_modules/@noble/hashes/crypto.js\");\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nfunction u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nfunction clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nfunction rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nfunction rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nfunction byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexports.swap8IfBE = exports.isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexports.byteSwapIfBE = exports.swap8IfBE;\n/** In place byte swap for Uint32Array */\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexports.swap32IfBE = exports.isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nfunction bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nfunction kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nclass Hash {\n}\nexports.Hash = Hash;\n/** Wraps hash function, creating an interface on top of it */\nfunction createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructor = createHasher;\nexports.wrapConstructorWithOpts = createOptHasher;\nexports.wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@noble/hashes/utils.js?\n}")},"./node_modules/@noble/secp256k1/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURVE: () => (/* binding */ CURVE),\n/* harmony export */   ProjectivePoint: () => (/* binding */ Point),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   etc: () => (/* binding */ etc),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   signAsync: () => (/* binding */ signAsync),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\n/**\n * 4KB JS implementation of secp256k1 signatures & ECDH. Compliant with RFC6979.\n * @module\n */\nconst B256 = 2n ** 256n;\nconst P = B256 - 0x1000003d1n; // curve's field prime\nconst N = B256 - 0x14551231950b75fc4402da1732fc9bebfn; // curve (group) order\nconst Gx = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n; // base point x\nconst Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n; // base point y\n/**\n * secp256k1 curve parameters. Equation is x + ax + b.\n * Gx and Gy are generator coordinates. p is field order, n is group order.\n */\nconst CURVE = {\n    p: P, n: N, a: 0n, b: 7n, Gx, Gy\n}; // exported variables incl. a, b\nconst fLen = 32; // field / group byte length\nconst curve = (x) => M(M(x * x) * x + CURVE.b); // x + ax + b weierstrass formula; a=0\nconst err = (m = '') => { throw new Error(m); }; // error helper, messes-up stack trace\nconst isB = (n) => typeof n === 'bigint'; // is big integer\nconst isS = (s) => typeof s === 'string'; // is string\nconst fe = (n) => isB(n) && 0n < n && n < P; // is field element (invertible)\nconst ge = (n) => isB(n) && 0n < n && n < N; // is group element\nconst isu8 = (a) => (a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array'));\nconst au8 = (a, l) => // assert is Uint8Array (of specific length)\n !isu8(a) || (typeof l === 'number' && l > 0 && a.length !== l) ?\n    err('Uint8Array expected') : a;\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst toU8 = (a, len) => au8(isS(a) ? h2b(a) : u8n(au8(a)), len); // norm(hex/u8a) to u8a\nconst M = (a, b = P) => {\n    const r = a % b;\n    return r >= 0n ? r : b + r;\n};\nconst aPoint = (p) => (p instanceof Point ? p : err('Point expected')); // is 3d point\n/** Point in 3d xyz projective coordinates. 3d takes less inversions than 2d. */\nclass Point {\n    constructor(px, py, pz) {\n        this.px = px;\n        this.py = py;\n        this.pz = pz;\n        Object.freeze(this);\n    }\n    /** Create 3d xyz point from 2d xy. (0, 0) => (0, 1, 0), not (0, 0, 1) */\n    static fromAffine(p) {\n        return ((p.x === 0n) && (p.y === 0n)) ? I : new Point(p.x, p.y, 1n);\n    }\n    /** Convert Uint8Array or hex string to Point. */\n    static fromHex(hex) {\n        hex = toU8(hex); // convert hex string to Uint8Array\n        let p = undefined;\n        const head = hex[0], tail = hex.subarray(1); // first byte is prefix, rest is data\n        const x = slc(tail, 0, fLen), len = hex.length; // next 32 bytes are x coordinate\n        if (len === 33 && [0x02, 0x03].includes(head)) { // compressed points: 33b, start\n            if (!fe(x))\n                err('Point hex invalid: x not FE'); // with byte 0x02 or 0x03. Check if 0<x<P\n            let y = sqrt(curve(x)); // x + ax + b is right side of equation\n            const isYOdd = (y & 1n) === 1n; // y is equivalent left-side. Calculate y:\n            const headOdd = (head & 1) === 1; // y = y; there are two solutions: y, -y\n            if (headOdd !== isYOdd)\n                y = M(-y); // determine proper solution\n            p = new Point(x, y, 1n); // create point\n        } // Uncompressed points: 65b, start with 0x04\n        if (len === 65 && head === 0x04)\n            p = new Point(x, slc(tail, fLen, 2 * fLen), 1n);\n        return p ? p.ok() : err('Point invalid: not on curve'); // Verify the result\n    }\n    /** Create point from a private key. */\n    static fromPrivateKey(k) { return G.mul(toPriv(k)); }\n    get x() { return this.aff().x; } // .x, .y will call expensive toAffine:\n    get y() { return this.aff().y; } // should be used with care.\n    /** Equality check: compare points P&Q. */\n    equals(other) {\n        const { px: X1, py: Y1, pz: Z1 } = this;\n        const { px: X2, py: Y2, pz: Z2 } = aPoint(other); // isPoint() checks class equality\n        const X1Z2 = M(X1 * Z2), X2Z1 = M(X2 * Z1);\n        const Y1Z2 = M(Y1 * Z2), Y2Z1 = M(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    /** Flip point over y coordinate. */\n    negate() { return new Point(this.px, M(-this.py), this.pz); }\n    /** Point doubling: P+P, complete formula. */\n    double() { return this.add(this); }\n    /**\n     * Point addition: P+Q, complete, exception-free formula\n     * (Renes-Costello-Batina, algo 1 of [2015/1060](https://eprint.iacr.org/2015/1060)).\n     * Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n     */\n    add(other) {\n        const { px: X1, py: Y1, pz: Z1 } = this;\n        const { px: X2, py: Y2, pz: Z2 } = aPoint(other);\n        const { a, b } = CURVE;\n        let X3 = 0n, Y3 = 0n, Z3 = 0n;\n        const b3 = M(b * 3n);\n        let t0 = M(X1 * X2), t1 = M(Y1 * Y2), t2 = M(Z1 * Z2), t3 = M(X1 + Y1); // step 1\n        let t4 = M(X2 + Y2); // step 5\n        t3 = M(t3 * t4);\n        t4 = M(t0 + t1);\n        t3 = M(t3 - t4);\n        t4 = M(X1 + Z1);\n        let t5 = M(X2 + Z2); // step 10\n        t4 = M(t4 * t5);\n        t5 = M(t0 + t2);\n        t4 = M(t4 - t5);\n        t5 = M(Y1 + Z1);\n        X3 = M(Y2 + Z2); // step 15\n        t5 = M(t5 * X3);\n        X3 = M(t1 + t2);\n        t5 = M(t5 - X3);\n        Z3 = M(a * t4);\n        X3 = M(b3 * t2); // step 20\n        Z3 = M(X3 + Z3);\n        X3 = M(t1 - Z3);\n        Z3 = M(t1 + Z3);\n        Y3 = M(X3 * Z3);\n        t1 = M(t0 + t0); // step 25\n        t1 = M(t1 + t0);\n        t2 = M(a * t2);\n        t4 = M(b3 * t4);\n        t1 = M(t1 + t2);\n        t2 = M(t0 - t2); // step 30\n        t2 = M(a * t2);\n        t4 = M(t4 + t2);\n        t0 = M(t1 * t4);\n        Y3 = M(Y3 + t0);\n        t0 = M(t5 * t4); // step 35\n        X3 = M(t3 * X3);\n        X3 = M(X3 - t0);\n        t0 = M(t3 * t1);\n        Z3 = M(t5 * Z3);\n        Z3 = M(Z3 + t0); // step 40\n        return new Point(X3, Y3, Z3);\n    }\n    mul(n, safe = true) {\n        if (!safe && n === 0n)\n            return I; // in unsafe mode, allow zero\n        if (!ge(n))\n            err('scalar invalid'); // must be 0 < n < CURVE.n\n        if (this.equals(G))\n            return wNAF(n).p; // use precomputes for base point\n        let p = I, f = G; // init result point & fake point\n        for (let d = this; n > 0n; d = d.double(), n >>= 1n) { // double-and-add ladder\n            if (n & 1n)\n                p = p.add(d); // if bit is present, add to point\n            else if (safe)\n                f = f.add(d); // if not, add to fake for timing safety\n        }\n        return p;\n    }\n    mulAddQUns(R, u1, u2) {\n        return this.mul(u1, false).add(R.mul(u2, false)).ok(); // Unsafe: do NOT use for stuff related\n    } // to private keys. Doesn't use Shamir trick\n    /** Convert point to 2d xy affine point. (x, y, z)  (x=x/z, y=y/z) */\n    toAffine() {\n        const { px: x, py: y, pz: z } = this;\n        if (this.equals(I))\n            return { x: 0n, y: 0n }; // fast-path for zero point\n        if (z === 1n)\n            return { x, y }; // if z is 1, pass affine coordinates as-is\n        const iz = inv(z, P); // z^-1: invert z\n        if (M(z * iz) !== 1n)\n            err('inverse invalid'); // (z * z^-1) must be 1, otherwise bad math\n        return { x: M(x * iz), y: M(y * iz) }; // x = x*z^-1; y = y*z^-1\n    }\n    /** Checks if the point is valid and on-curve. */\n    assertValidity() {\n        const { x, y } = this.aff(); // convert to 2d xy affine point.\n        if (!fe(x) || !fe(y))\n            err('Point invalid: x or y'); // x and y must be in range 0 < n < P\n        return M(y * y) === curve(x) ? // y = x + ax + b, must be equal\n            this : err('Point invalid: not on curve');\n    }\n    multiply(n) { return this.mul(n); } // Aliases to compress code\n    aff() { return this.toAffine(); }\n    ok() { return this.assertValidity(); }\n    toHex(isCompressed = true) {\n        const { x, y } = this.aff(); // convert to 2d xy affine point\n        const head = isCompressed ? ((y & 1n) === 0n ? '02' : '03') : '04'; // 0x02, 0x03, 0x04 prefix\n        return head + n2h(x) + (isCompressed ? '' : n2h(y)); // prefix||x and ||y\n    }\n    toRawBytes(isCompressed = true) {\n        return h2b(this.toHex(isCompressed)); // re-use toHex(), convert hex to bytes\n    }\n}\n/** Generator / base point */\nPoint.BASE = new Point(Gx, Gy, 1n);\n/** Identity / zero point */\nPoint.ZERO = new Point(0n, 1n, 0n);\nconst { BASE: G, ZERO: I } = Point; // Generator, identity points\nconst padh = (n, pad) => n.toString(16).padStart(pad, '0');\nconst b2h = (b) => Array.from(au8(b)).map(e => padh(e, 2)).join(''); // bytes to hex\nconst C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }; // ASCII characters\nconst _ch = (ch) => {\n    if (ch >= C._0 && ch <= C._9)\n        return ch - C._0; // '2' => 50-48\n    if (ch >= C.A && ch <= C.F)\n        return ch - (C.A - 10); // 'B' => 66-(65-10)\n    if (ch >= C.a && ch <= C.f)\n        return ch - (C.a - 10); // 'b' => 98-(97-10)\n    return;\n};\nconst h2b = (hex) => {\n    const e = 'hex invalid';\n    if (!isS(hex))\n        return err(e);\n    const hl = hex.length, al = hl / 2;\n    if (hl % 2)\n        return err(e);\n    const array = u8n(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) { // treat each char as ASCII\n        const n1 = _ch(hex.charCodeAt(hi)); // parse first char, multiply it by 16\n        const n2 = _ch(hex.charCodeAt(hi + 1)); // parse second char\n        if (n1 === undefined || n2 === undefined)\n            return err(e);\n        array[ai] = n1 * 16 + n2; // example: 'A9' => 10*16 + 9\n    }\n    return array;\n};\nconst b2n = (b) => BigInt('0x' + (b2h(b) || '0')); // bytes to number\nconst slc = (b, from, to) => b2n(b.slice(from, to)); // slice bytes num\nconst n2b = (num) => {\n    return isB(num) && num >= 0n && num < B256 ? h2b(padh(num, 2 * fLen)) : err('bigint expected');\n};\nconst n2h = (num) => b2h(n2b(num)); // number to 32b hex\nconst concatB = (...arrs) => {\n    const r = u8n(arrs.reduce((sum, a) => sum + au8(a).length, 0)); // create u8a of summed length\n    let pad = 0; // walk through each array,\n    arrs.forEach(a => { r.set(a, pad); pad += a.length; }); // ensure they have proper type\n    return r;\n};\nconst inv = (num, md) => {\n    if (num === 0n || md <= 0n)\n        err('no inverse n=' + num + ' mod=' + md); // no neg exponent for now\n    let a = M(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;\n    while (a !== 0n) { // uses euclidean gcd algorithm\n        const q = b / a, r = b % a; // not constant-time\n        const m = x - u * q, n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    return b === 1n ? M(x, md) : err('no inverse'); // b is gcd at this point\n};\nconst sqrt = (n) => {\n    let r = 1n; // So, a special, fast case. Paper: \"Square Roots from 1;24,51,10 to Dan Shanks\".\n    for (let num = n, e = (P + 1n) / 4n; e > 0n; e >>= 1n) { // powMod: modular exponentiation.\n        if (e & 1n)\n            r = (r * num) % P; // Uses exponentiation by squaring.\n        num = (num * num) % P; // Not constant-time.\n    }\n    return M(r * r) === n ? r : err('sqrt invalid'); // check if result is valid\n};\nconst toPriv = (p) => {\n    if (!isB(p))\n        p = b2n(toU8(p, fLen)); // convert to bigint when bytes\n    return ge(p) ? p : err('private key invalid 3'); // check if bigint is in range\n};\nconst high = (n) => n > (N >> 1n); // if a number is bigger than CURVE.n/2\n/** Creates 33/65-byte public key from 32-byte private key. */\nconst getPublicKey = (privKey, isCompressed = true) => {\n    return Point.fromPrivateKey(privKey).toRawBytes(isCompressed);\n};\n/** ECDSA Signature class. Supports only compact 64-byte representation, not DER. */\nclass Signature {\n    constructor(r, s, recovery) {\n        this.r = r;\n        this.s = s;\n        this.recovery = recovery;\n        this.assertValidity(); // recovery bit is optional when\n    } // constructed outside.\n    /** Create signature from 64b compact (r || s) representation. */\n    static fromCompact(hex) {\n        hex = toU8(hex, 64); // compact repr is (32b r)||(32b s)\n        return new Signature(slc(hex, 0, fLen), slc(hex, fLen, 2 * fLen));\n    }\n    assertValidity() { return ge(this.r) && ge(this.s) ? this : err(); } // 0 < r or s < CURVE.n\n    /** Create new signature, with added recovery bit. */\n    addRecoveryBit(rec) {\n        return new Signature(this.r, this.s, rec);\n    }\n    hasHighS() { return high(this.s); }\n    normalizeS() {\n        return high(this.s) ? new Signature(this.r, M(-this.s, N), this.recovery) : this;\n    }\n    /** ECDSA public key recovery. Requires msg hash and recovery id. */\n    recoverPublicKey(msgh) {\n        const { r, s, recovery: rec } = this; // secg.org/sec1-v2.pdf 4.1.6\n        if (![0, 1, 2, 3].includes(rec))\n            err('recovery id invalid'); // check recovery id\n        const h = bits2int_modN(toU8(msgh, fLen)); // Truncate hash\n        const radj = rec === 2 || rec === 3 ? r + N : r; // If rec was 2 or 3, q.x is bigger than n\n        if (radj >= P)\n            err('q.x invalid'); // ensure q.x is still a field element\n        const head = (rec & 1) === 0 ? '02' : '03'; // head is 0x02 or 0x03\n        const R = Point.fromHex(head + n2h(radj)); // concat head + hex repr of r\n        const ir = inv(radj, N); // r^-1\n        const u1 = M(-h * ir, N); // -hr^-1\n        const u2 = M(s * ir, N); // sr^-1\n        return G.mulAddQUns(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n    }\n    /** Uint8Array 64b compact (r || s) representation. */\n    toCompactRawBytes() { return h2b(this.toCompactHex()); }\n    /** Hex string 64b compact (r || s) representation. */\n    toCompactHex() { return n2h(this.r) + n2h(this.s); }\n}\nconst bits2int = (bytes) => {\n    const delta = bytes.length * 8 - 256; // RFC suggests optional truncating via bits2octets\n    if (delta > 1024)\n        err('msg invalid'); // our CUSTOM check, \"just-in-case\"\n    const num = b2n(bytes); // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which\n    return delta > 0 ? num >> BigInt(delta) : num; // matches bits2int. bits2int can produce res>N.\n};\nconst bits2int_modN = (bytes) => {\n    return M(bits2int(bytes), N); // with 0: BAD for trunc as per RFC vectors\n};\nconst i2o = (num) => n2b(num); // int to octets\nconst cr = () => // We support: 1) browsers 2) node.js 19+ 3) deno, other envs with crypto\n typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\nlet _hmacSync; // Can be redefined by use in utils; built-ins don't provide it\nconst optS = { lowS: true }; // opts for sign()\nconst optV = { lowS: true }; // standard opts for verify()\nconst prepSig = (msgh, priv, opts = optS) => {\n    if (['der', 'recovered', 'canonical'].some(k => k in opts))\n        err('option not supported'); // legacy opts\n    let { lowS } = opts; // generates low-s sigs by default\n    if (lowS == null)\n        lowS = true; // RFC6979 3.2: we skip step A\n    const h1i = bits2int_modN(toU8(msgh)); // msg bigint\n    const h1o = i2o(h1i); // msg octets\n    const d = toPriv(priv); // validate private key, convert to bigint\n    const seed = [i2o(d), h1o]; // Step D of RFC6979 3.2\n    let ent = opts.extraEntropy; // RFC6979 3.6: additional k' (optional)\n    if (ent) // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n        seed.push(ent === true ? etc.randomBytes(fLen) : toU8(ent)); // true == fetch from CSPRNG\n    const m = h1i; // convert msg to bigint\n    const k2sig = (kBytes) => {\n        const k = bits2int(kBytes); // RFC6979 method.\n        if (!ge(k))\n            return; // Check 0 < k < CURVE.n\n        const ik = inv(k, N); // k^-1 mod n, NOT mod P\n        const q = G.mul(k).aff(); // q = Gk\n        const r = M(q.x, N); // r = q.x mod n\n        if (r === 0n)\n            return; // r=0 invalid\n        const s = M(ik * M(m + M(d * r, N), N), N); // s = k^-1(m + rd) mod n\n        if (s === 0n)\n            return; // s=0 invalid\n        let normS = s; // normalized S\n        let rec = (q.x === r ? 0 : 2) | Number(q.y & 1n); // recovery bit\n        if (lowS && high(s)) { // if lowS was passed, ensure s is always\n            normS = M(-s, N); // in the bottom half of CURVE.n\n            rec ^= 1;\n        }\n        return new Signature(r, normS, rec); // use normS, not s\n    };\n    return { seed: concatB(...seed), k2sig };\n};\nfunction hmacDrbg(asynchronous) {\n    let v = u8n(fLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(fLen); // Steps B, C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => { v.fill(1); k.fill(0); i = 0; };\n    const _e = 'drbg: tried 1000 values';\n    if (asynchronous) { // asynchronous=true\n        const h = (...b) => etc.hmacSha256Async(k, v, ...b); // hmac(k)(v, ...values)\n        const reseed = async (seed = u8n()) => {\n            k = await h(u8n([0x00]), seed); // k = hmac(K || V || 0x00 || seed)\n            v = await h(); // v = hmac(K || V)\n            if (seed.length === 0)\n                return;\n            k = await h(u8n([0x01]), seed); // k = hmac(K || V || 0x01 || seed)\n            v = await h(); // v = hmac(K || V)\n        };\n        const gen = async () => {\n            if (i++ >= 1000)\n                err(_e);\n            v = await h(); // v = hmac(K || V)\n            return v;\n        };\n        return async (seed, pred) => {\n            reset(); // the returned fn, don't, it's: 1. slower (JIT). 2. unsafe (async race conditions)\n            await reseed(seed); // Steps D-G\n            let res = undefined; // Step H: grind until k is in [1..n-1]\n            while (!(res = pred(await gen())))\n                await reseed(); // test predicate until it returns ok\n            reset();\n            return res;\n        };\n    }\n    else {\n        const h = (...b) => {\n            const f = _hmacSync;\n            if (!f)\n                err('etc.hmacSha256Sync not set');\n            return f(k, v, ...b); // hmac(k)(v, ...values)\n        };\n        const reseed = (seed = u8n()) => {\n            k = h(u8n([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n            v = h(); // v = hmac(k || v)\n            if (seed.length === 0)\n                return;\n            k = h(u8n([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n            v = h(); // v = hmac(k || v)\n        };\n        const gen = () => {\n            if (i++ >= 1000)\n                err(_e);\n            v = h(); // v = hmac(k || v)\n            return v;\n        };\n        return (seed, pred) => {\n            reset();\n            reseed(seed); // Steps D-G\n            let res = undefined; // Step H: grind until k is in [1..n-1]\n            while (!(res = pred(gen())))\n                reseed(); // test predicate until it returns ok\n            reset();\n            return res;\n        };\n    }\n}\n;\n/** ECDSA signature generation. via secg.org/sec1-v2.pdf 4.1.2 + RFC6979 deterministic k. */\n/**\n * Sign a msg hash using secp256k1. Async.\n * It is advised to use `extraEntropy: true` (from RFC6979 3.6) to prevent fault attacks.\n * Worst case: if randomness source for extraEntropy is bad, it would be as secure as if\n * the option has not been used.\n * @param msgh - message HASH, not message itself e.g. sha256(message)\n * @param priv - private key\n * @param opts - `lowS: true` to prevent malleability (s >= CURVE.n/2), `extraEntropy: boolean | Hex` to improve sig security.\n */\nconst signAsync = async (msgh, priv, opts = optS) => {\n    const { seed, k2sig } = prepSig(msgh, priv, opts); // Extract arguments for hmac-drbg\n    return hmacDrbg(true)(seed, k2sig); // Re-run drbg until k2sig returns ok\n};\n/**\n * Sign a msg hash using secp256k1.\n * It is advised to use `extraEntropy: true` (from RFC6979 3.6) to prevent fault attacks.\n * Worst case: if randomness source for extraEntropy is bad, it would be as secure as if\n * the option has not been used.\n * @param msgh - message HASH, not message itself e.g. sha256(message)\n * @param priv - private key\n * @param opts - `lowS: true` to prevent malleability (s >= CURVE.n/2), `extraEntropy: boolean | Hex` to improve sig security.\n * @example\n * const sig = sign(sha256('hello'), privKey, { extraEntropy: true }).toCompactRawBytes();\n */\nconst sign = (msgh, priv, opts = optS) => {\n    const { seed, k2sig } = prepSig(msgh, priv, opts); // Extract arguments for hmac-drbg\n    return hmacDrbg(false)(seed, k2sig); // Re-run drbg until k2sig returns ok\n};\n/**\n * Verify a signature using secp256k1.\n * @param sig - signature, 64-byte or Signature instance\n * @param msgh - message HASH, not message itself e.g. sha256(message)\n * @param pub - public key\n * @param opts - { lowS: true } is default, prohibits s >= CURVE.n/2 to prevent malleability\n */\nconst verify = (sig, msgh, pub, opts = optV) => {\n    let { lowS } = opts; // ECDSA signature verification\n    if (lowS == null)\n        lowS = true; // Default lowS=true\n    if ('strict' in opts)\n        err('option not supported'); // legacy param\n    let sig_, h, P; // secg.org/sec1-v2.pdf 4.1.4\n    const rs = sig && typeof sig === 'object' && 'r' in sig; // Previous ver supported DER sigs. We\n    if (!rs && (toU8(sig).length !== 2 * fLen)) // throw error when DER is suspected now.\n        err('signature must be 64 bytes');\n    try {\n        sig_ = rs ? new Signature(sig.r, sig.s).assertValidity() : Signature.fromCompact(sig);\n        h = bits2int_modN(toU8(msgh)); // Truncate hash\n        P = pub instanceof Point ? pub.ok() : Point.fromHex(pub); // Validate public key\n    }\n    catch (e) {\n        return false;\n    } // Check sig for validity in both cases\n    if (!sig_)\n        return false;\n    const { r, s } = sig_;\n    if (lowS && high(s))\n        return false; // lowS bans sig.s >= CURVE.n/2\n    let R;\n    try {\n        const is = inv(s, N); // s^-1\n        const u1 = M(h * is, N); // u1 = hs^-1 mod n\n        const u2 = M(r * is, N); // u2 = rs^-1 mod n\n        R = G.mulAddQUns(P, u1, u2).aff(); // R = u1G + u2P\n    }\n    catch (error) {\n        return false;\n    }\n    if (!R)\n        return false; // stop if R is identity / zero point\n    const v = M(R.x, N); // R.x must be in N's field, not P's\n    return v === r; // mod(R.x, n) == r\n};\n/**\n * Elliptic Curve Diffie-Hellman (ECDH) on secp256k1.\n * Result is **NOT hashed**. Use hash on it if you need.\n * @param privA private key A\n * @param pubB public key B\n * @param isCompressed 33-byte or 65-byte output\n * @returns public key C\n */\nconst getSharedSecret = (privA, pubB, isCompressed = true) => {\n    return Point.fromHex(pubB).mul(toPriv(privA)).toRawBytes(isCompressed); // ECDH\n};\nconst hashToPrivateKey = (hash) => {\n    hash = toU8(hash); // produces private keys with modulo bias\n    if (hash.length < fLen + 8 || hash.length > 1024)\n        err('expected 40-1024b'); // being neglible.\n    const num = M(b2n(hash), N - 1n); // takes n+8 bytes\n    return n2b(num + 1n); // returns (hash mod n-1)+1\n};\n/** Math, hex, byte helpers. Not in `utils` because utils share API with noble-curves. */\nconst etc = {\n    hexToBytes: h2b,\n    bytesToHex: b2h,\n    concatBytes: concatB,\n    bytesToNumberBE: b2n,\n    numberToBytesBE: n2b,\n    mod: M,\n    invert: inv, // math utilities\n    hmacSha256Async: async (key, ...msgs) => {\n        const c = cr(); // async HMAC-SHA256, no sync built-in!\n        const s = c && c.subtle; // For React Native support, see README.\n        if (!s)\n            return err('etc.hmacSha256Async or crypto.subtle must be defined'); // Uses webcrypto built-in cryptography.\n        const k = await s.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n        return u8n(await s.sign('HMAC', k, concatB(...msgs)));\n    },\n    hmacSha256Sync: _hmacSync, // For TypeScript. Actual logic is below\n    hashToPrivateKey: hashToPrivateKey,\n    randomBytes: (len = 32) => {\n        const crypto = cr(); // Must be shimmed in node.js <= 18 to prevent error. See README.\n        if (!crypto || !crypto.getRandomValues)\n            err('crypto.getRandomValues must be defined');\n        return crypto.getRandomValues(u8n(len));\n    },\n};\n/** Curve-specific utilities for private keys. */\nconst utils = {\n    normPrivateKeyToScalar: toPriv,\n    isValidPrivateKey: (key) => { try {\n        return !!toPriv(key);\n    }\n    catch (e) {\n        return false;\n    } },\n    randomPrivateKey: () => hashToPrivateKey(etc.randomBytes(fLen + 16)), // FIPS 186 B.4.1.\n    precompute: (w = 8, p = G) => { p.multiply(3n); w; return p; }, // no-op\n};\nObject.defineProperties(etc, { hmacSha256Sync: {\n        configurable: false, get() { return _hmacSync; }, set(f) { if (!_hmacSync)\n            _hmacSync = f; },\n    } });\nconst W = 8; // Precomputes-related code. W = window size\nconst precompute = () => {\n    const points = []; // 10x sign(), 2x verify(). To achieve this,\n    const windows = 256 / W + 1; // app needs to spend 40ms+ to calculate\n    let p = G, b = p; // a lot of points related to base point G.\n    for (let w = 0; w < windows; w++) { // Points are stored in array and used\n        b = p; // any time Gx multiplication is done.\n        points.push(b); // They consume 16-32 MiB of RAM.\n        for (let i = 1; i < 2 ** (W - 1); i++) {\n            b = b.add(p);\n            points.push(b);\n        }\n        p = b.double(); // Precomputes don't speed-up getSharedKey,\n    } // which multiplies user point by scalar,\n    return points; // when precomputes are using base point\n};\nlet Gpows = undefined; // precomputes for base point G\nconst wNAF = (n) => {\n    // Compared to other point mult methods,\n    const comp = Gpows || (Gpows = precompute()); // stores 2x less points using subtraction\n    const neg = (cnd, p) => { let n = p.negate(); return cnd ? n : p; }; // negate\n    let p = I, f = G; // f must be G, or could become I in the end\n    const windows = 1 + 256 / W; // W=8 17 windows\n    const wsize = 2 ** (W - 1); // W=8 128 window size\n    const mask = BigInt(2 ** W - 1); // W=8 will create mask 0b11111111\n    const maxNum = 2 ** W; // W=8 256\n    const shiftBy = BigInt(W); // W=8 8\n    for (let w = 0; w < windows; w++) {\n        const off = w * wsize;\n        let wbits = Number(n & mask); // extract W bits.\n        n >>= shiftBy; // shift number by W bits.\n        if (wbits > wsize) {\n            wbits -= maxNum;\n            n += 1n;\n        } // split if bits > max: +224 => 256-32\n        const off1 = off, off2 = off + Math.abs(wbits) - 1; // offsets, evaluate both\n        const cnd1 = w % 2 !== 0, cnd2 = wbits < 0; // conditions, evaluate both\n        if (wbits === 0) {\n            f = f.add(neg(cnd1, comp[off1])); // bits are 0: add garbage to fake point\n        }\n        else { //          ^ can't add off2, off2 = I\n            p = p.add(neg(cnd2, comp[off2])); // bits are 1: add to result point\n        }\n    }\n    return { p, f }; // return both real and fake points for JIT\n}; // !! you can disable precomputes by commenting-out call of the wNAF() inside Point#mul()\n // envs like browser console\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@noble/secp256k1/index.js?\n}")},"./node_modules/@scure/base/lib/index.js":(__unused_webpack_module,exports)=>{"use strict";eval("{\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64nopad = exports.base64 = exports.base32crockford = exports.base32hexnopad = exports.base32hex = exports.base32nopad = exports.base32 = exports.base16 = exports.utils = void 0;\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\nfunction isArrayOf(isString, arr) {\n    if (!Array.isArray(arr))\n        return false;\n    if (arr.length === 0)\n        return true;\n    if (isString) {\n        return arr.every((item) => typeof item === 'string');\n    }\n    else {\n        return arr.every((item) => Number.isSafeInteger(item));\n    }\n}\n// no abytes: seems to have 10% slowdown. Why?!\nfunction afn(input) {\n    if (typeof input !== 'function')\n        throw new Error('function expected');\n    return true;\n}\nfunction astr(label, input) {\n    if (typeof input !== 'string')\n        throw new Error(`${label}: string expected`);\n    return true;\n}\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`invalid integer: ${n}`);\n}\nfunction aArr(input) {\n    if (!Array.isArray(input))\n        throw new Error('array expected');\n}\nfunction astrArr(label, input) {\n    if (!isArrayOf(true, input))\n        throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label, input) {\n    if (!isArrayOf(false, input))\n        throw new Error(`${label}: array of numbers expected`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters) {\n    // mapping 1 to \"b\"\n    const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n    const len = lettersA.length;\n    astrArr('alphabet', lettersA);\n    // mapping \"b\" to 1\n    const indexes = new Map(lettersA.map((l, i) => [l, i]));\n    return {\n        encode: (digits) => {\n            aArr(digits);\n            return digits.map((i) => {\n                if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n                    throw new Error(`alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`);\n                return lettersA[i];\n            });\n        },\n        decode: (input) => {\n            aArr(input);\n            return input.map((letter) => {\n                astr('alphabet.decode', letter);\n                const i = indexes.get(letter);\n                if (i === undefined)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n                return i;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    astr('join', separator);\n    return {\n        encode: (from) => {\n            astrArr('join.decode', from);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            astr('join.decode', to);\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    anumber(bits);\n    astr('padding', chr);\n    return {\n        encode(data) {\n            astrArr('padding.encode', data);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            astrArr('padding.decode', input);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('padding: invalid, string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                const last = end - 1;\n                const byte = last * bits;\n                if (byte % 8 === 0)\n                    throw new Error('padding: invalid, string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    afn(fn);\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n    aArr(data);\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data, (d) => {\n        anumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`invalid integer: ${d}`);\n        return d;\n    });\n    const dlen = digits.length;\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < dlen; i++) {\n            const digit = digits[i];\n            const fromCarry = from * carry;\n            const digitBase = fromCarry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                fromCarry / from !== carry ||\n                digitBase - digit !== fromCarry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            const div = digitBase / to;\n            carry = digitBase % to;\n            const rounded = Math.floor(div);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\nconst powers = /* @__PURE__ */ (() => {\n    let res = [];\n    for (let i = 0; i < 40; i++)\n        res.push(2 ** i);\n    return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data, from, to, padding) {\n    aArr(data);\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const max = powers[from];\n    const mask = powers[to] - 1;\n    const res = [];\n    for (const n of data) {\n        anumber(n);\n        if (n >= max)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        const pow = powers[pos];\n        if (pow === undefined)\n            throw new Error('invalid carry');\n        carry &= pow - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry > 0)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    anumber(num);\n    const _256 = 2 ** 8;\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), _256, num);\n        },\n        decode: (digits) => {\n            anumArr('radix.decode', digits);\n            return Uint8Array.from(convertRadix(digits, num, _256));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    anumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            anumArr('radix2.decode', digits);\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    afn(fn);\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    anumber(len);\n    afn(fn);\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const sum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(sum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const oldChecksum = data.slice(-len);\n            const newChecksum = fn(payload).slice(0, len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nexports.utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nexports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexports.base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexports.base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// prettier-ignore\nconst hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === 'function' &&\n    typeof Uint8Array.fromBase64 === 'function')();\nconst decodeBase64Builtin = (s, isUrl) => {\n    astr('base64', s);\n    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;\n    const alphabet = isUrl ? 'base64url' : 'base64';\n    if (s.length > 0 && !re.test(s))\n        throw new Error('invalid base64');\n    return Uint8Array.fromBase64(s, { alphabet, lastChunkHandling: 'strict' });\n};\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexports.base64 = hasBase64Builtin ? {\n    encode(b) { abytes(b); return b.toBase64(); },\n    decode(s) { return decodeBase64Builtin(s, false); },\n} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexports.base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexports.base64url = hasBase64Builtin ? {\n    encode(b) { abytes(b); return b.toBase64({ alphabet: 'base64url' }); },\n    decode(s) { return decodeBase64Builtin(s, true); },\n} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexports.base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => chain(radix(58), alphabet(abc), join(''));\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nexports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\n/**\n * base58: flickr version. Check out `base58`.\n */\nexports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\n/**\n * base58: XRP version. Check out `base58`.\n */\nexports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexports.base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = exports.base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nconst createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);\nexports.createBase58check = createBase58check;\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexports.base58check = exports.createBase58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        astr('bech32.encode prefix', prefix);\n        if (isBytes(words))\n            words = Array.from(words);\n        anumArr('bech32.encode', words);\n        const plen = prefix.length;\n        if (plen === 0)\n            throw new TypeError(`Invalid prefix length ${plen}`);\n        const actualLength = plen + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        astr('bech32.decode input', str);\n        const slen = str.length;\n        if (slen < 8 || (limit !== false && slen > limit))\n            throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords,\n    };\n}\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexports.bech32 = genBech32('bech32');\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexports.bech32m = genBech32('bech32m');\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nexports.utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === 'function' &&\n    typeof Uint8Array.fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin = {\n    encode(data) { abytes(data); return data.toHex(); },\n    decode(s) { astr('hex', s); return Uint8Array.fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nexports.hex = hasHexBuiltin\n    ? hexBuiltin\n    : chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n            throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n        return s.toLowerCase();\n    }));\n// prettier-ignore\nconst CODERS = {\n    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n/** @deprecated */\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexports.bytesToString = bytesToString;\n/** @deprecated */\nexports.str = exports.bytesToString; // as in python, but for bytes only\n/** @deprecated */\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexports.stringToBytes = stringToBytes;\n/** @deprecated */\nexports.bytes = exports.stringToBytes;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@scure/base/lib/index.js?\n}")},"./node_modules/@scure/btc-signer/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports._Estimator = exports._cmpBig = exports.SigHash = exports.PSBTCombine = exports.DEFAULT_SEQUENCE = exports.Decimal = exports.bip32Path = exports.TaprootControlBlock = exports._DebugPSBT = exports.WIF = exports.taprootListToTree = exports.sortedMultisig = exports.OutScript = exports.getAddress = exports.combinations = exports.Address = exports._sortPubkeys = exports.utils = exports.selectUTXO = exports.TEST_NETWORK = exports.TAPROOT_UNSPENDABLE_KEY = exports.NETWORK = exports.Transaction = exports.getInputType = exports.ScriptNum = exports.Script = exports.RawWitness = exports.RawTx = exports.OP = exports.MAX_SCRIPT_BYTE_LENGTH = exports.CompactSize = exports.p2wsh = exports.p2wpkh = exports.p2tr_pk = exports.p2tr_ns = exports.p2tr_ms = exports.p2tr = exports.p2sh = exports.p2pkh = exports.p2pk = exports.p2ms = exports.multisig = void 0;\n/*! scure-btc-signer - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@scure/btc-signer/utils.js");\n// should multisig be exported as classicMultisig?\n// prettier-ignore\nvar payment_ts_1 = __webpack_require__(/*! ./payment.js */ "./node_modules/@scure/btc-signer/payment.js");\nObject.defineProperty(exports, "multisig", ({ enumerable: true, get: function () { return payment_ts_1.multisig; } }));\nObject.defineProperty(exports, "p2ms", ({ enumerable: true, get: function () { return payment_ts_1.p2ms; } }));\nObject.defineProperty(exports, "p2pk", ({ enumerable: true, get: function () { return payment_ts_1.p2pk; } }));\nObject.defineProperty(exports, "p2pkh", ({ enumerable: true, get: function () { return payment_ts_1.p2pkh; } }));\nObject.defineProperty(exports, "p2sh", ({ enumerable: true, get: function () { return payment_ts_1.p2sh; } }));\nObject.defineProperty(exports, "p2tr", ({ enumerable: true, get: function () { return payment_ts_1.p2tr; } }));\nObject.defineProperty(exports, "p2tr_ms", ({ enumerable: true, get: function () { return payment_ts_1.p2tr_ms; } }));\nObject.defineProperty(exports, "p2tr_ns", ({ enumerable: true, get: function () { return payment_ts_1.p2tr_ns; } }));\nObject.defineProperty(exports, "p2tr_pk", ({ enumerable: true, get: function () { return payment_ts_1.p2tr_pk; } }));\nObject.defineProperty(exports, "p2wpkh", ({ enumerable: true, get: function () { return payment_ts_1.p2wpkh; } }));\nObject.defineProperty(exports, "p2wsh", ({ enumerable: true, get: function () { return payment_ts_1.p2wsh; } }));\nvar script_ts_1 = __webpack_require__(/*! ./script.js */ "./node_modules/@scure/btc-signer/script.js");\nObject.defineProperty(exports, "CompactSize", ({ enumerable: true, get: function () { return script_ts_1.CompactSize; } }));\nObject.defineProperty(exports, "MAX_SCRIPT_BYTE_LENGTH", ({ enumerable: true, get: function () { return script_ts_1.MAX_SCRIPT_BYTE_LENGTH; } }));\nObject.defineProperty(exports, "OP", ({ enumerable: true, get: function () { return script_ts_1.OP; } }));\nObject.defineProperty(exports, "RawTx", ({ enumerable: true, get: function () { return script_ts_1.RawTx; } }));\nObject.defineProperty(exports, "RawWitness", ({ enumerable: true, get: function () { return script_ts_1.RawWitness; } }));\nObject.defineProperty(exports, "Script", ({ enumerable: true, get: function () { return script_ts_1.Script; } }));\nObject.defineProperty(exports, "ScriptNum", ({ enumerable: true, get: function () { return script_ts_1.ScriptNum; } }));\nvar transaction_ts_1 = __webpack_require__(/*! ./transaction.js */ "./node_modules/@scure/btc-signer/transaction.js");\nObject.defineProperty(exports, "getInputType", ({ enumerable: true, get: function () { return transaction_ts_1.getInputType; } }));\nObject.defineProperty(exports, "Transaction", ({ enumerable: true, get: function () { return transaction_ts_1.Transaction; } }));\nvar utils_ts_2 = __webpack_require__(/*! ./utils.js */ "./node_modules/@scure/btc-signer/utils.js");\nObject.defineProperty(exports, "NETWORK", ({ enumerable: true, get: function () { return utils_ts_2.NETWORK; } }));\nObject.defineProperty(exports, "TAPROOT_UNSPENDABLE_KEY", ({ enumerable: true, get: function () { return utils_ts_2.TAPROOT_UNSPENDABLE_KEY; } }));\nObject.defineProperty(exports, "TEST_NETWORK", ({ enumerable: true, get: function () { return utils_ts_2.TEST_NETWORK; } }));\nvar utxo_ts_1 = __webpack_require__(/*! ./utxo.js */ "./node_modules/@scure/btc-signer/utxo.js");\nObject.defineProperty(exports, "selectUTXO", ({ enumerable: true, get: function () { return utxo_ts_1.selectUTXO; } }));\nexports.utils = {\n    isBytes: utils_ts_1.isBytes,\n    concatBytes: utils_ts_1.concatBytes,\n    compareBytes: utils_ts_1.compareBytes,\n    pubSchnorr: utils_ts_1.pubSchnorr,\n    randomPrivateKeyBytes: utils_ts_1.randomPrivateKeyBytes,\n    taprootTweakPubkey: utils_ts_1.taprootTweakPubkey,\n};\nvar payment_ts_2 = __webpack_require__(/*! ./payment.js */ "./node_modules/@scure/btc-signer/payment.js"); // remove\nObject.defineProperty(exports, "_sortPubkeys", ({ enumerable: true, get: function () { return payment_ts_2._sortPubkeys; } }));\nObject.defineProperty(exports, "Address", ({ enumerable: true, get: function () { return payment_ts_2.Address; } }));\nObject.defineProperty(exports, "combinations", ({ enumerable: true, get: function () { return payment_ts_2.combinations; } }));\nObject.defineProperty(exports, "getAddress", ({ enumerable: true, get: function () { return payment_ts_2.getAddress; } }));\nObject.defineProperty(exports, "OutScript", ({ enumerable: true, get: function () { return payment_ts_2.OutScript; } }));\nObject.defineProperty(exports, "sortedMultisig", ({ enumerable: true, get: function () { return payment_ts_2.sortedMultisig; } }));\nObject.defineProperty(exports, "taprootListToTree", ({ enumerable: true, get: function () { return payment_ts_2.taprootListToTree; } }));\nObject.defineProperty(exports, "WIF", ({ enumerable: true, get: function () { return payment_ts_2.WIF; } }));\nvar psbt_ts_1 = __webpack_require__(/*! ./psbt.js */ "./node_modules/@scure/btc-signer/psbt.js"); // remove\nObject.defineProperty(exports, "_DebugPSBT", ({ enumerable: true, get: function () { return psbt_ts_1._DebugPSBT; } }));\nObject.defineProperty(exports, "TaprootControlBlock", ({ enumerable: true, get: function () { return psbt_ts_1.TaprootControlBlock; } }));\nvar transaction_ts_2 = __webpack_require__(/*! ./transaction.js */ "./node_modules/@scure/btc-signer/transaction.js"); // remove\nObject.defineProperty(exports, "bip32Path", ({ enumerable: true, get: function () { return transaction_ts_2.bip32Path; } }));\nObject.defineProperty(exports, "Decimal", ({ enumerable: true, get: function () { return transaction_ts_2.Decimal; } }));\nObject.defineProperty(exports, "DEFAULT_SEQUENCE", ({ enumerable: true, get: function () { return transaction_ts_2.DEFAULT_SEQUENCE; } }));\nObject.defineProperty(exports, "PSBTCombine", ({ enumerable: true, get: function () { return transaction_ts_2.PSBTCombine; } }));\nObject.defineProperty(exports, "SigHash", ({ enumerable: true, get: function () { return transaction_ts_2.SigHash; } }));\nvar utxo_ts_2 = __webpack_require__(/*! ./utxo.js */ "./node_modules/@scure/btc-signer/utxo.js");\nObject.defineProperty(exports, "_cmpBig", ({ enumerable: true, get: function () { return utxo_ts_2._cmpBig; } }));\nObject.defineProperty(exports, "_Estimator", ({ enumerable: true, get: function () { return utxo_ts_2._Estimator; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@scure/btc-signer/index.js?\n}')},"./node_modules/@scure/btc-signer/musig2.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Session = exports.InvalidContributionErr = void 0;\nexports.IndividualPubkey = IndividualPubkey;\nexports.sortKeys = sortKeys;\nexports.keyAggregate = keyAggregate;\nexports.keyAggExport = keyAggExport;\nexports.nonceGen = nonceGen;\nexports.nonceAggregate = nonceAggregate;\nexports.deterministicSign = deterministicSign;\nconst modular_js_1 = __webpack_require__(/*! @noble/curves/abstract/modular.js */ \"./node_modules/@noble/curves/abstract/modular.js\");\nconst utils_js_1 = __webpack_require__(/*! @noble/curves/abstract/utils.js */ \"./node_modules/@noble/curves/abstract/utils.js\");\nconst secp256k1_js_1 = __webpack_require__(/*! @noble/curves/secp256k1.js */ \"./node_modules/@noble/curves/secp256k1.js\");\nconst utils_js_2 = __webpack_require__(/*! @noble/hashes/utils.js */ \"./node_modules/@noble/hashes/utils.js\");\nconst P = __webpack_require__(/*! micro-packed */ \"./node_modules/micro-packed/lib/index.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@scure/btc-signer/utils.js\");\n/**\n * Represents an error indicating an invalid contribution from a signer.\n * This allows pointing out which participant is malicious and what specifically is wrong.\n */\nclass InvalidContributionErr extends Error {\n    constructor(idx, m) {\n        super(m);\n        this.idx = idx;\n    }\n}\nexports.InvalidContributionErr = InvalidContributionErr;\n// Utils\nconst { taggedHash, pointToBytes } = secp256k1_js_1.schnorr.utils;\nconst Point = secp256k1_js_1.secp256k1.ProjectivePoint;\nconst PUBKEY_LEN = 33;\nconst ZERO = new Uint8Array(PUBKEY_LEN); // Compressed zero point\nconst SECP_N = secp256k1_js_1.secp256k1.CURVE.n;\n// Encoding\n// TODO: re-use in PSBT?\nconst compressed = P.apply(P.bytes(33), {\n    decode: (p) => (isZero(p) ? ZERO : p.toRawBytes(true)),\n    encode: (b) => ((0, utils_js_1.equalBytes)(b, ZERO) ? Point.ZERO : Point.fromHex(b)),\n});\nconst scalar = P.validate(P.U256BE, (n) => {\n    (0, utils_js_1.aInRange)('n', n, 1n, SECP_N);\n    return n;\n});\nconst PubNonce = P.struct({ R1: compressed, R2: compressed });\nconst SecretNonce = P.struct({ k1: scalar, k2: scalar, publicKey: P.bytes(PUBKEY_LEN) });\nfunction abytesOptional(b, ...lengths) {\n    if (b !== undefined)\n        (0, utils_js_2.abytes)(b, ...lengths);\n}\nfunction abytesArray(lst, ...lengths) {\n    if (!Array.isArray(lst))\n        throw new Error('expected array');\n    lst.forEach((i) => (0, utils_js_2.abytes)(i, ...lengths));\n}\nfunction aXonly(lst) {\n    if (!Array.isArray(lst))\n        throw new Error('expected array');\n    lst.forEach((i, j) => {\n        if (typeof i !== 'boolean')\n            throw new Error('expected boolean in xOnly array, got' + i + '(' + j + ')');\n    });\n}\nconst modN = (x) => (0, modular_js_1.mod)(x, SECP_N);\nconst taggedInt = (tag, ...messages) => modN((0, utils_js_1.bytesToNumberBE)(taggedHash(tag, ...messages)));\nconst evenScalar = (p, n) => (p.hasEvenY() ? n : modN(-n));\n// Short utility for compat with reference implementation\nfunction IndividualPubkey(seckey) {\n    return secp256k1_js_1.secp256k1.getPublicKey(seckey, true);\n}\n// Same, but returns Point\nfunction mulBase(n) {\n    return Point.BASE.multiply(n);\n}\nfunction isZero(point) {\n    return point.equals(Point.ZERO);\n}\n/**\n * Lexicographically sorts an array of public keys.\n * @param publicKeys An array of public keys (Uint8Array).\n * @returns A new array containing the sorted public keys.\n * @throws {Error} If the input is not an array or if any element is not a Uint8Array of the correct length.\n */\nfunction sortKeys(publicKeys) {\n    abytesArray(publicKeys, PUBKEY_LEN);\n    return publicKeys.sort(utils_ts_1.compareBytes);\n}\n// Finds second distinct key (to make coefficient 1)\nfunction getSecondKey(publicKeys) {\n    abytesArray(publicKeys, PUBKEY_LEN);\n    for (let j = 1; j < publicKeys.length; j++)\n        if (!(0, utils_js_1.equalBytes)(publicKeys[j], publicKeys[0]))\n            return publicKeys[j];\n    return ZERO;\n}\nfunction keyAggL(publicKeys) {\n    abytesArray(publicKeys, PUBKEY_LEN);\n    return taggedHash('KeyAgg list', ...publicKeys);\n}\nfunction keyAggCoeffInternal(publicKey1, publicKey2, L) {\n    (0, utils_js_2.abytes)(publicKey1, PUBKEY_LEN);\n    (0, utils_js_2.abytes)(publicKey2, PUBKEY_LEN);\n    if ((0, utils_js_1.equalBytes)(publicKey1, publicKey2))\n        return 1n;\n    return taggedInt('KeyAgg coefficient', L, publicKey1);\n}\n/**\n * Aggregates multiple public keys using the MuSig2 key aggregation algorithm.\n * @param publicKeys An array of individual public keys (Uint8Array).\n * @param tweaks An optional array of tweaks (Uint8Array) to apply to the aggregate public key.\n * @param isXonly An optional array of booleans indicating whether each tweak is an X-only tweak.\n * @returns An object containing the aggregate public key, accumulated sign, and accumulated tweak.\n * @throws {Error} If the input is invalid, such as non array publicKeys, tweaks and isXonly array length not matching.\n * @throws {InvalidContributionErr} If any of the public keys are invalid and cannot be processed.\n */\nfunction keyAggregate(publicKeys, tweaks = [], isXonly = []) {\n    abytesArray(publicKeys, PUBKEY_LEN);\n    abytesArray(tweaks, 32);\n    if (tweaks.length !== isXonly.length)\n        throw new Error('The tweaks and isXonly arrays must have the same length');\n    // Aggregate\n    const pk2 = getSecondKey(publicKeys);\n    const L = keyAggL(publicKeys);\n    let aggPublicKey = Point.ZERO;\n    for (let i = 0; i < publicKeys.length; i++) {\n        let Pi;\n        try {\n            Pi = Point.fromHex(publicKeys[i]);\n        }\n        catch (error) {\n            throw new InvalidContributionErr(i, 'pubkey');\n        }\n        aggPublicKey = aggPublicKey.add(Pi.multiply(keyAggCoeffInternal(publicKeys[i], pk2, L)));\n    }\n    let gAcc = 1n;\n    let tweakAcc = 0n;\n    // Apply tweaks\n    for (let i = 0; i < tweaks.length; i++) {\n        const g = isXonly[i] && !aggPublicKey.hasEvenY() ? modN(-1n) : 1n;\n        const t = (0, utils_js_1.bytesToNumberBE)(tweaks[i]);\n        (0, utils_js_1.aInRange)('tweak', t, 0n, SECP_N);\n        aggPublicKey = aggPublicKey.multiply(g).add(mulBase(t));\n        if (isZero(aggPublicKey))\n            throw new Error('The result of tweaking cannot be infinity');\n        gAcc = modN(g * gAcc);\n        tweakAcc = modN(t + g * tweakAcc);\n    }\n    return { aggPublicKey, gAcc, tweakAcc };\n}\n/**\n * Exports the aggregate public key to a byte array.\n * @param ctx The result of the keyAggregate function.\n * @returns The aggregate public key as a byte array.\n */\nfunction keyAggExport(ctx) {\n    return pointToBytes(ctx.aggPublicKey);\n}\nfunction aux(secret, rand) {\n    const rand2 = taggedHash('MuSig/aux', rand);\n    if (secret.length !== rand2.length)\n        throw new Error('Cannot XOR arrays of different lengths');\n    const res = new Uint8Array(secret.length);\n    for (let i = 0; i < secret.length; i++)\n        res[i] = secret[i] ^ rand2[i];\n    return res;\n}\nconst nonceHash = (rand, publicKey, aggPublicKey, i, msgPrefixed, extraIn) => taggedInt('MuSig/nonce', rand, new Uint8Array([publicKey.length]), publicKey, new Uint8Array([aggPublicKey.length]), aggPublicKey, msgPrefixed, (0, utils_js_1.numberToBytesBE)(extraIn.length, 4), extraIn, new Uint8Array([i]));\n/**\n * Generates a nonce pair (public and secret) for MuSig2 signing.\n * @param publicKey The individual public key of the signer (Uint8Array).\n * @param secretKey The secret key of the signer (Uint8Array). Optional, included to xor randomness\n * @param aggPublicKey The aggregate public key of all signers (Uint8Array).\n * @param msg The message to be signed (Uint8Array).\n * @param extraIn Extra input for nonce generation (Uint8Array).\n * @param rand Random 32-bytes for generating the nonces (Uint8Array).\n * @returns An object containing the public and secret nonces.\n * @throws {Error} If the input is invalid, such as non array publicKey, secretKey, aggPublicKey.\n */\nfunction nonceGen(publicKey, secretKey, aggPublicKey = new Uint8Array(0), msg, extraIn = new Uint8Array(0), rand = (0, utils_js_2.randomBytes)(32)) {\n    (0, utils_js_2.abytes)(publicKey, PUBKEY_LEN);\n    abytesOptional(secretKey, 32);\n    (0, utils_js_2.abytes)(aggPublicKey, 0, 32);\n    abytesOptional(msg);\n    (0, utils_js_2.abytes)(extraIn);\n    (0, utils_js_2.abytes)(rand, 32);\n    if (secretKey !== undefined)\n        rand = aux(secretKey, rand);\n    const msgPrefixed = msg !== undefined\n        ? (0, utils_js_1.concatBytes)(new Uint8Array([1]), (0, utils_js_1.numberToBytesBE)(msg.length, 8), msg)\n        : new Uint8Array([0]);\n    const k1 = nonceHash(rand, publicKey, aggPublicKey, 0, msgPrefixed, extraIn);\n    const k2 = nonceHash(rand, publicKey, aggPublicKey, 1, msgPrefixed, extraIn);\n    return {\n        secret: SecretNonce.encode({ k1, k2, publicKey }),\n        public: PubNonce.encode({ R1: mulBase(k1), R2: mulBase(k2) }),\n    };\n}\n/**\n * Aggregates public nonces from multiple signers into a single aggregate nonce.\n * @param pubNonces An array of public nonces from each signer (Uint8Array). Each pubnonce is assumed to be 66 bytes (two 33byte parts).\n * @returns The aggregate nonce (Uint8Array).\n * @throws {Error} If the input is not an array or if any element is not a Uint8Array of the correct length.\n * @throws {InvalidContributionErr} If any of the public nonces are invalid and cannot be processed.\n */\nfunction nonceAggregate(pubNonces) {\n    abytesArray(pubNonces, 66);\n    let R1 = Point.ZERO;\n    let R2 = Point.ZERO;\n    for (let i = 0; i < pubNonces.length; i++) {\n        const pn = pubNonces[i];\n        try {\n            const { R1: R1n, R2: R2n } = PubNonce.decode(pn);\n            if (isZero(R1n) || isZero(R2n))\n                throw new Error('infinity point');\n            R1 = R1.add(R1n);\n            R2 = R2.add(R2n);\n        }\n        catch (error) {\n            throw new InvalidContributionErr(i, 'pubnonce');\n        }\n    }\n    return PubNonce.encode({ R1, R2 });\n}\n// Class allows us re-use pre-computed stuff\n// NOTE: it would be nice to aggregate nonce in construdctor, but there is test that passes already aggregated nonce here.\nclass Session {\n    /**\n     * Constructor for the Session class.\n     * It precomputes and stores values derived from the aggregate nonce, public keys,\n     * message, and optional tweaks, optimizing the signing process.\n     * @param aggNonce The aggregate nonce (Uint8Array) from all participants combined, must be 66 bytes.\n     * @param publicKeys An array of public keys (Uint8Array) from each participant, must be 33 bytes.\n     * @param msg The message (Uint8Array) to be signed.\n     * @param tweaks Optional array of tweaks (Uint8Array) to be applied to the aggregate public key, each must be 32 bytes. Defaults to [].\n     * @param isXonly Optional array of booleans indicating whether each tweak is an X-only tweak. Defaults to [].\n     * @throws {Error} If the input is invalid, such as wrong array sizes or lengths.\n     */\n    constructor(aggNonce, publicKeys, msg, tweaks = [], isXonly = []) {\n        abytesArray(publicKeys, 33);\n        abytesArray(tweaks, 32);\n        aXonly(isXonly);\n        (0, utils_js_2.abytes)(msg);\n        if (tweaks.length !== isXonly.length)\n            throw new Error('The tweaks and isXonly arrays must have the same length');\n        const { aggPublicKey, gAcc, tweakAcc } = keyAggregate(publicKeys, tweaks, isXonly);\n        const { R1, R2 } = PubNonce.decode(aggNonce);\n        this.publicKeys = publicKeys;\n        this.Q = aggPublicKey;\n        this.gAcc = gAcc;\n        this.tweakAcc = tweakAcc;\n        this.b = taggedInt('MuSig/noncecoef', aggNonce, pointToBytes(aggPublicKey), msg);\n        const R = R1.add(R2.multiply(this.b));\n        this.R = isZero(R) ? Point.BASE : R;\n        this.e = taggedInt('BIP0340/challenge', pointToBytes(this.R), pointToBytes(aggPublicKey), msg);\n        this.tweaks = tweaks;\n        this.isXonly = isXonly;\n        this.L = keyAggL(publicKeys);\n        this.secondKey = getSecondKey(publicKeys);\n    }\n    /**\n     * Calculates the key aggregation coefficient for a given point.\n     * @private\n     * @param P The point to calculate the coefficient for.\n     * @returns The key aggregation coefficient as a bigint.\n     * @throws {Error} If the provided public key is not included in the list of pubkeys.\n     */\n    getSessionKeyAggCoeff(P) {\n        const { publicKeys } = this;\n        const pk = P.toRawBytes(true);\n        const found = publicKeys.some((p) => (0, utils_js_1.equalBytes)(p, pk));\n        if (!found)\n            throw new Error(\"The signer's pubkey must be included in the list of pubkeys\");\n        return keyAggCoeffInternal(pk, this.secondKey, this.L);\n    }\n    partialSigVerifyInternal(partialSig, publicNonce, publicKey) {\n        const { Q, gAcc, b, R, e } = this;\n        const s = (0, utils_js_1.bytesToNumberBE)(partialSig);\n        if (s >= SECP_N)\n            return false;\n        const { R1, R2 } = PubNonce.decode(publicNonce);\n        const Re_s_ = R1.add(R2.multiply(b));\n        const Re_s = R.hasEvenY() ? Re_s_ : Re_s_.negate();\n        const P = Point.fromHex(publicKey);\n        const a = this.getSessionKeyAggCoeff(P);\n        const g = modN(evenScalar(Q, 1n) * gAcc);\n        const left = mulBase(s);\n        const right = Re_s.add(P.multiply(modN(e * a * g)));\n        return left.equals(right);\n    }\n    /**\n     * Generates a partial signature for a given message, secret nonce, secret key, and session context.\n     * @param secretNonce The secret nonce for this signing session (Uint8Array). MUST be securely erased after use.\n     * @param secret The secret key of the signer (Uint8Array).\n     * @param sessionCtx The session context containing all necessary information for signing.\n     * @param fastSign if set to true, the signature is created without checking validity.\n     * @returns The partial signature (Uint8Array).\n     * @throws {Error} If the input is invalid, such as wrong array sizes, invalid nonce or secret key.\n     */\n    sign(secretNonce, secret, fastSign = false) {\n        (0, utils_js_2.abytes)(secret, 32);\n        if (typeof fastSign !== 'boolean')\n            throw new Error('expected boolean');\n        const { Q, gAcc, b, R, e } = this;\n        const { k1: k1_, k2: k2_, publicKey: originalPk } = SecretNonce.decode(secretNonce);\n        // zero-out the first 64 bytes of secretNonce so it cannot be reused\n        // TODO: this was in reference implementation, but feels very broken. Modifying input arguments is pretty bad.\n        secretNonce.fill(0, 0, 64);\n        (0, utils_js_1.aInRange)('k1', k1_, 0n, SECP_N);\n        (0, utils_js_1.aInRange)('k2', k2_, 0n, SECP_N);\n        const k1 = evenScalar(R, k1_);\n        const k2 = evenScalar(R, k2_);\n        const d_ = (0, utils_js_1.bytesToNumberBE)(secret);\n        (0, utils_js_1.aInRange)('d_', d_, 1n, SECP_N);\n        const P = mulBase(d_);\n        const pk = P.toRawBytes(true);\n        if (!(0, utils_js_1.equalBytes)(pk, originalPk))\n            throw new Error('Public key does not match nonceGen argument');\n        const a = this.getSessionKeyAggCoeff(P);\n        const g = evenScalar(Q, 1n);\n        const d = modN(g * gAcc * d_);\n        const s = modN(k1 + b * k2 + e * a * d);\n        const partialSig = (0, utils_js_1.numberToBytesBE)(s, 32);\n        // Skip validation in fast-sign mode\n        if (!fastSign) {\n            const publicNonce = PubNonce.encode({\n                R1: mulBase(k1_),\n                R2: mulBase(k2_),\n            });\n            if (!this.partialSigVerifyInternal(partialSig, publicNonce, pk))\n                throw new Error('Partial signature verification failed');\n        }\n        return partialSig;\n    }\n    /**\n     * Verifies a partial signature against the aggregate public key and other session parameters.\n     * @param partialSig The partial signature to verify (Uint8Array).\n     * @param pubNonces An array of public nonces from each signer (Uint8Array).\n     * @param pubKeys An array of public keys from each signer (Uint8Array).\n     * @param tweaks An array of tweaks applied to the aggregate public key.\n     * @param isXonly An array of booleans indicating whether each tweak is an X-only tweak.\n     * @param msg The message that was signed (Uint8Array).\n     * @param i The index of the signer whose partial signature is being verified.\n     * @returns True if the partial signature is valid, false otherwise.\n     * @throws {Error} If the input is invalid, such as non array partialSig, pubNonces, pubKeys, tweaks.\n     */\n    partialSigVerify(partialSig, pubNonces, i) {\n        const { publicKeys, tweaks, isXonly } = this;\n        (0, utils_js_2.abytes)(partialSig, 32);\n        abytesArray(pubNonces, 66);\n        abytesArray(publicKeys, PUBKEY_LEN);\n        abytesArray(tweaks, 32);\n        aXonly(isXonly);\n        (0, utils_js_2.anumber)(i);\n        if (pubNonces.length !== publicKeys.length)\n            throw new Error('The pubNonces and publicKeys arrays must have the same length');\n        if (tweaks.length !== isXonly.length)\n            throw new Error('The tweaks and isXonly arrays must have the same length');\n        if (i >= pubNonces.length)\n            throw new Error('index outside of pubKeys/pubNonces');\n        return this.partialSigVerifyInternal(partialSig, pubNonces[i], publicKeys[i]);\n    }\n    /**\n     * Aggregates partial signatures from multiple signers into a single final signature.\n     * @param partialSigs An array of partial signatures from each signer (Uint8Array).\n     * @param sessionCtx The session context containing all necessary information for signing.\n     * @returns The final aggregate signature (Uint8Array).\n     * @throws {Error} If the input is invalid, such as wrong array sizes, invalid signature.\n     */\n    partialSigAgg(partialSigs) {\n        abytesArray(partialSigs, 32);\n        const { Q, tweakAcc, R, e } = this;\n        let s = 0n;\n        for (let i = 0; i < partialSigs.length; i++) {\n            const si = (0, utils_js_1.bytesToNumberBE)(partialSigs[i]);\n            if (si >= SECP_N)\n                throw new InvalidContributionErr(i, 'psig');\n            s = modN(s + si);\n        }\n        const g = evenScalar(Q, 1n);\n        s = modN(s + e * g * tweakAcc);\n        return (0, utils_js_1.concatBytes)(pointToBytes(R), (0, utils_js_1.numberToBytesBE)(s, 32));\n    }\n}\nexports.Session = Session;\nconst deterministicNonceHash = (secret, aggOtherNonce, aggPublicKey, msg, i) => taggedInt('MuSig/deterministic/nonce', secret, aggOtherNonce, aggPublicKey, (0, utils_js_1.numberToBytesBE)(msg.length, 8), msg, new Uint8Array([i]));\n/**\n * Generates a nonce pair and partial signature deterministically for a single signer.\n * @param secret The secret key of the signer (Uint8Array).\n * @param aggOtherNonce The aggregate public nonce of all other signers (Uint8Array).\n * @param publicKeys An array of all signers' public keys (Uint8Array).\n * @param tweaks An array of tweaks to apply to the aggregate public key.\n * @param isXonly An array of booleans indicating whether each tweak is an X-only tweak.\n * @param msg The message to be signed (Uint8Array).\n * @param rand Optional extra randomness (Uint8Array).\n * @returns An object containing the public nonce and partial signature.\n */\nfunction deterministicSign(secret, aggOtherNonce, publicKeys, msg, tweaks = [], isXonly = [], rand, fastSign = false) {\n    (0, utils_js_2.abytes)(secret, 32);\n    (0, utils_js_2.abytes)(aggOtherNonce, 66);\n    abytesArray(publicKeys, PUBKEY_LEN);\n    abytesArray(tweaks, 32);\n    (0, utils_js_2.abytes)(msg);\n    abytesOptional(rand);\n    const sk = rand !== undefined ? aux(secret, rand) : secret;\n    const aggPublicKey = keyAggExport(keyAggregate(publicKeys, tweaks, isXonly));\n    const k1 = deterministicNonceHash(sk, aggOtherNonce, aggPublicKey, msg, 0);\n    const k2 = deterministicNonceHash(sk, aggOtherNonce, aggPublicKey, msg, 1);\n    const R1 = mulBase(k1);\n    const R2 = mulBase(k2);\n    const publicNonce = PubNonce.encode({ R1, R2 });\n    const secretNonce = SecretNonce.encode({ k1, k2, publicKey: IndividualPubkey(secret) });\n    const aggNonce = nonceAggregate([publicNonce, aggOtherNonce]);\n    const session = new Session(aggNonce, publicKeys, msg, tweaks, isXonly);\n    const partialSig = session.sign(secretNonce, secret, fastSign);\n    return { publicNonce, partialSig };\n}\n//# sourceMappingURL=musig2.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@scure/btc-signer/musig2.js?\n}")},"./node_modules/@scure/btc-signer/payment.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._sortPubkeys = exports.p2tr_pk = exports.p2tr_ns = exports.tapLeafHash = exports.TAP_LEAF_VERSION = exports.p2ms = exports.p2wpkh = exports.p2wsh = exports.p2sh = exports.p2pkh = exports.p2pk = exports.OutScript = void 0;\nexports.checkScript = checkScript;\nexports.taprootListToTree = taprootListToTree;\nexports.p2tr = p2tr;\nexports.combinations = combinations;\nexports.p2tr_ms = p2tr_ms;\nexports.getAddress = getAddress;\nexports.multisig = multisig;\nexports.sortedMultisig = sortedMultisig;\nexports.WIF = WIF;\nexports.Address = Address;\nconst base_1 = __webpack_require__(/*! @scure/base */ \"./node_modules/@scure/base/lib/index.js\");\nconst P = __webpack_require__(/*! micro-packed */ \"./node_modules/micro-packed/lib/index.js\");\nconst psbt_ts_1 = __webpack_require__(/*! ./psbt.js */ \"./node_modules/@scure/btc-signer/psbt.js\");\nconst script_ts_1 = __webpack_require__(/*! ./script.js */ \"./node_modules/@scure/btc-signer/script.js\");\nconst u = __webpack_require__(/*! ./utils.js */ \"./node_modules/@scure/btc-signer/utils.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@scure/btc-signer/utils.js\");\nconst OutP2A = {\n    encode(from) {\n        if (from.length !== 2 || from[0] !== 1 || !u.isBytes(from[1]) || base_1.hex.encode(from[1]) !== '4e73')\n            return;\n        return { type: 'p2a', script: script_ts_1.Script.encode(from) };\n    },\n    decode: (to) => {\n        if (to.type !== 'p2a')\n            return;\n        return [1, base_1.hex.decode('4e73')];\n    },\n};\nfunction isValidPubkey(pub, type) {\n    try {\n        u.validatePubkey(pub, type);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\nconst OutPK = {\n    encode(from) {\n        if (from.length !== 2 ||\n            !u.isBytes(from[0]) ||\n            !isValidPubkey(from[0], u.PubT.ecdsa) ||\n            from[1] !== 'CHECKSIG')\n            return;\n        return { type: 'pk', pubkey: from[0] };\n    },\n    decode: (to) => (to.type === 'pk' ? [to.pubkey, 'CHECKSIG'] : undefined),\n};\nconst OutPKH = {\n    encode(from) {\n        if (from.length !== 5 || from[0] !== 'DUP' || from[1] !== 'HASH160' || !u.isBytes(from[2]))\n            return;\n        if (from[3] !== 'EQUALVERIFY' || from[4] !== 'CHECKSIG')\n            return;\n        return { type: 'pkh', hash: from[2] };\n    },\n    decode: (to) => to.type === 'pkh' ? ['DUP', 'HASH160', to.hash, 'EQUALVERIFY', 'CHECKSIG'] : undefined,\n};\nconst OutSH = {\n    encode(from) {\n        if (from.length !== 3 || from[0] !== 'HASH160' || !u.isBytes(from[1]) || from[2] !== 'EQUAL')\n            return;\n        return { type: 'sh', hash: from[1] };\n    },\n    decode: (to) => to.type === 'sh' ? ['HASH160', to.hash, 'EQUAL'] : undefined,\n};\nconst OutWSH = {\n    encode(from) {\n        if (from.length !== 2 || from[0] !== 0 || !u.isBytes(from[1]))\n            return;\n        if (from[1].length !== 32)\n            return;\n        return { type: 'wsh', hash: from[1] };\n    },\n    decode: (to) => (to.type === 'wsh' ? [0, to.hash] : undefined),\n};\nconst OutWPKH = {\n    encode(from) {\n        if (from.length !== 2 || from[0] !== 0 || !u.isBytes(from[1]))\n            return;\n        if (from[1].length !== 20)\n            return;\n        return { type: 'wpkh', hash: from[1] };\n    },\n    decode: (to) => (to.type === 'wpkh' ? [0, to.hash] : undefined),\n};\nconst OutMS = {\n    encode(from) {\n        const last = from.length - 1;\n        if (from[last] !== 'CHECKMULTISIG')\n            return;\n        const m = from[0];\n        const n = from[last - 1];\n        if (typeof m !== 'number' || typeof n !== 'number')\n            return;\n        const pubkeys = from.slice(1, -2);\n        if (n !== pubkeys.length)\n            return;\n        for (const pub of pubkeys)\n            if (!u.isBytes(pub))\n                return;\n        return { type: 'ms', m, pubkeys: pubkeys }; // we don't need n, since it is the same as pubkeys\n    },\n    // checkmultisig(n, ..pubkeys, m)\n    decode: (to) => to.type === 'ms' ? [to.m, ...to.pubkeys, to.pubkeys.length, 'CHECKMULTISIG'] : undefined,\n};\nconst OutTR = {\n    encode(from) {\n        if (from.length !== 2 || from[0] !== 1 || !u.isBytes(from[1]))\n            return;\n        return { type: 'tr', pubkey: from[1] };\n    },\n    decode: (to) => (to.type === 'tr' ? [1, to.pubkey] : undefined),\n};\nconst OutTRNS = {\n    encode(from) {\n        const last = from.length - 1;\n        if (from[last] !== 'CHECKSIG')\n            return;\n        const pubkeys = [];\n        // On error return, since it can be different script\n        for (let i = 0; i < last; i++) {\n            const elm = from[i];\n            if (i & 1) {\n                if (elm !== 'CHECKSIGVERIFY' || i === last - 1)\n                    return;\n                continue;\n            }\n            if (!u.isBytes(elm))\n                return;\n            pubkeys.push(elm);\n        }\n        return { type: 'tr_ns', pubkeys };\n    },\n    decode: (to) => {\n        if (to.type !== 'tr_ns')\n            return;\n        const out = [];\n        for (let i = 0; i < to.pubkeys.length - 1; i++)\n            out.push(to.pubkeys[i], 'CHECKSIGVERIFY');\n        out.push(to.pubkeys[to.pubkeys.length - 1], 'CHECKSIG');\n        return out;\n    },\n};\nconst OutTRMS = {\n    encode(from) {\n        const last = from.length - 1;\n        if (from[last] !== 'NUMEQUAL' || from[1] !== 'CHECKSIG')\n            return;\n        const pubkeys = [];\n        const m = (0, script_ts_1.OpToNum)(from[last - 1]);\n        if (typeof m !== 'number')\n            return;\n        for (let i = 0; i < last - 1; i++) {\n            const elm = from[i];\n            if (i & 1) {\n                if (elm !== (i === 1 ? 'CHECKSIG' : 'CHECKSIGADD'))\n                    throw new Error('OutScript.encode/tr_ms: wrong element');\n                continue;\n            }\n            if (!u.isBytes(elm))\n                throw new Error('OutScript.encode/tr_ms: wrong key element');\n            pubkeys.push(elm);\n        }\n        return { type: 'tr_ms', pubkeys, m };\n    },\n    decode: (to) => {\n        if (to.type !== 'tr_ms')\n            return;\n        const out = [to.pubkeys[0], 'CHECKSIG'];\n        for (let i = 1; i < to.pubkeys.length; i++)\n            out.push(to.pubkeys[i], 'CHECKSIGADD');\n        out.push(to.m, 'NUMEQUAL');\n        return out;\n    },\n};\nconst OutUnknown = {\n    encode(from) {\n        return { type: 'unknown', script: script_ts_1.Script.encode(from) };\n    },\n    decode: (to) => to.type === 'unknown' ? script_ts_1.Script.decode(to.script) : undefined,\n};\n// /Payments\nconst OutScripts = [\n    OutP2A,\n    OutPK,\n    OutPKH,\n    OutSH,\n    OutWSH,\n    OutWPKH,\n    OutMS,\n    OutTR,\n    OutTRNS,\n    OutTRMS,\n    OutUnknown,\n];\n// TODO: we can support user supplied output scripts now\n// - addOutScript\n// - removeOutScript\n// - We can do that as log we modify array in-place\n// - Actually is very hard, since there is sign/finalize logic\nconst _OutScript = P.apply(script_ts_1.Script, P.coders.match(OutScripts));\n// We can validate this once, because of packed & coders\nexports.OutScript = P.validate(_OutScript, (i) => {\n    if (i.type === 'pk' && !isValidPubkey(i.pubkey, u.PubT.ecdsa))\n        throw new Error('OutScript/pk: wrong key');\n    if ((i.type === 'pkh' || i.type === 'sh' || i.type === 'wpkh') &&\n        (!u.isBytes(i.hash) || i.hash.length !== 20))\n        throw new Error(`OutScript/${i.type}: wrong hash`);\n    if (i.type === 'wsh' && (!u.isBytes(i.hash) || i.hash.length !== 32))\n        throw new Error(`OutScript/wsh: wrong hash`);\n    if (i.type === 'tr' && (!u.isBytes(i.pubkey) || !isValidPubkey(i.pubkey, u.PubT.schnorr)))\n        throw new Error('OutScript/tr: wrong taproot public key');\n    if (i.type === 'ms' || i.type === 'tr_ns' || i.type === 'tr_ms')\n        if (!Array.isArray(i.pubkeys))\n            throw new Error('OutScript/multisig: wrong pubkeys array');\n    if (i.type === 'ms') {\n        const n = i.pubkeys.length;\n        for (const p of i.pubkeys)\n            if (!isValidPubkey(p, u.PubT.ecdsa))\n                throw new Error('OutScript/multisig: wrong pubkey');\n        if (i.m <= 0 || n > 16 || i.m > n)\n            throw new Error('OutScript/multisig: invalid params');\n    }\n    if (i.type === 'tr_ns' || i.type === 'tr_ms') {\n        for (const p of i.pubkeys)\n            if (!isValidPubkey(p, u.PubT.schnorr))\n                throw new Error(`OutScript/${i.type}: wrong pubkey`);\n    }\n    if (i.type === 'tr_ms') {\n        const n = i.pubkeys.length;\n        if (i.m <= 0 || n > 999 || i.m > n)\n            throw new Error('OutScript/tr_ms: invalid params');\n    }\n    return i;\n});\n// Basic sanity check for scripts\nfunction checkWSH(s, witnessScript) {\n    if (!u.equalBytes(s.hash, u.sha256(witnessScript)))\n        throw new Error('checkScript: wsh wrong witnessScript hash');\n    const w = exports.OutScript.decode(witnessScript);\n    if (w.type === 'tr' || w.type === 'tr_ns' || w.type === 'tr_ms')\n        throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2SH`);\n    if (w.type === 'wpkh' || w.type === 'sh')\n        throw new Error(`checkScript: P2${w.type} cannot be wrapped in P2WSH`);\n}\nfunction checkScript(script, redeemScript, witnessScript) {\n    if (script) {\n        const s = exports.OutScript.decode(script);\n        // ms||pk maybe work, but there will be no address, hard to spend\n        if (s.type === 'tr_ns' || s.type === 'tr_ms' || s.type === 'ms' || s.type == 'pk')\n            throw new Error(`checkScript: non-wrapped ${s.type}`);\n        if (s.type === 'sh' && redeemScript) {\n            if (!u.equalBytes(s.hash, u.hash160(redeemScript)))\n                throw new Error('checkScript: sh wrong redeemScript hash');\n            const r = exports.OutScript.decode(redeemScript);\n            if (r.type === 'tr' || r.type === 'tr_ns' || r.type === 'tr_ms')\n                throw new Error(`checkScript: P2${r.type} cannot be wrapped in P2SH`);\n            // Not sure if this unspendable, but we cannot represent this via PSBT\n            if (r.type === 'sh')\n                throw new Error('checkScript: P2SH cannot be wrapped in P2SH');\n        }\n        if (s.type === 'wsh' && witnessScript)\n            checkWSH(s, witnessScript);\n    }\n    if (redeemScript) {\n        const r = exports.OutScript.decode(redeemScript);\n        if (r.type === 'wsh' && witnessScript)\n            checkWSH(r, witnessScript);\n    }\n}\nfunction uniqPubkey(pubkeys) {\n    const map = {};\n    for (const pub of pubkeys) {\n        const key = base_1.hex.encode(pub);\n        if (map[key])\n            throw new Error(`Multisig: non-uniq pubkey: ${pubkeys.map(base_1.hex.encode)}`);\n        map[key] = true;\n    }\n}\nconst p2pk = (pubkey, _network = utils_ts_1.NETWORK) => {\n    // network is unused\n    if (!isValidPubkey(pubkey, u.PubT.ecdsa))\n        throw new Error('P2PK: invalid publicKey');\n    return { type: 'pk', script: exports.OutScript.encode({ type: 'pk', pubkey }) };\n};\nexports.p2pk = p2pk;\nconst p2pkh = (publicKey, network = utils_ts_1.NETWORK) => {\n    if (!isValidPubkey(publicKey, u.PubT.ecdsa))\n        throw new Error('P2PKH: invalid publicKey');\n    const hash = u.hash160(publicKey);\n    return {\n        type: 'pkh',\n        script: exports.OutScript.encode({ type: 'pkh', hash }),\n        address: Address(network).encode({ type: 'pkh', hash }),\n        hash,\n    };\n};\nexports.p2pkh = p2pkh;\nconst p2sh = (child, network = utils_ts_1.NETWORK) => {\n    // It is already tested inside noble-hashes and checkScript\n    const cs = child.script;\n    if (!u.isBytes(cs))\n        throw new Error(`Wrong script: ${typeof child.script}, expected Uint8Array`);\n    const hash = u.hash160(cs);\n    const script = exports.OutScript.encode({ type: 'sh', hash });\n    checkScript(script, cs, child.witnessScript);\n    if (child.witnessScript) {\n        return {\n            type: 'sh',\n            redeemScript: cs,\n            script: exports.OutScript.encode({ type: 'sh', hash }),\n            address: Address(network).encode({ type: 'sh', hash }),\n            hash,\n            witnessScript: child.witnessScript,\n        };\n    }\n    else {\n        return {\n            type: 'sh',\n            redeemScript: cs,\n            script: exports.OutScript.encode({ type: 'sh', hash }),\n            address: Address(network).encode({ type: 'sh', hash }),\n            hash,\n        };\n    }\n};\nexports.p2sh = p2sh;\nconst p2wsh = (child, network = utils_ts_1.NETWORK) => {\n    const cs = child.script;\n    if (!u.isBytes(cs))\n        throw new Error(`Wrong script: ${typeof cs}, expected Uint8Array`);\n    const hash = u.sha256(cs);\n    const script = exports.OutScript.encode({ type: 'wsh', hash });\n    checkScript(script, undefined, cs);\n    return {\n        type: 'wsh',\n        witnessScript: cs,\n        script: exports.OutScript.encode({ type: 'wsh', hash }),\n        address: Address(network).encode({ type: 'wsh', hash }),\n        hash,\n    };\n};\nexports.p2wsh = p2wsh;\nconst p2wpkh = (publicKey, network = utils_ts_1.NETWORK) => {\n    if (!isValidPubkey(publicKey, u.PubT.ecdsa))\n        throw new Error('P2WPKH: invalid publicKey');\n    if (publicKey.length === 65)\n        throw new Error('P2WPKH: uncompressed public key');\n    const hash = u.hash160(publicKey);\n    return {\n        type: 'wpkh',\n        script: exports.OutScript.encode({ type: 'wpkh', hash }),\n        address: Address(network).encode({ type: 'wpkh', hash }),\n        hash,\n    };\n};\nexports.p2wpkh = p2wpkh;\nconst p2ms = (m, pubkeys, allowSamePubkeys = false) => {\n    if (!allowSamePubkeys)\n        uniqPubkey(pubkeys);\n    return {\n        type: 'ms',\n        script: exports.OutScript.encode({ type: 'ms', pubkeys, m }),\n    };\n};\nexports.p2ms = p2ms;\nfunction checkTaprootScript(script, internalPubKey, allowUnknownOutputs = false, customScripts) {\n    const out = exports.OutScript.decode(script);\n    if (out.type === 'unknown') {\n        // NOTE: this check should be before allowUnknownOutputs, otherwise it will\n        // disable custom. All custom scripts for taproot should have prefix 'tr_'\n        if (customScripts) {\n            const cs = P.apply(script_ts_1.Script, P.coders.match(customScripts));\n            const c = cs.decode(script);\n            if (c !== undefined) {\n                if (typeof c.type !== 'string' || !c.type.startsWith('tr_'))\n                    throw new Error(`P2TR: invalid custom type=${c.type}`);\n                return;\n            }\n        }\n        if (allowUnknownOutputs)\n            return;\n    }\n    if (!['tr_ns', 'tr_ms'].includes(out.type))\n        throw new Error(`P2TR: invalid leaf script=${out.type}`);\n    const outms = out;\n    if (!allowUnknownOutputs && outms.pubkeys) {\n        for (const p of outms.pubkeys) {\n            if (u.equalBytes(p, u.TAPROOT_UNSPENDABLE_KEY))\n                throw new Error('Unspendable taproot key in leaf script');\n            // It's likely a mistake at this point:\n            // 1. p2tr(A, p2tr_ns(2, [A, B])) == p2tr(A, p2tr_pk(B)) (A or B key)\n            // but will take more space and fees.\n            // 2. For multi-sig p2tr(A, p2tr_ns(2, [A, B, C])) it's probably a security issue:\n            // User creates 2 of 3 multisig of keys [A, B, C],\n            // but key A always can spend whole output without signatures from other keys.\n            // p2tr(A, p2tr_ns(2, [B, C, D])) is ok: A or (B and C) or (B and D) or (C and D)\n            if (u.equalBytes(p, internalPubKey)) {\n                throw new Error('Using P2TR with leaf script with same key as internal key is not supported');\n            }\n        }\n    }\n}\n// Helper for generating binary tree from list, with weights\nfunction taprootListToTree(taprootList) {\n    // Clone input in order to not corrupt it\n    const lst = Array.from(taprootList);\n    // We have at least 2 elements => can create branch\n    while (lst.length >= 2) {\n        // Sort: elements with smallest weight are in the end of queue\n        lst.sort((a, b) => (b.weight || 1) - (a.weight || 1));\n        const b = lst.pop();\n        const a = lst.pop();\n        const weight = (a?.weight || 1) + (b?.weight || 1);\n        lst.push({\n            weight,\n            // Unwrap children array\n            // TODO: Very hard to remove any here\n            childs: [a?.childs || a, b?.childs || b],\n        });\n    }\n    // At this point there is always 1 element in lst\n    const last = lst[0];\n    return (last?.childs || last);\n}\nfunction taprootAddPath(tree, path = []) {\n    if (!tree)\n        throw new Error(`taprootAddPath: empty tree`);\n    if (tree.type === 'leaf')\n        return { ...tree, path };\n    if (tree.type !== 'branch')\n        throw new Error(`taprootAddPath: wrong type=${tree}`);\n    return {\n        ...tree,\n        path,\n        // Left element has right hash in path and otherwise\n        left: taprootAddPath(tree.left, [tree.right.hash, ...path]),\n        right: taprootAddPath(tree.right, [tree.left.hash, ...path]),\n    };\n}\nfunction taprootWalkTree(tree) {\n    if (!tree)\n        throw new Error(`taprootAddPath: empty tree`);\n    if (tree.type === 'leaf')\n        return [tree];\n    if (tree.type !== 'branch')\n        throw new Error(`taprootWalkTree: wrong type=${tree}`);\n    return [...taprootWalkTree(tree.left), ...taprootWalkTree(tree.right)];\n}\nfunction taprootHashTree(tree, internalPubKey, allowUnknownOutputs = false, customScripts) {\n    if (!tree)\n        throw new Error('taprootHashTree: empty tree');\n    if (Array.isArray(tree) && tree.length === 1)\n        tree = tree[0];\n    // Terminal node (leaf)\n    if (!Array.isArray(tree)) {\n        const { leafVersion: version, script: leafScript } = tree;\n        // Earliest tree walk where we can validate tapScripts\n        if (tree.tapLeafScript || (tree.tapMerkleRoot && !u.equalBytes(tree.tapMerkleRoot, P.EMPTY)))\n            throw new Error('P2TR: tapRoot leafScript cannot have tree');\n        const script = typeof leafScript === 'string' ? base_1.hex.decode(leafScript) : leafScript;\n        if (!u.isBytes(script))\n            throw new Error(`checkScript: wrong script type=${script}`);\n        checkTaprootScript(script, internalPubKey, allowUnknownOutputs, customScripts);\n        return {\n            type: 'leaf',\n            version,\n            script,\n            hash: (0, exports.tapLeafHash)(script, version),\n        };\n    }\n    // If tree / branch is not binary tree, convert it\n    if (tree.length !== 2)\n        tree = taprootListToTree(tree);\n    if (tree.length !== 2)\n        throw new Error('hashTree: non binary tree!');\n    // branch\n    // Both nodes should exist\n    const left = taprootHashTree(tree[0], internalPubKey, allowUnknownOutputs, customScripts);\n    const right = taprootHashTree(tree[1], internalPubKey, allowUnknownOutputs, customScripts);\n    // We cannot swap left/right here, since it will change structure of tree\n    let [lH, rH] = [left.hash, right.hash];\n    if (u.compareBytes(rH, lH) === -1)\n        [lH, rH] = [rH, lH];\n    return { type: 'branch', left, right, hash: u.tagSchnorr('TapBranch', lH, rH) };\n}\nexports.TAP_LEAF_VERSION = 0xc0;\nconst tapLeafHash = (script, version = exports.TAP_LEAF_VERSION) => u.tagSchnorr('TapLeaf', new Uint8Array([version]), script_ts_1.VarBytes.encode(script));\nexports.tapLeafHash = tapLeafHash;\nfunction p2tr(internalPubKey, tree, network = utils_ts_1.NETWORK, allowUnknownOutputs = false, customScripts) {\n    // Unspendable\n    if (!internalPubKey && !tree)\n        throw new Error('p2tr: should have pubKey or scriptTree (or both)');\n    const pubKey = typeof internalPubKey === 'string'\n        ? base_1.hex.decode(internalPubKey)\n        : internalPubKey || u.TAPROOT_UNSPENDABLE_KEY;\n    if (!isValidPubkey(pubKey, u.PubT.schnorr))\n        throw new Error('p2tr: non-schnorr pubkey');\n    if (tree) {\n        let hashedTree = taprootAddPath(taprootHashTree(tree, pubKey, allowUnknownOutputs, customScripts));\n        const tapMerkleRoot = hashedTree.hash;\n        const [tweakedPubkey, parity] = u.taprootTweakPubkey(pubKey, tapMerkleRoot);\n        const leaves = taprootWalkTree(hashedTree).map((l) => ({\n            ...l,\n            controlBlock: psbt_ts_1.TaprootControlBlock.encode({\n                version: (l.version || exports.TAP_LEAF_VERSION) + parity,\n                internalKey: pubKey,\n                merklePath: l.path,\n            }),\n        }));\n        return {\n            type: 'tr',\n            script: exports.OutScript.encode({ type: 'tr', pubkey: tweakedPubkey }),\n            address: Address(network).encode({ type: 'tr', pubkey: tweakedPubkey }),\n            // For tests\n            tweakedPubkey,\n            // PSBT stuff\n            tapInternalKey: pubKey,\n            leaves,\n            tapLeafScript: leaves.map((l) => [\n                psbt_ts_1.TaprootControlBlock.decode(l.controlBlock),\n                u.concatBytes(l.script, new Uint8Array([l.version || exports.TAP_LEAF_VERSION])),\n            ]),\n            tapMerkleRoot,\n        };\n    }\n    else {\n        const tweakedPubkey = u.taprootTweakPubkey(pubKey, P.EMPTY)[0];\n        return {\n            type: 'tr',\n            script: exports.OutScript.encode({ type: 'tr', pubkey: tweakedPubkey }),\n            address: Address(network).encode({ type: 'tr', pubkey: tweakedPubkey }),\n            // For tests\n            tweakedPubkey,\n            // PSBT stuff\n            tapInternalKey: pubKey,\n        };\n    }\n}\n// Returns all combinations of size M from lst\nfunction combinations(m, list) {\n    const res = [];\n    if (!Array.isArray(list))\n        throw new Error('combinations: lst arg should be array');\n    const n = list.length;\n    if (m > n)\n        throw new Error('combinations: m > lst.length, no combinations possible');\n    /*\n    Basically works as M nested loops like:\n    for (;idx[0]<lst.length;idx[0]++) for (idx[1]=idx[0]+1;idx[1]<lst.length;idx[1]++)\n    but since we cannot create nested loops dynamically, we unroll it to a single loop\n    */\n    const idx = Array.from({ length: m }, (_, i) => i);\n    const last = idx.length - 1;\n    main: for (;;) {\n        res.push(idx.map((i) => list[i]));\n        idx[last] += 1;\n        let i = last;\n        // Propagate increment\n        // idx[i] cannot be bigger than n-m+i, otherwise last elements in right part will overflow\n        for (; i >= 0 && idx[i] > n - m + i; i--) {\n            idx[i] = 0;\n            // Overflow in idx[0], break\n            if (i === 0)\n                break main;\n            idx[i - 1] += 1;\n        }\n        // Propagate: idx[i+1] = idx[idx]+1\n        for (i += 1; i < idx.length; i++)\n            idx[i] = idx[i - 1] + 1;\n    }\n    return res;\n}\nconst p2tr_ns = (m, pubkeys, allowSamePubkeys = false) => {\n    if (!allowSamePubkeys)\n        uniqPubkey(pubkeys);\n    return combinations(m, pubkeys).map((i) => ({\n        type: 'tr_ns',\n        script: exports.OutScript.encode({ type: 'tr_ns', pubkeys: i }),\n    }));\n};\nexports.p2tr_ns = p2tr_ns;\nconst p2tr_pk = (pubkey) => (0, exports.p2tr_ns)(1, [pubkey], undefined)[0];\nexports.p2tr_pk = p2tr_pk;\nfunction p2tr_ms(m, pubkeys, allowSamePubkeys = false) {\n    if (!allowSamePubkeys)\n        uniqPubkey(pubkeys);\n    return {\n        type: 'tr_ms',\n        script: exports.OutScript.encode({ type: 'tr_ms', pubkeys, m }),\n    };\n}\n// Simple pubkey address, without complex scripts\nfunction getAddress(type, privKey, network = utils_ts_1.NETWORK) {\n    if (type === 'tr') {\n        return p2tr(u.pubSchnorr(privKey), undefined, network).address;\n    }\n    const pubKey = u.pubECDSA(privKey);\n    if (type === 'pkh')\n        return (0, exports.p2pkh)(pubKey, network).address;\n    if (type === 'wpkh')\n        return (0, exports.p2wpkh)(pubKey, network).address;\n    throw new Error(`getAddress: unknown type=${type}`);\n}\nconst _sortPubkeys = (pubkeys) => Array.from(pubkeys).sort(u.compareBytes);\nexports._sortPubkeys = _sortPubkeys;\nfunction multisig(m, pubkeys, sorted = false, witness = false, network = utils_ts_1.NETWORK) {\n    const ms = (0, exports.p2ms)(m, sorted ? (0, exports._sortPubkeys)(pubkeys) : pubkeys);\n    return witness ? (0, exports.p2wsh)(ms, network) : (0, exports.p2sh)(ms, network);\n}\nfunction sortedMultisig(m, pubkeys, witness = false, network = utils_ts_1.NETWORK) {\n    return multisig(m, pubkeys, true, witness, network);\n}\nconst base58check = (0, base_1.createBase58check)(u.sha256);\nfunction validateWitness(version, data) {\n    if (data.length < 2 || data.length > 40)\n        throw new Error('Witness: invalid length');\n    if (version > 16)\n        throw new Error('Witness: invalid version');\n    if (version === 0 && !(data.length === 20 || data.length === 32))\n        throw new Error('Witness: invalid length for version');\n}\nfunction programToWitness(version, data, network = utils_ts_1.NETWORK) {\n    validateWitness(version, data);\n    const coder = version === 0 ? base_1.bech32 : base_1.bech32m;\n    return coder.encode(network.bech32, [version].concat(coder.toWords(data)));\n}\nfunction formatKey(hashed, prefix) {\n    return base58check.encode(u.concatBytes(Uint8Array.from(prefix), hashed));\n}\nfunction WIF(network = utils_ts_1.NETWORK) {\n    return {\n        encode(privKey) {\n            const compressed = u.concatBytes(privKey, new Uint8Array([0x01]));\n            return formatKey(compressed.subarray(0, 33), [network.wif]);\n        },\n        decode(wif) {\n            let parsed = base58check.decode(wif);\n            if (parsed[0] !== network.wif)\n                throw new Error('Wrong WIF prefix');\n            parsed = parsed.subarray(1);\n            // Check what it is. Compressed flag?\n            if (parsed.length !== 33)\n                throw new Error('Wrong WIF length');\n            if (parsed[32] !== 0x01)\n                throw new Error('Wrong WIF postfix');\n            return parsed.subarray(0, -1);\n        },\n    };\n}\n// Returns OutType, which can be used to create outscript\nfunction Address(network = utils_ts_1.NETWORK) {\n    return {\n        encode(from) {\n            const { type } = from;\n            if (type === 'wpkh')\n                return programToWitness(0, from.hash, network);\n            else if (type === 'wsh')\n                return programToWitness(0, from.hash, network);\n            else if (type === 'tr')\n                return programToWitness(1, from.pubkey, network);\n            else if (type === 'pkh')\n                return formatKey(from.hash, [network.pubKeyHash]);\n            else if (type === 'sh')\n                return formatKey(from.hash, [network.scriptHash]);\n            throw new Error(`Unknown address type=${type}`);\n        },\n        decode(address) {\n            if (address.length < 14 || address.length > 74)\n                throw new Error('Invalid address length');\n            // Bech32\n            if (network.bech32 && address.toLowerCase().startsWith(`${network.bech32}1`)) {\n                let res;\n                try {\n                    res = base_1.bech32.decode(address);\n                    if (res.words[0] !== 0)\n                        throw new Error(`bech32: wrong version=${res.words[0]}`);\n                }\n                catch (_) {\n                    // Starting from version 1 it is decoded as bech32m\n                    res = base_1.bech32m.decode(address);\n                    if (res.words[0] === 0)\n                        throw new Error(`bech32m: wrong version=${res.words[0]}`);\n                }\n                if (res.prefix !== network.bech32)\n                    throw new Error(`wrong bech32 prefix=${res.prefix}`);\n                const [version, ...program] = res.words;\n                const data = base_1.bech32.fromWords(program);\n                validateWitness(version, data);\n                if (version === 0 && data.length === 32)\n                    return { type: 'wsh', hash: data };\n                else if (version === 0 && data.length === 20)\n                    return { type: 'wpkh', hash: data };\n                else if (version === 1 && data.length === 32)\n                    return { type: 'tr', pubkey: data };\n                else\n                    throw new Error('Unknown witness program');\n            }\n            const data = base58check.decode(address);\n            if (data.length !== 21)\n                throw new Error('Invalid base58 address');\n            // Pay To Public Key Hash\n            if (data[0] === network.pubKeyHash) {\n                return { type: 'pkh', hash: data.slice(1) };\n            }\n            else if (data[0] === network.scriptHash) {\n                return {\n                    type: 'sh',\n                    hash: data.slice(1),\n                };\n            }\n            throw new Error(`Invalid address prefix=${data[0]}`);\n        },\n    };\n}\n//# sourceMappingURL=payment.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@scure/btc-signer/payment.js?\n}")},"./node_modules/@scure/btc-signer/psbt.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RawPSBTV2 = exports.RawPSBTV0 = exports._DebugPSBT = exports._RawPSBTV2 = exports._RawPSBTV0 = exports.PSBTOutputCoder = exports.PSBTInputCoder = exports.PSBTOutputUnsignedKeys = exports.PSBTOutput = exports.PSBTInputUnsignedKeys = exports.PSBTInputFinalKeys = exports.PSBTInput = exports.PSBTGlobal = exports.TaprootControlBlock = void 0;\nexports.cleanPSBTFields = cleanPSBTFields;\nexports.mergeKeyMap = mergeKeyMap;\nconst base_1 = __webpack_require__(/*! @scure/base */ \"./node_modules/@scure/base/lib/index.js\");\nconst P = __webpack_require__(/*! micro-packed */ \"./node_modules/micro-packed/lib/index.js\");\nconst script_ts_1 = __webpack_require__(/*! ./script.js */ \"./node_modules/@scure/btc-signer/script.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@scure/btc-signer/utils.js\");\n// PSBT BIP174, BIP370, BIP371\n// Can be 33 or 64 bytes\nconst PubKeyECDSA = P.validate(P.bytes(null), (pub) => (0, utils_ts_1.validatePubkey)(pub, utils_ts_1.PubT.ecdsa));\nconst PubKeySchnorr = P.validate(P.bytes(32), (pub) => (0, utils_ts_1.validatePubkey)(pub, utils_ts_1.PubT.schnorr));\nconst SignatureSchnorr = P.validate(P.bytes(null), (sig) => {\n    if (sig.length !== 64 && sig.length !== 65)\n        throw new Error('Schnorr signature should be 64 or 65 bytes long');\n    return sig;\n});\nconst BIP32Der = P.struct({\n    fingerprint: P.U32BE,\n    path: P.array(null, P.U32LE),\n});\nconst TaprootBIP32Der = P.struct({\n    hashes: P.array(script_ts_1.CompactSizeLen, P.bytes(32)),\n    der: BIP32Der,\n});\n// The 78 byte serialized extended public key as defined by BIP 32.\nconst GlobalXPUB = P.bytes(78);\nconst tapScriptSigKey = P.struct({ pubKey: PubKeySchnorr, leafHash: P.bytes(32) });\n// Complex structure for PSBT fields\n// <control byte with leaf version and parity bit> <internal key p> <C> <E> <AB>\nconst _TaprootControlBlock = P.struct({\n    version: P.U8, // With parity :(\n    internalKey: P.bytes(32),\n    merklePath: P.array(null, P.bytes(32)),\n});\nexports.TaprootControlBlock = P.validate(_TaprootControlBlock, (cb) => {\n    if (cb.merklePath.length > 128)\n        throw new Error('TaprootControlBlock: merklePath should be of length 0..128 (inclusive)');\n    return cb;\n});\n// {<8-bit uint depth> <8-bit uint leaf version> <compact size uint scriptlen> <bytes script>}*\nconst tapTree = P.array(null, P.struct({\n    depth: P.U8,\n    version: P.U8,\n    script: script_ts_1.VarBytes,\n}));\nconst BytesInf = P.bytes(null); // Bytes will conflict with Bytes type\nconst Bytes20 = P.bytes(20);\nconst Bytes32 = P.bytes(32);\n// versionsRequiringExclusing = !versionsAllowsInclusion (as set)\n// {name: [tag, keyCoder, valueCoder, versionsRequiringInclusion, versionsRequiringExclusing, versionsAllowsInclusion, silentIgnore]}\n// SilentIgnore: we use some v2 fields for v1 representation too, so we just clean them before serialize\n// Tables from BIP-0174 (https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki)\n// prettier-ignore\nexports.PSBTGlobal = {\n    unsignedTx: [0x00, false, script_ts_1.RawOldTx, [0], [0], false],\n    xpub: [0x01, GlobalXPUB, BIP32Der, [], [0, 2], false],\n    txVersion: [0x02, false, P.U32LE, [2], [2], false],\n    fallbackLocktime: [0x03, false, P.U32LE, [], [2], false],\n    inputCount: [0x04, false, script_ts_1.CompactSizeLen, [2], [2], false],\n    outputCount: [0x05, false, script_ts_1.CompactSizeLen, [2], [2], false],\n    txModifiable: [0x06, false, P.U8, [], [2], false], // TODO: bitfield\n    version: [0xfb, false, P.U32LE, [], [0, 2], false],\n    proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false],\n};\n// prettier-ignore\nexports.PSBTInput = {\n    nonWitnessUtxo: [0x00, false, script_ts_1.RawTx, [], [0, 2], false],\n    witnessUtxo: [0x01, false, script_ts_1.RawOutput, [], [0, 2], false],\n    partialSig: [0x02, PubKeyECDSA, BytesInf, [], [0, 2], false],\n    sighashType: [0x03, false, P.U32LE, [], [0, 2], false],\n    redeemScript: [0x04, false, BytesInf, [], [0, 2], false],\n    witnessScript: [0x05, false, BytesInf, [], [0, 2], false],\n    bip32Derivation: [0x06, PubKeyECDSA, BIP32Der, [], [0, 2], false],\n    finalScriptSig: [0x07, false, BytesInf, [], [0, 2], false],\n    finalScriptWitness: [0x08, false, script_ts_1.RawWitness, [], [0, 2], false],\n    porCommitment: [0x09, false, BytesInf, [], [0, 2], false],\n    ripemd160: [0x0a, Bytes20, BytesInf, [], [0, 2], false],\n    sha256: [0x0b, Bytes32, BytesInf, [], [0, 2], false],\n    hash160: [0x0c, Bytes20, BytesInf, [], [0, 2], false],\n    hash256: [0x0d, Bytes32, BytesInf, [], [0, 2], false],\n    txid: [0x0e, false, Bytes32, [2], [2], true],\n    index: [0x0f, false, P.U32LE, [2], [2], true],\n    sequence: [0x10, false, P.U32LE, [], [2], true],\n    requiredTimeLocktime: [0x11, false, P.U32LE, [], [2], false],\n    requiredHeightLocktime: [0x12, false, P.U32LE, [], [2], false],\n    tapKeySig: [0x13, false, SignatureSchnorr, [], [0, 2], false],\n    tapScriptSig: [0x14, tapScriptSigKey, SignatureSchnorr, [], [0, 2], false],\n    tapLeafScript: [0x15, exports.TaprootControlBlock, BytesInf, [], [0, 2], false],\n    tapBip32Derivation: [0x16, Bytes32, TaprootBIP32Der, [], [0, 2], false],\n    tapInternalKey: [0x17, false, PubKeySchnorr, [], [0, 2], false],\n    tapMerkleRoot: [0x18, false, Bytes32, [], [0, 2], false],\n    proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false],\n};\n// All other keys removed when finalizing\nexports.PSBTInputFinalKeys = [\n    'txid',\n    'sequence',\n    'index',\n    'witnessUtxo',\n    'nonWitnessUtxo',\n    'finalScriptSig',\n    'finalScriptWitness',\n    'unknown',\n];\n// Can be modified even on signed input\nexports.PSBTInputUnsignedKeys = [\n    'partialSig',\n    'finalScriptSig',\n    'finalScriptWitness',\n    'tapKeySig',\n    'tapScriptSig',\n];\n// prettier-ignore\nexports.PSBTOutput = {\n    redeemScript: [0x00, false, BytesInf, [], [0, 2], false],\n    witnessScript: [0x01, false, BytesInf, [], [0, 2], false],\n    bip32Derivation: [0x02, PubKeyECDSA, BIP32Der, [], [0, 2], false],\n    amount: [0x03, false, P.I64LE, [2], [2], true],\n    script: [0x04, false, BytesInf, [2], [2], true],\n    tapInternalKey: [0x05, false, PubKeySchnorr, [], [0, 2], false],\n    tapTree: [0x06, false, tapTree, [], [0, 2], false],\n    tapBip32Derivation: [0x07, PubKeySchnorr, TaprootBIP32Der, [], [0, 2], false],\n    proprietary: [0xfc, BytesInf, BytesInf, [], [0, 2], false],\n};\n// Can be modified even on signed input\nexports.PSBTOutputUnsignedKeys = [];\nconst PSBTKeyPair = P.array(P.NULL, P.struct({\n    //  <key> := <keylen> <keytype> <keydata> WHERE keylen = len(keytype)+len(keydata)\n    key: P.prefix(script_ts_1.CompactSizeLen, P.struct({ type: script_ts_1.CompactSizeLen, key: P.bytes(null) })),\n    //  <value> := <valuelen> <valuedata>\n    value: P.bytes(script_ts_1.CompactSizeLen),\n}));\nfunction PSBTKeyInfo(info) {\n    const [type, kc, vc, reqInc, allowInc, silentIgnore] = info;\n    return { type, kc, vc, reqInc, allowInc, silentIgnore };\n}\nconst PSBTUnknownKey = P.struct({ type: script_ts_1.CompactSizeLen, key: P.bytes(null) });\n// Key cannot be 'unknown', value coder cannot be array for elements with empty key\nfunction PSBTKeyMap(psbtEnum) {\n    // -> Record<type, [keyName, ...coders]>\n    const byType = {};\n    for (const k in psbtEnum) {\n        const [num, kc, vc] = psbtEnum[k];\n        byType[num] = [k, kc, vc];\n    }\n    return P.wrap({\n        encodeStream: (w, value) => {\n            let out = [];\n            // Because we use order of psbtEnum, keymap is sorted here\n            for (const name in psbtEnum) {\n                const val = value[name];\n                if (val === undefined)\n                    continue;\n                const [type, kc, vc] = psbtEnum[name];\n                if (!kc) {\n                    out.push({ key: { type, key: P.EMPTY }, value: vc.encode(val) });\n                }\n                else {\n                    // Low level interface, returns keys as is (with duplicates). Useful for debug\n                    const kv = val.map(([k, v]) => [\n                        kc.encode(k),\n                        vc.encode(v),\n                    ]);\n                    // sort by keys\n                    kv.sort((a, b) => (0, utils_ts_1.compareBytes)(a[0], b[0]));\n                    for (const [key, value] of kv)\n                        out.push({ key: { key, type }, value });\n                }\n            }\n            if (value.unknown) {\n                value.unknown.sort((a, b) => (0, utils_ts_1.compareBytes)(a[0].key, b[0].key));\n                for (const [k, v] of value.unknown)\n                    out.push({ key: k, value: v });\n            }\n            PSBTKeyPair.encodeStream(w, out);\n        },\n        decodeStream: (r) => {\n            const raw = PSBTKeyPair.decodeStream(r);\n            const out = {};\n            const noKey = {};\n            for (const elm of raw) {\n                let name = 'unknown';\n                let key = elm.key.key;\n                let value = elm.value;\n                if (byType[elm.key.type]) {\n                    const [_name, kc, vc] = byType[elm.key.type];\n                    name = _name;\n                    if (!kc && key.length) {\n                        throw new Error(`PSBT: Non-empty key for ${name} (key=${base_1.hex.encode(key)} value=${base_1.hex.encode(value)}`);\n                    }\n                    key = kc ? kc.decode(key) : undefined;\n                    value = vc.decode(value);\n                    if (!kc) {\n                        if (out[name])\n                            throw new Error(`PSBT: Same keys: ${name} (key=${key} value=${value})`);\n                        out[name] = value;\n                        noKey[name] = true;\n                        continue;\n                    }\n                }\n                else {\n                    // For unknown: add key type inside key\n                    key = { type: elm.key.type, key: elm.key.key };\n                }\n                // Only keyed elements at this point\n                if (noKey[name])\n                    throw new Error(`PSBT: Key type with empty key and no key=${name} val=${value}`);\n                if (!out[name])\n                    out[name] = [];\n                out[name].push([key, value]);\n            }\n            return out;\n        },\n    });\n}\nexports.PSBTInputCoder = P.validate(PSBTKeyMap(exports.PSBTInput), (i) => {\n    if (i.finalScriptWitness && !i.finalScriptWitness.length)\n        throw new Error('validateInput: empty finalScriptWitness');\n    //if (i.finalScriptSig && !i.finalScriptSig.length) throw new Error('validateInput: empty finalScriptSig');\n    if (i.partialSig && !i.partialSig.length)\n        throw new Error('Empty partialSig');\n    if (i.partialSig)\n        for (const [k] of i.partialSig)\n            (0, utils_ts_1.validatePubkey)(k, utils_ts_1.PubT.ecdsa);\n    if (i.bip32Derivation)\n        for (const [k] of i.bip32Derivation)\n            (0, utils_ts_1.validatePubkey)(k, utils_ts_1.PubT.ecdsa);\n    // Locktime = unsigned little endian integer greater than or equal to 500000000 representing\n    if (i.requiredTimeLocktime !== undefined && i.requiredTimeLocktime < 500000000)\n        throw new Error(`validateInput: wrong timeLocktime=${i.requiredTimeLocktime}`);\n    // unsigned little endian integer greater than 0 and less than 500000000\n    if (i.requiredHeightLocktime !== undefined &&\n        (i.requiredHeightLocktime <= 0 || i.requiredHeightLocktime >= 500000000))\n        throw new Error(`validateInput: wrong heighLocktime=${i.requiredHeightLocktime}`);\n    if (i.tapLeafScript) {\n        // tap leaf version appears here twice: in control block and at the end of script\n        for (const [k, v] of i.tapLeafScript) {\n            if ((k.version & 254) !== v[v.length - 1])\n                throw new Error('validateInput: tapLeafScript version mimatch');\n            if (v[v.length - 1] & 1)\n                throw new Error('validateInput: tapLeafScript version has parity bit!');\n        }\n    }\n    return i;\n});\nexports.PSBTOutputCoder = P.validate(PSBTKeyMap(exports.PSBTOutput), (o) => {\n    if (o.bip32Derivation)\n        for (const [k] of o.bip32Derivation)\n            (0, utils_ts_1.validatePubkey)(k, utils_ts_1.PubT.ecdsa);\n    return o;\n});\nconst PSBTGlobalCoder = P.validate(PSBTKeyMap(exports.PSBTGlobal), (g) => {\n    const version = g.version || 0;\n    if (version === 0) {\n        if (!g.unsignedTx)\n            throw new Error('PSBTv0: missing unsignedTx');\n        for (const inp of g.unsignedTx.inputs)\n            if (inp.finalScriptSig && inp.finalScriptSig.length)\n                throw new Error('PSBTv0: input scriptSig found in unsignedTx');\n    }\n    return g;\n});\nexports._RawPSBTV0 = P.struct({\n    magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n    global: PSBTGlobalCoder,\n    inputs: P.array('global/unsignedTx/inputs/length', exports.PSBTInputCoder),\n    outputs: P.array(null, exports.PSBTOutputCoder),\n});\nexports._RawPSBTV2 = P.struct({\n    magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n    global: PSBTGlobalCoder,\n    inputs: P.array('global/inputCount', exports.PSBTInputCoder),\n    outputs: P.array('global/outputCount', exports.PSBTOutputCoder),\n});\nexports._DebugPSBT = P.struct({\n    magic: P.magic(P.string(new Uint8Array([0xff])), 'psbt'),\n    items: P.array(null, P.apply(P.array(P.NULL, P.tuple([P.hex(script_ts_1.CompactSizeLen), P.bytes(script_ts_1.CompactSize)])), P.coders.dict())),\n});\nfunction validatePSBTFields(version, info, lst) {\n    for (const k in lst) {\n        if (k === 'unknown')\n            continue;\n        if (!info[k])\n            continue;\n        const { allowInc } = PSBTKeyInfo(info[k]);\n        if (!allowInc.includes(version))\n            throw new Error(`PSBTv${version}: field ${k} is not allowed`);\n    }\n    for (const k in info) {\n        const { reqInc } = PSBTKeyInfo(info[k]);\n        if (reqInc.includes(version) && lst[k] === undefined)\n            throw new Error(`PSBTv${version}: missing required field ${k}`);\n    }\n}\nfunction cleanPSBTFields(version, info, lst) {\n    const out = {};\n    for (const _k in lst) {\n        const k = _k;\n        if (k !== 'unknown') {\n            if (!info[k])\n                continue;\n            const { allowInc, silentIgnore } = PSBTKeyInfo(info[k]);\n            if (!allowInc.includes(version)) {\n                if (silentIgnore)\n                    continue;\n                throw new Error(`Failed to serialize in PSBTv${version}: ${k} but versions allows inclusion=${allowInc}`);\n            }\n        }\n        out[k] = lst[k];\n    }\n    return out;\n}\nfunction validatePSBT(tx) {\n    const version = (tx && tx.global && tx.global.version) || 0;\n    validatePSBTFields(version, exports.PSBTGlobal, tx.global);\n    for (const i of tx.inputs)\n        validatePSBTFields(version, exports.PSBTInput, i);\n    for (const o of tx.outputs)\n        validatePSBTFields(version, exports.PSBTOutput, o);\n    // We allow only one empty element at the end of map (compat with bitcoinjs-lib bug)\n    const inputCount = !version ? tx.global.unsignedTx.inputs.length : tx.global.inputCount;\n    if (tx.inputs.length < inputCount)\n        throw new Error('Not enough inputs');\n    const inputsLeft = tx.inputs.slice(inputCount);\n    if (inputsLeft.length > 1 || (inputsLeft.length && Object.keys(inputsLeft[0]).length))\n        throw new Error(`Unexpected inputs left in tx=${inputsLeft}`);\n    // Same for inputs\n    const outputCount = !version ? tx.global.unsignedTx.outputs.length : tx.global.outputCount;\n    if (tx.outputs.length < outputCount)\n        throw new Error('Not outputs inputs');\n    const outputsLeft = tx.outputs.slice(outputCount);\n    if (outputsLeft.length > 1 || (outputsLeft.length && Object.keys(outputsLeft[0]).length))\n        throw new Error(`Unexpected outputs left in tx=${outputsLeft}`);\n    return tx;\n}\nfunction mergeKeyMap(psbtEnum, val, cur, allowedFields, allowUnknown) {\n    const res = { ...cur, ...val };\n    // All arguments can be provided as hex\n    for (const k in psbtEnum) {\n        const key = k;\n        const [_, kC, vC] = psbtEnum[key];\n        const cannotChange = allowedFields && !allowedFields.includes(k);\n        if (val[k] === undefined && k in val) {\n            if (cannotChange)\n                throw new Error(`Cannot remove signed field=${k}`);\n            delete res[k];\n        }\n        else if (kC) {\n            const oldKV = (cur && cur[k] ? cur[k] : []);\n            let newKV = val[key];\n            if (newKV) {\n                if (!Array.isArray(newKV))\n                    throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n                // Decode hex in k-v\n                newKV = newKV.map((val) => {\n                    if (val.length !== 2)\n                        throw new Error(`keyMap(${k}): KV pairs should be [k, v][]`);\n                    return [\n                        typeof val[0] === 'string' ? kC.decode(base_1.hex.decode(val[0])) : val[0],\n                        typeof val[1] === 'string' ? vC.decode(base_1.hex.decode(val[1])) : val[1],\n                    ];\n                });\n                const map = {};\n                const add = (kStr, k, v) => {\n                    if (map[kStr] === undefined) {\n                        map[kStr] = [k, v];\n                        return;\n                    }\n                    const oldVal = base_1.hex.encode(vC.encode(map[kStr][1]));\n                    const newVal = base_1.hex.encode(vC.encode(v));\n                    if (oldVal !== newVal)\n                        throw new Error(`keyMap(${key}): same key=${kStr} oldVal=${oldVal} newVal=${newVal}`);\n                };\n                for (const [k, v] of oldKV) {\n                    const kStr = base_1.hex.encode(kC.encode(k));\n                    add(kStr, k, v);\n                }\n                for (const [k, v] of newKV) {\n                    const kStr = base_1.hex.encode(kC.encode(k));\n                    // undefined removes previous value\n                    if (v === undefined) {\n                        if (cannotChange)\n                            throw new Error(`Cannot remove signed field=${key}/${k}`);\n                        delete map[kStr];\n                    }\n                    else\n                        add(kStr, k, v);\n                }\n                res[key] = Object.values(map);\n            }\n        }\n        else if (typeof res[k] === 'string') {\n            res[k] = vC.decode(base_1.hex.decode(res[k]));\n        }\n        else if (cannotChange && k in val && cur && cur[k] !== undefined) {\n            if (!(0, utils_ts_1.equalBytes)(vC.encode(val[k]), vC.encode(cur[k])))\n                throw new Error(`Cannot change signed field=${k}`);\n        }\n    }\n    // Remove unknown keys except the \"unknown\" array if allowUnknown is true\n    for (const k in res) {\n        if (!psbtEnum[k]) {\n            if (allowUnknown && k === 'unknown')\n                continue;\n            delete res[k];\n        }\n    }\n    return res;\n}\nexports.RawPSBTV0 = P.validate(exports._RawPSBTV0, validatePSBT);\nexports.RawPSBTV2 = P.validate(exports._RawPSBTV2, validatePSBT);\n//# sourceMappingURL=psbt.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@scure/btc-signer/psbt.js?\n}")},"./node_modules/@scure/btc-signer/script.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.RawOldTx = exports.RawTx = exports.RawOutput = exports.RawInput = exports.BTCArray = exports.RawWitness = exports.VarBytes = exports.CompactSizeLen = exports.CompactSize = exports.Script = exports.OP = exports.MAX_SCRIPT_BYTE_LENGTH = void 0;\nexports.ScriptNum = ScriptNum;\nexports.OpToNum = OpToNum;\nconst P = __webpack_require__(/*! micro-packed */ "./node_modules/micro-packed/lib/index.js");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@scure/btc-signer/utils.js");\nexports.MAX_SCRIPT_BYTE_LENGTH = 520;\n// prettier-ignore\nvar OP;\n(function (OP) {\n    OP[OP["OP_0"] = 0] = "OP_0";\n    OP[OP["PUSHDATA1"] = 76] = "PUSHDATA1";\n    OP[OP["PUSHDATA2"] = 77] = "PUSHDATA2";\n    OP[OP["PUSHDATA4"] = 78] = "PUSHDATA4";\n    OP[OP["1NEGATE"] = 79] = "1NEGATE";\n    OP[OP["RESERVED"] = 80] = "RESERVED";\n    OP[OP["OP_1"] = 81] = "OP_1";\n    OP[OP["OP_2"] = 82] = "OP_2";\n    OP[OP["OP_3"] = 83] = "OP_3";\n    OP[OP["OP_4"] = 84] = "OP_4";\n    OP[OP["OP_5"] = 85] = "OP_5";\n    OP[OP["OP_6"] = 86] = "OP_6";\n    OP[OP["OP_7"] = 87] = "OP_7";\n    OP[OP["OP_8"] = 88] = "OP_8";\n    OP[OP["OP_9"] = 89] = "OP_9";\n    OP[OP["OP_10"] = 90] = "OP_10";\n    OP[OP["OP_11"] = 91] = "OP_11";\n    OP[OP["OP_12"] = 92] = "OP_12";\n    OP[OP["OP_13"] = 93] = "OP_13";\n    OP[OP["OP_14"] = 94] = "OP_14";\n    OP[OP["OP_15"] = 95] = "OP_15";\n    OP[OP["OP_16"] = 96] = "OP_16";\n    // Control\n    OP[OP["NOP"] = 97] = "NOP";\n    OP[OP["VER"] = 98] = "VER";\n    OP[OP["IF"] = 99] = "IF";\n    OP[OP["NOTIF"] = 100] = "NOTIF";\n    OP[OP["VERIF"] = 101] = "VERIF";\n    OP[OP["VERNOTIF"] = 102] = "VERNOTIF";\n    OP[OP["ELSE"] = 103] = "ELSE";\n    OP[OP["ENDIF"] = 104] = "ENDIF";\n    OP[OP["VERIFY"] = 105] = "VERIFY";\n    OP[OP["RETURN"] = 106] = "RETURN";\n    // Stack\n    OP[OP["TOALTSTACK"] = 107] = "TOALTSTACK";\n    OP[OP["FROMALTSTACK"] = 108] = "FROMALTSTACK";\n    OP[OP["2DROP"] = 109] = "2DROP";\n    OP[OP["2DUP"] = 110] = "2DUP";\n    OP[OP["3DUP"] = 111] = "3DUP";\n    OP[OP["2OVER"] = 112] = "2OVER";\n    OP[OP["2ROT"] = 113] = "2ROT";\n    OP[OP["2SWAP"] = 114] = "2SWAP";\n    OP[OP["IFDUP"] = 115] = "IFDUP";\n    OP[OP["DEPTH"] = 116] = "DEPTH";\n    OP[OP["DROP"] = 117] = "DROP";\n    OP[OP["DUP"] = 118] = "DUP";\n    OP[OP["NIP"] = 119] = "NIP";\n    OP[OP["OVER"] = 120] = "OVER";\n    OP[OP["PICK"] = 121] = "PICK";\n    OP[OP["ROLL"] = 122] = "ROLL";\n    OP[OP["ROT"] = 123] = "ROT";\n    OP[OP["SWAP"] = 124] = "SWAP";\n    OP[OP["TUCK"] = 125] = "TUCK";\n    // Splice\n    OP[OP["CAT"] = 126] = "CAT";\n    OP[OP["SUBSTR"] = 127] = "SUBSTR";\n    OP[OP["LEFT"] = 128] = "LEFT";\n    OP[OP["RIGHT"] = 129] = "RIGHT";\n    OP[OP["SIZE"] = 130] = "SIZE";\n    // Boolean logic\n    OP[OP["INVERT"] = 131] = "INVERT";\n    OP[OP["AND"] = 132] = "AND";\n    OP[OP["OR"] = 133] = "OR";\n    OP[OP["XOR"] = 134] = "XOR";\n    OP[OP["EQUAL"] = 135] = "EQUAL";\n    OP[OP["EQUALVERIFY"] = 136] = "EQUALVERIFY";\n    OP[OP["RESERVED1"] = 137] = "RESERVED1";\n    OP[OP["RESERVED2"] = 138] = "RESERVED2";\n    // Numbers\n    OP[OP["1ADD"] = 139] = "1ADD";\n    OP[OP["1SUB"] = 140] = "1SUB";\n    OP[OP["2MUL"] = 141] = "2MUL";\n    OP[OP["2DIV"] = 142] = "2DIV";\n    OP[OP["NEGATE"] = 143] = "NEGATE";\n    OP[OP["ABS"] = 144] = "ABS";\n    OP[OP["NOT"] = 145] = "NOT";\n    OP[OP["0NOTEQUAL"] = 146] = "0NOTEQUAL";\n    OP[OP["ADD"] = 147] = "ADD";\n    OP[OP["SUB"] = 148] = "SUB";\n    OP[OP["MUL"] = 149] = "MUL";\n    OP[OP["DIV"] = 150] = "DIV";\n    OP[OP["MOD"] = 151] = "MOD";\n    OP[OP["LSHIFT"] = 152] = "LSHIFT";\n    OP[OP["RSHIFT"] = 153] = "RSHIFT";\n    OP[OP["BOOLAND"] = 154] = "BOOLAND";\n    OP[OP["BOOLOR"] = 155] = "BOOLOR";\n    OP[OP["NUMEQUAL"] = 156] = "NUMEQUAL";\n    OP[OP["NUMEQUALVERIFY"] = 157] = "NUMEQUALVERIFY";\n    OP[OP["NUMNOTEQUAL"] = 158] = "NUMNOTEQUAL";\n    OP[OP["LESSTHAN"] = 159] = "LESSTHAN";\n    OP[OP["GREATERTHAN"] = 160] = "GREATERTHAN";\n    OP[OP["LESSTHANOREQUAL"] = 161] = "LESSTHANOREQUAL";\n    OP[OP["GREATERTHANOREQUAL"] = 162] = "GREATERTHANOREQUAL";\n    OP[OP["MIN"] = 163] = "MIN";\n    OP[OP["MAX"] = 164] = "MAX";\n    OP[OP["WITHIN"] = 165] = "WITHIN";\n    // Crypto\n    OP[OP["RIPEMD160"] = 166] = "RIPEMD160";\n    OP[OP["SHA1"] = 167] = "SHA1";\n    OP[OP["SHA256"] = 168] = "SHA256";\n    OP[OP["HASH160"] = 169] = "HASH160";\n    OP[OP["HASH256"] = 170] = "HASH256";\n    OP[OP["CODESEPARATOR"] = 171] = "CODESEPARATOR";\n    OP[OP["CHECKSIG"] = 172] = "CHECKSIG";\n    OP[OP["CHECKSIGVERIFY"] = 173] = "CHECKSIGVERIFY";\n    OP[OP["CHECKMULTISIG"] = 174] = "CHECKMULTISIG";\n    OP[OP["CHECKMULTISIGVERIFY"] = 175] = "CHECKMULTISIGVERIFY";\n    // Expansion\n    OP[OP["NOP1"] = 176] = "NOP1";\n    OP[OP["CHECKLOCKTIMEVERIFY"] = 177] = "CHECKLOCKTIMEVERIFY";\n    OP[OP["CHECKSEQUENCEVERIFY"] = 178] = "CHECKSEQUENCEVERIFY";\n    OP[OP["NOP4"] = 179] = "NOP4";\n    OP[OP["NOP5"] = 180] = "NOP5";\n    OP[OP["NOP6"] = 181] = "NOP6";\n    OP[OP["NOP7"] = 182] = "NOP7";\n    OP[OP["NOP8"] = 183] = "NOP8";\n    OP[OP["NOP9"] = 184] = "NOP9";\n    OP[OP["NOP10"] = 185] = "NOP10";\n    // BIP 342\n    OP[OP["CHECKSIGADD"] = 186] = "CHECKSIGADD";\n    // Invalid\n    OP[OP["INVALID"] = 255] = "INVALID";\n})(OP || (exports.OP = OP = {}));\n// We can encode almost any number as ScriptNum, however, parsing will be a problem\n// since we can\'t know if buffer is a number or something else.\nfunction ScriptNum(bytesLimit = 6, forceMinimal = false) {\n    return P.wrap({\n        encodeStream: (w, value) => {\n            if (value === 0n)\n                return;\n            const neg = value < 0;\n            const val = BigInt(value);\n            const nums = [];\n            for (let abs = neg ? -val : val; abs; abs >>= 8n)\n                nums.push(Number(abs & 0xffn));\n            if (nums[nums.length - 1] >= 0x80)\n                nums.push(neg ? 0x80 : 0);\n            else if (neg)\n                nums[nums.length - 1] |= 0x80;\n            w.bytes(new Uint8Array(nums));\n        },\n        decodeStream: (r) => {\n            const len = r.leftBytes;\n            if (len > bytesLimit)\n                throw new Error(`ScriptNum: number (${len}) bigger than limit=${bytesLimit}`);\n            if (len === 0)\n                return 0n;\n            if (forceMinimal) {\n                const data = r.bytes(len, true);\n                // MSB is zero (without sign bit) -> not minimally encoded\n                if ((data[data.length - 1] & 0x7f) === 0) {\n                    // exception\n                    if (len <= 1 || (data[data.length - 2] & 0x80) === 0)\n                        throw new Error(\'Non-minimally encoded ScriptNum\');\n                }\n            }\n            let last = 0;\n            let res = 0n;\n            for (let i = 0; i < len; ++i) {\n                last = r.byte();\n                res |= BigInt(last) << (8n * BigInt(i));\n            }\n            if (last >= 0x80) {\n                res &= (2n ** BigInt(len * 8) - 1n) >> 1n;\n                res = -res;\n            }\n            return res;\n        },\n    });\n}\nfunction OpToNum(op, bytesLimit = 4, forceMinimal = true) {\n    if (typeof op === \'number\')\n        return op;\n    if ((0, utils_ts_1.isBytes)(op)) {\n        try {\n            const val = ScriptNum(bytesLimit, forceMinimal).decode(op);\n            if (val > Number.MAX_SAFE_INTEGER)\n                return;\n            return Number(val);\n        }\n        catch (e) {\n            return;\n        }\n    }\n    return;\n}\n// Converts script bytes to parsed script\n// 5221030000000000000000000000000000000000000000000000000000000000000001210300000000000000000000000000000000000000000000000000000000000000022103000000000000000000000000000000000000000000000000000000000000000353ae\n// =>\n// OP_2\n//   030000000000000000000000000000000000000000000000000000000000000001\n//   030000000000000000000000000000000000000000000000000000000000000002\n//   030000000000000000000000000000000000000000000000000000000000000003\n//   OP_3\n//   CHECKMULTISIG\nexports.Script = P.wrap({\n    encodeStream: (w, value) => {\n        for (let o of value) {\n            if (typeof o === \'string\') {\n                if (OP[o] === undefined)\n                    throw new Error(`Unknown opcode=${o}`);\n                w.byte(OP[o]);\n                continue;\n            }\n            else if (typeof o === \'number\') {\n                if (o === 0x00) {\n                    w.byte(0x00);\n                    continue;\n                }\n                else if (1 <= o && o <= 16) {\n                    w.byte(OP.OP_1 - 1 + o);\n                    continue;\n                }\n            }\n            // Encode big numbers\n            if (typeof o === \'number\')\n                o = ScriptNum().encode(BigInt(o));\n            if (!(0, utils_ts_1.isBytes)(o))\n                throw new Error(`Wrong Script OP=${o} (${typeof o})`);\n            // Bytes\n            const len = o.length;\n            if (len < OP.PUSHDATA1)\n                w.byte(len);\n            else if (len <= 0xff) {\n                w.byte(OP.PUSHDATA1);\n                w.byte(len);\n            }\n            else if (len <= 0xffff) {\n                w.byte(OP.PUSHDATA2);\n                w.bytes(P.U16LE.encode(len));\n            }\n            else {\n                w.byte(OP.PUSHDATA4);\n                w.bytes(P.U32LE.encode(len));\n            }\n            w.bytes(o);\n        }\n    },\n    decodeStream: (r) => {\n        const out = [];\n        while (!r.isEnd()) {\n            const cur = r.byte();\n            // if 0 < cur < 78\n            if (OP.OP_0 < cur && cur <= OP.PUSHDATA4) {\n                let len;\n                if (cur < OP.PUSHDATA1)\n                    len = cur;\n                else if (cur === OP.PUSHDATA1)\n                    len = P.U8.decodeStream(r);\n                else if (cur === OP.PUSHDATA2)\n                    len = P.U16LE.decodeStream(r);\n                else if (cur === OP.PUSHDATA4)\n                    len = P.U32LE.decodeStream(r);\n                else\n                    throw new Error(\'Should be not possible\');\n                out.push(r.bytes(len));\n            }\n            else if (cur === 0x00) {\n                out.push(0);\n            }\n            else if (OP.OP_1 <= cur && cur <= OP.OP_16) {\n                out.push(cur - (OP.OP_1 - 1));\n            }\n            else {\n                const op = OP[cur];\n                if (op === undefined)\n                    throw new Error(`Unknown opcode=${cur.toString(16)}`);\n                out.push(op);\n            }\n        }\n        return out;\n    },\n});\n// BTC specific variable length integer encoding\n// https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\nconst CSLimits = {\n    0xfd: [0xfd, 2, 253n, 65535n],\n    0xfe: [0xfe, 4, 65536n, 4294967295n],\n    0xff: [0xff, 8, 4294967296n, 18446744073709551615n],\n};\nexports.CompactSize = P.wrap({\n    encodeStream: (w, value) => {\n        if (typeof value === \'number\')\n            value = BigInt(value);\n        if (0n <= value && value <= 252n)\n            return w.byte(Number(value));\n        for (const [flag, bytes, start, stop] of Object.values(CSLimits)) {\n            if (start > value || value > stop)\n                continue;\n            w.byte(flag);\n            for (let i = 0; i < bytes; i++)\n                w.byte(Number((value >> (8n * BigInt(i))) & 0xffn));\n            return;\n        }\n        throw w.err(`VarInt too big: ${value}`);\n    },\n    decodeStream: (r) => {\n        const b0 = r.byte();\n        if (b0 <= 0xfc)\n            return BigInt(b0);\n        const [_, bytes, start] = CSLimits[b0];\n        let num = 0n;\n        for (let i = 0; i < bytes; i++)\n            num |= BigInt(r.byte()) << (8n * BigInt(i));\n        if (num < start)\n            throw r.err(`Wrong CompactSize(${8 * bytes})`);\n        return num;\n    },\n});\n// Same thing, but in number instead of bigint. Checks for safe integer inside\nexports.CompactSizeLen = P.apply(exports.CompactSize, P.coders.numberBigint);\n// ui8a of size <CompactSize>\nexports.VarBytes = P.bytes(exports.CompactSize);\n// SegWit v0 stack of witness buffers\nexports.RawWitness = P.array(exports.CompactSizeLen, exports.VarBytes);\n// Array of size <CompactSize>\nconst BTCArray = (t) => P.array(exports.CompactSize, t);\nexports.BTCArray = BTCArray;\nexports.RawInput = P.struct({\n    txid: P.bytes(32, true), // hash(prev_tx),\n    index: P.U32LE, // output number of previous tx\n    finalScriptSig: exports.VarBytes, // btc merges input and output script, executes it. If ok = tx passes\n    sequence: P.U32LE, // ?\n});\nexports.RawOutput = P.struct({ amount: P.U64LE, script: exports.VarBytes });\n// https://en.bitcoin.it/wiki/Protocol_documentation#tx\nconst _RawTx = P.struct({\n    version: P.I32LE,\n    segwitFlag: P.flag(new Uint8Array([0x00, 0x01])),\n    inputs: (0, exports.BTCArray)(exports.RawInput),\n    outputs: (0, exports.BTCArray)(exports.RawOutput),\n    witnesses: P.flagged(\'segwitFlag\', P.array(\'inputs/length\', exports.RawWitness)),\n    // < 500000000\tBlock number at which this transaction is unlocked\n    // >= 500000000\tUNIX timestamp at which this transaction is unlocked\n    // Handled as part of PSBTv2\n    lockTime: P.U32LE,\n});\nfunction validateRawTx(tx) {\n    if (tx.segwitFlag && tx.witnesses && !tx.witnesses.length)\n        throw new Error(\'Segwit flag with empty witnesses array\');\n    return tx;\n}\nexports.RawTx = P.validate(_RawTx, validateRawTx);\n// Pre-SegWit serialization format (for PSBTv0)\nexports.RawOldTx = P.struct({\n    version: P.I32LE,\n    inputs: (0, exports.BTCArray)(exports.RawInput),\n    outputs: (0, exports.BTCArray)(exports.RawOutput),\n    lockTime: P.U32LE,\n});\n//# sourceMappingURL=script.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@scure/btc-signer/script.js?\n}')},"./node_modules/@scure/btc-signer/transaction.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transaction = exports.SigHash = exports.SignatureHash = exports.def = exports.Decimal = exports.DEFAULT_SEQUENCE = exports.DEFAULT_LOCKTIME = exports.DEFAULT_VERSION = exports.PRECISION = exports.toVsize = void 0;\nexports.cloneDeep = cloneDeep;\nexports.inputBeforeSign = inputBeforeSign;\nexports.getPrevOut = getPrevOut;\nexports.normalizeInput = normalizeInput;\nexports.getInputType = getInputType;\nexports.PSBTCombine = PSBTCombine;\nexports.bip32Path = bip32Path;\nconst base_1 = __webpack_require__(/*! @scure/base */ \"./node_modules/@scure/base/lib/index.js\");\nconst P = __webpack_require__(/*! micro-packed */ \"./node_modules/micro-packed/lib/index.js\");\nconst payment_ts_1 = __webpack_require__(/*! ./payment.js */ \"./node_modules/@scure/btc-signer/payment.js\");\nconst psbt = __webpack_require__(/*! ./psbt.js */ \"./node_modules/@scure/btc-signer/psbt.js\");\nconst script_ts_1 = __webpack_require__(/*! ./script.js */ \"./node_modules/@scure/btc-signer/script.js\");\nconst u = __webpack_require__(/*! ./utils.js */ \"./node_modules/@scure/btc-signer/utils.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@scure/btc-signer/utils.js\");\nconst EMPTY32 = new Uint8Array(32);\nconst EMPTY_OUTPUT = {\n    amount: 0xffffffffffffffffn,\n    script: P.EMPTY,\n};\nconst toVsize = (weight) => Math.ceil(weight / 4);\nexports.toVsize = toVsize;\nexports.PRECISION = 8;\nexports.DEFAULT_VERSION = 2;\nexports.DEFAULT_LOCKTIME = 0;\nexports.DEFAULT_SEQUENCE = 4294967295;\nexports.Decimal = P.coders.decimal(exports.PRECISION);\n// Same as value || def, but doesn't overwrites zero ('0', 0, 0n, etc)\nconst def = (value, def) => (value === undefined ? def : value);\nexports.def = def;\nfunction cloneDeep(obj) {\n    if (Array.isArray(obj))\n        return obj.map((i) => cloneDeep(i));\n    // slice of nodejs Buffer doesn't copy\n    else if ((0, utils_ts_1.isBytes)(obj))\n        return Uint8Array.from(obj);\n    // immutable\n    else if (['number', 'bigint', 'boolean', 'string', 'undefined'].includes(typeof obj))\n        return obj;\n    // null is object\n    else if (obj === null)\n        return obj;\n    // should be last, so it won't catch other types\n    else if (typeof obj === 'object') {\n        return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, cloneDeep(v)]));\n    }\n    throw new Error(`cloneDeep: unknown type=${obj} (${typeof obj})`);\n}\n/**\n * Internal, exported only for backwards-compat. Use `SigHash` instead.\n * @deprecated\n */\nvar SignatureHash;\n(function (SignatureHash) {\n    SignatureHash[SignatureHash[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    SignatureHash[SignatureHash[\"ALL\"] = 1] = \"ALL\";\n    SignatureHash[SignatureHash[\"NONE\"] = 2] = \"NONE\";\n    SignatureHash[SignatureHash[\"SINGLE\"] = 3] = \"SINGLE\";\n    SignatureHash[SignatureHash[\"ANYONECANPAY\"] = 128] = \"ANYONECANPAY\";\n})(SignatureHash || (exports.SignatureHash = SignatureHash = {}));\nvar SigHash;\n(function (SigHash) {\n    SigHash[SigHash[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    SigHash[SigHash[\"ALL\"] = 1] = \"ALL\";\n    SigHash[SigHash[\"NONE\"] = 2] = \"NONE\";\n    SigHash[SigHash[\"SINGLE\"] = 3] = \"SINGLE\";\n    SigHash[SigHash[\"DEFAULT_ANYONECANPAY\"] = 128] = \"DEFAULT_ANYONECANPAY\";\n    SigHash[SigHash[\"ALL_ANYONECANPAY\"] = 129] = \"ALL_ANYONECANPAY\";\n    SigHash[SigHash[\"NONE_ANYONECANPAY\"] = 130] = \"NONE_ANYONECANPAY\";\n    SigHash[SigHash[\"SINGLE_ANYONECANPAY\"] = 131] = \"SINGLE_ANYONECANPAY\";\n})(SigHash || (exports.SigHash = SigHash = {}));\nfunction getTaprootKeys(privKey, pubKey, internalKey, merkleRoot = P.EMPTY) {\n    if ((0, utils_ts_1.equalBytes)(internalKey, pubKey)) {\n        privKey = u.taprootTweakPrivKey(privKey, merkleRoot);\n        pubKey = u.pubSchnorr(privKey);\n    }\n    return { privKey, pubKey };\n}\n// Force check amount/script\nfunction outputBeforeSign(i) {\n    if (i.script === undefined || i.amount === undefined)\n        throw new Error('Transaction/output: script and amount required');\n    return { script: i.script, amount: i.amount };\n}\n// Force check index/txid/sequence\nfunction inputBeforeSign(i) {\n    if (i.txid === undefined || i.index === undefined)\n        throw new Error('Transaction/input: txid and index required');\n    return {\n        txid: i.txid,\n        index: i.index,\n        sequence: (0, exports.def)(i.sequence, exports.DEFAULT_SEQUENCE),\n        finalScriptSig: (0, exports.def)(i.finalScriptSig, P.EMPTY),\n    };\n}\nfunction cleanFinalInput(i) {\n    for (const _k in i) {\n        const k = _k;\n        if (!psbt.PSBTInputFinalKeys.includes(k))\n            delete i[k];\n    }\n}\n// (TxHash, Idx)\nconst TxHashIdx = P.struct({ txid: P.bytes(32, true), index: P.U32LE });\nfunction validateSigHash(s) {\n    if (typeof s !== 'number' || typeof SigHash[s] !== 'string')\n        throw new Error(`Invalid SigHash=${s}`);\n    return s;\n}\nfunction unpackSighash(hashType) {\n    const masked = hashType & 0b0011111;\n    return {\n        isAny: !!(hashType & SignatureHash.ANYONECANPAY),\n        isNone: masked === SignatureHash.NONE,\n        isSingle: masked === SignatureHash.SINGLE,\n    };\n}\nfunction validateOpts(opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error(`Wrong object type for transaction options: ${opts}`);\n    const _opts = {\n        ...opts,\n        // Defaults\n        version: (0, exports.def)(opts.version, exports.DEFAULT_VERSION),\n        lockTime: (0, exports.def)(opts.lockTime, 0),\n        PSBTVersion: (0, exports.def)(opts.PSBTVersion, 0),\n    };\n    if (typeof _opts.allowUnknowInput !== 'undefined')\n        opts.allowUnknownInputs = _opts.allowUnknowInput;\n    if (typeof _opts.allowUnknowOutput !== 'undefined')\n        opts.allowUnknownOutputs = _opts.allowUnknowOutput;\n    if (typeof _opts.lockTime !== 'number')\n        throw new Error('Transaction lock time should be number');\n    P.U32LE.encode(_opts.lockTime); // Additional range checks that lockTime\n    // There is no PSBT v1, and any new version will probably have fields which we don't know how to parse, which\n    // can lead to constructing broken transactions\n    if (_opts.PSBTVersion !== 0 && _opts.PSBTVersion !== 2)\n        throw new Error(`Unknown PSBT version ${_opts.PSBTVersion}`);\n    // Flags\n    for (const k of [\n        'allowUnknownVersion',\n        'allowUnknownOutputs',\n        'allowUnknownInputs',\n        'disableScriptCheck',\n        'bip174jsCompat',\n        'allowLegacyWitnessUtxo',\n        'lowR',\n    ]) {\n        const v = _opts[k];\n        if (v === undefined)\n            continue; // optional\n        if (typeof v !== 'boolean')\n            throw new Error(`Transation options wrong type: ${k}=${v} (${typeof v})`);\n    }\n    // 0 and -1 happens in tests\n    if (_opts.allowUnknownVersion\n        ? typeof _opts.version === 'number'\n        : ![-1, 0, 1, 2, 3].includes(_opts.version))\n        throw new Error(`Unknown version: ${_opts.version}`);\n    if (_opts.customScripts !== undefined) {\n        const cs = _opts.customScripts;\n        if (!Array.isArray(cs)) {\n            throw new Error(`wrong custom scripts type (expected array): customScripts=${cs} (${typeof cs})`);\n        }\n        for (const s of cs) {\n            if (typeof s.encode !== 'function' || typeof s.decode !== 'function')\n                throw new Error(`wrong script=${s} (${typeof s})`);\n            if (s.finalizeTaproot !== undefined && typeof s.finalizeTaproot !== 'function')\n                throw new Error(`wrong script=${s} (${typeof s})`);\n        }\n    }\n    return Object.freeze(_opts);\n}\n// NOTE: we cannot do this inside PSBTInput coder, because there is no index/txid at this point!\nfunction validateInput(i) {\n    if (i.nonWitnessUtxo && i.index !== undefined) {\n        const last = i.nonWitnessUtxo.outputs.length - 1;\n        if (i.index > last)\n            throw new Error(`validateInput: index(${i.index}) not in nonWitnessUtxo`);\n        const prevOut = i.nonWitnessUtxo.outputs[i.index];\n        if (i.witnessUtxo &&\n            (!(0, utils_ts_1.equalBytes)(i.witnessUtxo.script, prevOut.script) || i.witnessUtxo.amount !== prevOut.amount))\n            throw new Error('validateInput: witnessUtxo different from nonWitnessUtxo');\n        if (i.txid) {\n            const outputs = i.nonWitnessUtxo.outputs;\n            if (outputs.length - 1 < i.index)\n                throw new Error('nonWitnessUtxo: incorect output index');\n            // At this point, we are using previous tx output to create new input.\n            // Script safety checks are unnecessary:\n            // - User has no control over previous tx. If somebody send money in same tx\n            //   as unspendable output, we still want user able to spend money\n            // - We still want some checks to notify user about possible errors early\n            //   in case user wants to use wrong input by mistake\n            // - Worst case: tx will be rejected by nodes. Still better than disallowing user\n            //   to spend real input, no matter how broken it looks\n            const tx = Transaction.fromRaw(script_ts_1.RawTx.encode(i.nonWitnessUtxo), {\n                allowUnknownOutputs: true,\n                disableScriptCheck: true,\n                allowUnknownInputs: true,\n            });\n            const txid = base_1.hex.encode(i.txid);\n            // PSBTv2 vectors have non-final tx in inputs\n            if (tx.isFinal && tx.id !== txid)\n                throw new Error(`nonWitnessUtxo: wrong txid, exp=${txid} got=${tx.id}`);\n        }\n    }\n    return i;\n}\n// Normalizes input\nfunction getPrevOut(input) {\n    if (input.nonWitnessUtxo) {\n        if (input.index === undefined)\n            throw new Error('Unknown input index');\n        return input.nonWitnessUtxo.outputs[input.index];\n    }\n    else if (input.witnessUtxo)\n        return input.witnessUtxo;\n    else\n        throw new Error('Cannot find previous output info');\n}\nfunction normalizeInput(i, cur, allowedFields, disableScriptCheck = false, allowUnknown = false) {\n    let { nonWitnessUtxo, txid } = i;\n    // String support for common fields. We usually prefer Uint8Array to avoid errors\n    // like hex looking string accidentally passed, however, in case of nonWitnessUtxo\n    // it is better to expect string, since constructing this complex object will be\n    // difficult for user\n    if (typeof nonWitnessUtxo === 'string')\n        nonWitnessUtxo = base_1.hex.decode(nonWitnessUtxo);\n    if ((0, utils_ts_1.isBytes)(nonWitnessUtxo))\n        nonWitnessUtxo = script_ts_1.RawTx.decode(nonWitnessUtxo);\n    if (!('nonWitnessUtxo' in i) && nonWitnessUtxo === undefined)\n        nonWitnessUtxo = cur?.nonWitnessUtxo;\n    if (typeof txid === 'string')\n        txid = base_1.hex.decode(txid);\n    // TODO: if we have nonWitnessUtxo, we can extract txId from here\n    if (txid === undefined)\n        txid = cur?.txid;\n    let res = { ...cur, ...i, nonWitnessUtxo, txid };\n    if (!('nonWitnessUtxo' in i) && res.nonWitnessUtxo === undefined)\n        delete res.nonWitnessUtxo;\n    if (res.sequence === undefined)\n        res.sequence = exports.DEFAULT_SEQUENCE;\n    if (res.tapMerkleRoot === null)\n        delete res.tapMerkleRoot;\n    res = psbt.mergeKeyMap(psbt.PSBTInput, res, cur, allowedFields, allowUnknown);\n    psbt.PSBTInputCoder.encode(res); // Validates that everything is correct at this point\n    let prevOut;\n    if (res.nonWitnessUtxo && res.index !== undefined)\n        prevOut = res.nonWitnessUtxo.outputs[res.index];\n    else if (res.witnessUtxo)\n        prevOut = res.witnessUtxo;\n    if (prevOut && !disableScriptCheck)\n        (0, payment_ts_1.checkScript)(prevOut && prevOut.script, res.redeemScript, res.witnessScript);\n    return res;\n}\nfunction getInputType(input, allowLegacyWitnessUtxo = false) {\n    let txType = 'legacy';\n    let defaultSighash = SignatureHash.ALL;\n    const prevOut = getPrevOut(input);\n    const first = payment_ts_1.OutScript.decode(prevOut.script);\n    let type = first.type;\n    let cur = first;\n    const stack = [first];\n    if (first.type === 'tr') {\n        defaultSighash = SignatureHash.DEFAULT;\n        return {\n            txType: 'taproot',\n            type: 'tr',\n            last: first,\n            lastScript: prevOut.script,\n            defaultSighash,\n            sighash: input.sighashType || defaultSighash,\n        };\n    }\n    else {\n        if (first.type === 'wpkh' || first.type === 'wsh')\n            txType = 'segwit';\n        if (first.type === 'sh') {\n            if (!input.redeemScript)\n                throw new Error('inputType: sh without redeemScript');\n            let child = payment_ts_1.OutScript.decode(input.redeemScript);\n            if (child.type === 'wpkh' || child.type === 'wsh')\n                txType = 'segwit';\n            stack.push(child);\n            cur = child;\n            type += `-${child.type}`;\n        }\n        // wsh can be inside sh\n        if (cur.type === 'wsh') {\n            if (!input.witnessScript)\n                throw new Error('inputType: wsh without witnessScript');\n            let child = payment_ts_1.OutScript.decode(input.witnessScript);\n            if (child.type === 'wsh')\n                txType = 'segwit';\n            stack.push(child);\n            cur = child;\n            type += `-${child.type}`;\n        }\n        const last = stack[stack.length - 1];\n        if (last.type === 'sh' || last.type === 'wsh')\n            throw new Error('inputType: sh/wsh cannot be terminal type');\n        const lastScript = payment_ts_1.OutScript.encode(last);\n        const res = {\n            type,\n            txType,\n            last,\n            lastScript,\n            defaultSighash,\n            sighash: input.sighashType || defaultSighash,\n        };\n        if (txType === 'legacy' && !allowLegacyWitnessUtxo && !input.nonWitnessUtxo) {\n            throw new Error(`Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure`);\n        }\n        return res;\n    }\n}\nclass Transaction {\n    constructor(opts = {}) {\n        this.global = {};\n        this.inputs = []; // use getInput()\n        this.outputs = []; // use getOutput()\n        const _opts = (this.opts = validateOpts(opts));\n        // Merge with global structure of PSBTv2\n        if (_opts.lockTime !== exports.DEFAULT_LOCKTIME)\n            this.global.fallbackLocktime = _opts.lockTime;\n        this.global.txVersion = _opts.version;\n    }\n    // Import\n    static fromRaw(raw, opts = {}) {\n        const parsed = script_ts_1.RawTx.decode(raw);\n        const tx = new Transaction({ ...opts, version: parsed.version, lockTime: parsed.lockTime });\n        for (const o of parsed.outputs)\n            tx.addOutput(o);\n        tx.outputs = parsed.outputs;\n        tx.inputs = parsed.inputs;\n        if (parsed.witnesses) {\n            for (let i = 0; i < parsed.witnesses.length; i++)\n                tx.inputs[i].finalScriptWitness = parsed.witnesses[i];\n        }\n        return tx;\n    }\n    // PSBT\n    static fromPSBT(psbt_, opts = {}) {\n        let parsed;\n        try {\n            parsed = psbt.RawPSBTV0.decode(psbt_);\n        }\n        catch (e0) {\n            try {\n                parsed = psbt.RawPSBTV2.decode(psbt_);\n            }\n            catch (e2) {\n                // Throw error for v0 parsing, since it popular, otherwise it would be shadowed by v2 error\n                throw e0;\n            }\n        }\n        const PSBTVersion = parsed.global.version || 0;\n        if (PSBTVersion !== 0 && PSBTVersion !== 2)\n            throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n        const unsigned = parsed.global.unsignedTx;\n        const version = PSBTVersion === 0 ? unsigned?.version : parsed.global.txVersion;\n        const lockTime = PSBTVersion === 0 ? unsigned?.lockTime : parsed.global.fallbackLocktime;\n        const tx = new Transaction({ ...opts, version, lockTime, PSBTVersion });\n        // We need slice here, because otherwise\n        const inputCount = PSBTVersion === 0 ? unsigned?.inputs.length : parsed.global.inputCount;\n        tx.inputs = parsed.inputs.slice(0, inputCount).map((i, j) => validateInput({\n            finalScriptSig: P.EMPTY,\n            ...parsed.global.unsignedTx?.inputs[j],\n            ...i,\n        }));\n        const outputCount = PSBTVersion === 0 ? unsigned?.outputs.length : parsed.global.outputCount;\n        tx.outputs = parsed.outputs.slice(0, outputCount).map((i, j) => ({\n            ...i,\n            ...parsed.global.unsignedTx?.outputs[j],\n        }));\n        tx.global = { ...parsed.global, txVersion: version }; // just in case proprietary/unknown fields\n        if (lockTime !== exports.DEFAULT_LOCKTIME)\n            tx.global.fallbackLocktime = lockTime;\n        return tx;\n    }\n    toPSBT(PSBTVersion = this.opts.PSBTVersion) {\n        if (PSBTVersion !== 0 && PSBTVersion !== 2)\n            throw new Error(`Wrong PSBT version=${PSBTVersion}`);\n        // if (PSBTVersion === 0 && this.inputs.length === 0) {\n        //   throw new Error(\n        //     'PSBT version=0 export for transaction without inputs disabled, please use version=2. Please check `toPSBT` method for explanation.'\n        //   );\n        // }\n        const inputs = this.inputs.map((i) => validateInput(psbt.cleanPSBTFields(PSBTVersion, psbt.PSBTInput, i)));\n        for (const inp of inputs) {\n            // Don't serialize empty fields\n            if (inp.partialSig && !inp.partialSig.length)\n                delete inp.partialSig;\n            if (inp.finalScriptSig && !inp.finalScriptSig.length)\n                delete inp.finalScriptSig;\n            if (inp.finalScriptWitness && !inp.finalScriptWitness.length)\n                delete inp.finalScriptWitness;\n        }\n        const outputs = this.outputs.map((i) => psbt.cleanPSBTFields(PSBTVersion, psbt.PSBTOutput, i));\n        const global = { ...this.global };\n        if (PSBTVersion === 0) {\n            /*\n            - Bitcoin raw transaction expects to have at least 1 input because it uses case with zero inputs as marker for SegWit\n            - this means we cannot serialize raw tx with zero inputs since it will be parsed as SegWit tx\n            - Parsing of PSBTv0 depends on unsignedTx (it looks for input count here)\n            - BIP-174 requires old serialization format (without witnesses) inside global, which solves this\n            */\n            global.unsignedTx = script_ts_1.RawOldTx.decode(script_ts_1.RawOldTx.encode({\n                version: this.version,\n                lockTime: this.lockTime,\n                inputs: this.inputs.map(inputBeforeSign).map((i) => ({\n                    ...i,\n                    finalScriptSig: P.EMPTY,\n                })),\n                outputs: this.outputs.map(outputBeforeSign),\n            }));\n            delete global.fallbackLocktime;\n            delete global.txVersion;\n        }\n        else {\n            global.version = PSBTVersion;\n            global.txVersion = this.version;\n            global.inputCount = this.inputs.length;\n            global.outputCount = this.outputs.length;\n            if (global.fallbackLocktime && global.fallbackLocktime === exports.DEFAULT_LOCKTIME)\n                delete global.fallbackLocktime;\n        }\n        if (this.opts.bip174jsCompat) {\n            if (!inputs.length)\n                inputs.push({});\n            if (!outputs.length)\n                outputs.push({});\n        }\n        return (PSBTVersion === 0 ? psbt.RawPSBTV0 : psbt.RawPSBTV2).encode({\n            global,\n            inputs,\n            outputs,\n        });\n    }\n    // BIP370 lockTime (https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#determining-lock-time)\n    get lockTime() {\n        let height = exports.DEFAULT_LOCKTIME;\n        let heightCnt = 0;\n        let time = exports.DEFAULT_LOCKTIME;\n        let timeCnt = 0;\n        for (const i of this.inputs) {\n            if (i.requiredHeightLocktime) {\n                height = Math.max(height, i.requiredHeightLocktime);\n                heightCnt++;\n            }\n            if (i.requiredTimeLocktime) {\n                time = Math.max(time, i.requiredTimeLocktime);\n                timeCnt++;\n            }\n        }\n        if (heightCnt && heightCnt >= timeCnt)\n            return height;\n        if (time !== exports.DEFAULT_LOCKTIME)\n            return time;\n        return this.global.fallbackLocktime || exports.DEFAULT_LOCKTIME;\n    }\n    get version() {\n        // Should be not possible\n        if (this.global.txVersion === undefined)\n            throw new Error('No global.txVersion');\n        return this.global.txVersion;\n    }\n    inputStatus(idx) {\n        this.checkInputIdx(idx);\n        const input = this.inputs[idx];\n        // Finalized\n        if (input.finalScriptSig && input.finalScriptSig.length)\n            return 'finalized';\n        if (input.finalScriptWitness && input.finalScriptWitness.length)\n            return 'finalized';\n        // Signed taproot\n        if (input.tapKeySig)\n            return 'signed';\n        if (input.tapScriptSig && input.tapScriptSig.length)\n            return 'signed';\n        // Signed\n        if (input.partialSig && input.partialSig.length)\n            return 'signed';\n        return 'unsigned';\n    }\n    // Cannot replace unpackSighash, tests rely on very generic implemenetation with signing inputs outside of range\n    // We will lose some vectors -> smaller test coverage of preimages (very important!)\n    inputSighash(idx) {\n        this.checkInputIdx(idx);\n        const inputSighash = this.inputs[idx].sighashType;\n        const sighash = inputSighash === undefined ? SignatureHash.DEFAULT : inputSighash;\n        // ALL or DEFAULT -- everything signed\n        // NONE           -- all inputs + no outputs\n        // SINGLE         -- all inputs + output with same index\n        // ALL + ANYONE   -- specific input + all outputs\n        // NONE + ANYONE  -- specific input + no outputs\n        // SINGLE         -- specific inputs + output with same index\n        const sigOutputs = sighash === SignatureHash.DEFAULT ? SignatureHash.ALL : sighash & 0b11;\n        const sigInputs = sighash & SignatureHash.ANYONECANPAY;\n        return { sigInputs, sigOutputs };\n    }\n    // Very nice for debug purposes, but slow. If there is too much inputs/outputs to add, will be quadratic.\n    // Some cache will be nice, but there chance to have bugs with cache invalidation\n    signStatus() {\n        // if addInput or addOutput is not possible, then all inputs or outputs are signed\n        let addInput = true, addOutput = true;\n        let inputs = [], outputs = [];\n        for (let idx = 0; idx < this.inputs.length; idx++) {\n            const status = this.inputStatus(idx);\n            // Unsigned input doesn't affect anything\n            if (status === 'unsigned')\n                continue;\n            const { sigInputs, sigOutputs } = this.inputSighash(idx);\n            // Input type\n            if (sigInputs === SignatureHash.ANYONECANPAY)\n                inputs.push(idx);\n            else\n                addInput = false;\n            // Output type\n            if (sigOutputs === SignatureHash.ALL)\n                addOutput = false;\n            else if (sigOutputs === SignatureHash.SINGLE)\n                outputs.push(idx);\n            else if (sigOutputs === SignatureHash.NONE) {\n                // Doesn't affect any outputs at all\n            }\n            else\n                throw new Error(`Wrong signature hash output type: ${sigOutputs}`);\n        }\n        return { addInput, addOutput, inputs, outputs };\n    }\n    get isFinal() {\n        for (let idx = 0; idx < this.inputs.length; idx++)\n            if (this.inputStatus(idx) !== 'finalized')\n                return false;\n        return true;\n    }\n    // Info utils\n    get hasWitnesses() {\n        let out = false;\n        for (const i of this.inputs)\n            if (i.finalScriptWitness && i.finalScriptWitness.length)\n                out = true;\n        return out;\n    }\n    // https://en.bitcoin.it/wiki/Weight_units\n    get weight() {\n        if (!this.isFinal)\n            throw new Error('Transaction is not finalized');\n        let out = 32;\n        // Outputs\n        const outputs = this.outputs.map(outputBeforeSign);\n        out += 4 * script_ts_1.CompactSizeLen.encode(this.outputs.length).length;\n        for (const o of outputs)\n            out += 32 + 4 * script_ts_1.VarBytes.encode(o.script).length;\n        // Inputs\n        if (this.hasWitnesses)\n            out += 2;\n        out += 4 * script_ts_1.CompactSizeLen.encode(this.inputs.length).length;\n        for (const i of this.inputs) {\n            out += 160 + 4 * script_ts_1.VarBytes.encode(i.finalScriptSig || P.EMPTY).length;\n            if (this.hasWitnesses && i.finalScriptWitness)\n                out += script_ts_1.RawWitness.encode(i.finalScriptWitness).length;\n        }\n        return out;\n    }\n    get vsize() {\n        return (0, exports.toVsize)(this.weight);\n    }\n    toBytes(withScriptSig = false, withWitness = false) {\n        return script_ts_1.RawTx.encode({\n            version: this.version,\n            lockTime: this.lockTime,\n            inputs: this.inputs.map(inputBeforeSign).map((i) => ({\n                ...i,\n                finalScriptSig: (withScriptSig && i.finalScriptSig) || P.EMPTY,\n            })),\n            outputs: this.outputs.map(outputBeforeSign),\n            witnesses: this.inputs.map((i) => i.finalScriptWitness || []),\n            segwitFlag: withWitness && this.hasWitnesses,\n        });\n    }\n    get unsignedTx() {\n        return this.toBytes(false, false);\n    }\n    get hex() {\n        return base_1.hex.encode(this.toBytes(true, this.hasWitnesses));\n    }\n    get hash() {\n        if (!this.isFinal)\n            throw new Error('Transaction is not finalized');\n        return base_1.hex.encode(u.sha256x2(this.toBytes(true)));\n    }\n    get id() {\n        if (!this.isFinal)\n            throw new Error('Transaction is not finalized');\n        return base_1.hex.encode(u.sha256x2(this.toBytes(true)).reverse());\n    }\n    // Input stuff\n    checkInputIdx(idx) {\n        if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.inputs.length)\n            throw new Error(`Wrong input index=${idx}`);\n    }\n    getInput(idx) {\n        this.checkInputIdx(idx);\n        return cloneDeep(this.inputs[idx]);\n    }\n    get inputsLength() {\n        return this.inputs.length;\n    }\n    // Modification\n    addInput(input, _ignoreSignStatus = false) {\n        if (!_ignoreSignStatus && !this.signStatus().addInput)\n            throw new Error('Tx has signed inputs, cannot add new one');\n        this.inputs.push(normalizeInput(input, undefined, undefined, this.opts.disableScriptCheck));\n        return this.inputs.length - 1;\n    }\n    updateInput(idx, input, _ignoreSignStatus = false) {\n        this.checkInputIdx(idx);\n        let allowedFields = undefined;\n        if (!_ignoreSignStatus) {\n            const status = this.signStatus();\n            if (!status.addInput || status.inputs.includes(idx))\n                allowedFields = psbt.PSBTInputUnsignedKeys;\n        }\n        this.inputs[idx] = normalizeInput(input, this.inputs[idx], allowedFields, this.opts.disableScriptCheck, this.opts.allowUnknown);\n    }\n    // Output stuff\n    checkOutputIdx(idx) {\n        if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.outputs.length)\n            throw new Error(`Wrong output index=${idx}`);\n    }\n    getOutput(idx) {\n        this.checkOutputIdx(idx);\n        return cloneDeep(this.outputs[idx]);\n    }\n    getOutputAddress(idx, network = utils_ts_1.NETWORK) {\n        const out = this.getOutput(idx);\n        if (!out.script)\n            return;\n        return (0, payment_ts_1.Address)(network).encode(payment_ts_1.OutScript.decode(out.script));\n    }\n    get outputsLength() {\n        return this.outputs.length;\n    }\n    normalizeOutput(o, cur, allowedFields) {\n        let { amount, script } = o;\n        if (amount === undefined)\n            amount = cur?.amount;\n        if (typeof amount !== 'bigint')\n            throw new Error(`Wrong amount type, should be of type bigint in sats, but got ${amount} of type ${typeof amount}`);\n        if (typeof script === 'string')\n            script = base_1.hex.decode(script);\n        if (script === undefined)\n            script = cur?.script;\n        let res = { ...cur, ...o, amount, script };\n        if (res.amount === undefined)\n            delete res.amount;\n        res = psbt.mergeKeyMap(psbt.PSBTOutput, res, cur, allowedFields, this.opts.allowUnknown);\n        psbt.PSBTOutputCoder.encode(res);\n        if (res.script &&\n            !this.opts.allowUnknownOutputs &&\n            payment_ts_1.OutScript.decode(res.script).type === 'unknown') {\n            throw new Error('Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure');\n        }\n        if (!this.opts.disableScriptCheck)\n            (0, payment_ts_1.checkScript)(res.script, res.redeemScript, res.witnessScript);\n        return res;\n    }\n    addOutput(o, _ignoreSignStatus = false) {\n        if (!_ignoreSignStatus && !this.signStatus().addOutput)\n            throw new Error('Tx has signed outputs, cannot add new one');\n        this.outputs.push(this.normalizeOutput(o));\n        return this.outputs.length - 1;\n    }\n    updateOutput(idx, output, _ignoreSignStatus = false) {\n        this.checkOutputIdx(idx);\n        let allowedFields = undefined;\n        if (!_ignoreSignStatus) {\n            const status = this.signStatus();\n            if (!status.addOutput || status.outputs.includes(idx))\n                allowedFields = psbt.PSBTOutputUnsignedKeys;\n        }\n        this.outputs[idx] = this.normalizeOutput(output, this.outputs[idx], allowedFields);\n    }\n    addOutputAddress(address, amount, network = utils_ts_1.NETWORK) {\n        return this.addOutput({ script: payment_ts_1.OutScript.encode((0, payment_ts_1.Address)(network).decode(address)), amount });\n    }\n    // Utils\n    get fee() {\n        let res = 0n;\n        for (const i of this.inputs) {\n            const prevOut = getPrevOut(i);\n            if (!prevOut)\n                throw new Error('Empty input amount');\n            res += prevOut.amount;\n        }\n        const outputs = this.outputs.map(outputBeforeSign);\n        for (const o of outputs)\n            res -= o.amount;\n        return res;\n    }\n    // Signing\n    // Based on https://github.com/bitcoin/bitcoin/blob/5871b5b5ab57a0caf9b7514eb162c491c83281d5/test/functional/test_framework/script.py#L624\n    // There is optimization opportunity to re-use hashes for multiple inputs for witness v0/v1,\n    // but we are trying to be less complicated for audit purpose for now.\n    preimageLegacy(idx, prevOutScript, hashType) {\n        const { isAny, isNone, isSingle } = unpackSighash(hashType);\n        if (idx < 0 || !Number.isSafeInteger(idx))\n            throw new Error(`Invalid input idx=${idx}`);\n        if ((isSingle && idx >= this.outputs.length) || idx >= this.inputs.length)\n            return P.U256BE.encode(1n);\n        prevOutScript = script_ts_1.Script.encode(script_ts_1.Script.decode(prevOutScript).filter((i) => i !== 'CODESEPARATOR'));\n        let inputs = this.inputs\n            .map(inputBeforeSign)\n            .map((input, inputIdx) => ({\n            ...input,\n            finalScriptSig: inputIdx === idx ? prevOutScript : P.EMPTY,\n        }));\n        if (isAny)\n            inputs = [inputs[idx]];\n        else if (isNone || isSingle) {\n            inputs = inputs.map((input, inputIdx) => ({\n                ...input,\n                sequence: inputIdx === idx ? input.sequence : 0,\n            }));\n        }\n        let outputs = this.outputs.map(outputBeforeSign);\n        if (isNone)\n            outputs = [];\n        else if (isSingle) {\n            outputs = outputs.slice(0, idx).fill(EMPTY_OUTPUT).concat([outputs[idx]]);\n        }\n        const tmpTx = script_ts_1.RawTx.encode({\n            lockTime: this.lockTime,\n            version: this.version,\n            segwitFlag: false,\n            inputs,\n            outputs,\n        });\n        return u.sha256x2(tmpTx, P.I32LE.encode(hashType));\n    }\n    preimageWitnessV0(idx, prevOutScript, hashType, amount) {\n        const { isAny, isNone, isSingle } = unpackSighash(hashType);\n        let inputHash = EMPTY32;\n        let sequenceHash = EMPTY32;\n        let outputHash = EMPTY32;\n        const inputs = this.inputs.map(inputBeforeSign);\n        const outputs = this.outputs.map(outputBeforeSign);\n        if (!isAny)\n            inputHash = u.sha256x2(...inputs.map(TxHashIdx.encode));\n        if (!isAny && !isSingle && !isNone)\n            sequenceHash = u.sha256x2(...inputs.map((i) => P.U32LE.encode(i.sequence)));\n        if (!isSingle && !isNone) {\n            outputHash = u.sha256x2(...outputs.map(script_ts_1.RawOutput.encode));\n        }\n        else if (isSingle && idx < outputs.length)\n            outputHash = u.sha256x2(script_ts_1.RawOutput.encode(outputs[idx]));\n        const input = inputs[idx];\n        return u.sha256x2(P.I32LE.encode(this.version), inputHash, sequenceHash, P.bytes(32, true).encode(input.txid), P.U32LE.encode(input.index), script_ts_1.VarBytes.encode(prevOutScript), P.U64LE.encode(amount), P.U32LE.encode(input.sequence), outputHash, P.U32LE.encode(this.lockTime), P.U32LE.encode(hashType));\n    }\n    preimageWitnessV1(idx, prevOutScript, hashType, amount, codeSeparator = -1, leafScript, leafVer = 0xc0, annex) {\n        if (!Array.isArray(amount) || this.inputs.length !== amount.length)\n            throw new Error(`Invalid amounts array=${amount}`);\n        if (!Array.isArray(prevOutScript) || this.inputs.length !== prevOutScript.length)\n            throw new Error(`Invalid prevOutScript array=${prevOutScript}`);\n        const out = [\n            P.U8.encode(0),\n            P.U8.encode(hashType), // U8 sigHash\n            P.I32LE.encode(this.version),\n            P.U32LE.encode(this.lockTime),\n        ];\n        const outType = hashType === SignatureHash.DEFAULT ? SignatureHash.ALL : hashType & 0b11;\n        const inType = hashType & SignatureHash.ANYONECANPAY;\n        const inputs = this.inputs.map(inputBeforeSign);\n        const outputs = this.outputs.map(outputBeforeSign);\n        if (inType !== SignatureHash.ANYONECANPAY) {\n            out.push(...[\n                inputs.map(TxHashIdx.encode),\n                amount.map(P.U64LE.encode),\n                prevOutScript.map(script_ts_1.VarBytes.encode),\n                inputs.map((i) => P.U32LE.encode(i.sequence)),\n            ].map((i) => u.sha256((0, utils_ts_1.concatBytes)(...i))));\n        }\n        if (outType === SignatureHash.ALL) {\n            out.push(u.sha256((0, utils_ts_1.concatBytes)(...outputs.map(script_ts_1.RawOutput.encode))));\n        }\n        const spendType = (annex ? 1 : 0) | (leafScript ? 2 : 0);\n        out.push(new Uint8Array([spendType]));\n        if (inType === SignatureHash.ANYONECANPAY) {\n            const inp = inputs[idx];\n            out.push(TxHashIdx.encode(inp), P.U64LE.encode(amount[idx]), script_ts_1.VarBytes.encode(prevOutScript[idx]), P.U32LE.encode(inp.sequence));\n        }\n        else\n            out.push(P.U32LE.encode(idx));\n        if (spendType & 1)\n            out.push(u.sha256(script_ts_1.VarBytes.encode(annex || P.EMPTY)));\n        if (outType === SignatureHash.SINGLE)\n            out.push(idx < outputs.length ? u.sha256(script_ts_1.RawOutput.encode(outputs[idx])) : EMPTY32);\n        if (leafScript)\n            out.push((0, payment_ts_1.tapLeafHash)(leafScript, leafVer), P.U8.encode(0), P.I32LE.encode(codeSeparator));\n        return u.tagSchnorr('TapSighash', ...out);\n    }\n    // Signer can be privateKey OR instance of bip32 HD stuff\n    signIdx(privateKey, idx, allowedSighash, _auxRand) {\n        this.checkInputIdx(idx);\n        const input = this.inputs[idx];\n        const inputType = getInputType(input, this.opts.allowLegacyWitnessUtxo);\n        // Handle BIP32 HDKey\n        if (!(0, utils_ts_1.isBytes)(privateKey)) {\n            if (!input.bip32Derivation || !input.bip32Derivation.length)\n                throw new Error('bip32Derivation: empty');\n            const signers = input.bip32Derivation\n                .filter((i) => i[1].fingerprint == privateKey.fingerprint)\n                .map(([pubKey, { path }]) => {\n                let s = privateKey;\n                for (const i of path)\n                    s = s.deriveChild(i);\n                if (!(0, utils_ts_1.equalBytes)(s.publicKey, pubKey))\n                    throw new Error('bip32Derivation: wrong pubKey');\n                if (!s.privateKey)\n                    throw new Error('bip32Derivation: no privateKey');\n                return s;\n            });\n            if (!signers.length)\n                throw new Error(`bip32Derivation: no items with fingerprint=${privateKey.fingerprint}`);\n            let signed = false;\n            for (const s of signers)\n                if (this.signIdx(s.privateKey, idx))\n                    signed = true;\n            return signed;\n        }\n        // Sighash checks\n        // Just for compat with bitcoinjs-lib, so users won't face unexpected behaviour.\n        if (!allowedSighash)\n            allowedSighash = [inputType.defaultSighash];\n        else\n            allowedSighash.forEach(validateSigHash);\n        const sighash = inputType.sighash;\n        if (!allowedSighash.includes(sighash)) {\n            throw new Error(`Input with not allowed sigHash=${sighash}. Allowed: ${allowedSighash.join(', ')}`);\n        }\n        // It is possible to sign these inputs for legacy/segwit v0 (but no taproot!),\n        // however this was because of bug in bitcoin-core, which remains here because of consensus.\n        // If this is absolutely neccessary for your case, please open issue.\n        // We disable it to avoid complicated workflow where SINGLE will block adding new outputs\n        const { sigOutputs } = this.inputSighash(idx);\n        if (sigOutputs === SignatureHash.SINGLE && idx >= this.outputs.length) {\n            throw new Error(`Input with sighash SINGLE, but there is no output with corresponding index=${idx}`);\n        }\n        // Actual signing\n        // Taproot\n        const prevOut = getPrevOut(input);\n        if (inputType.txType === 'taproot') {\n            const prevOuts = this.inputs.map(getPrevOut);\n            const prevOutScript = prevOuts.map((i) => i.script);\n            const amount = prevOuts.map((i) => i.amount);\n            let signed = false;\n            let schnorrPub = u.pubSchnorr(privateKey);\n            let merkleRoot = input.tapMerkleRoot || P.EMPTY;\n            if (input.tapInternalKey) {\n                // internal + tweak = tweaked key\n                // if internal key == current public key, we need to tweak private key,\n                // otherwise sign as is. bitcoinjs implementation always wants tweaked\n                // priv key to be provided\n                const { pubKey, privKey } = getTaprootKeys(privateKey, schnorrPub, input.tapInternalKey, merkleRoot);\n                const [taprootPubKey, _] = u.taprootTweakPubkey(input.tapInternalKey, merkleRoot);\n                if ((0, utils_ts_1.equalBytes)(taprootPubKey, pubKey)) {\n                    const hash = this.preimageWitnessV1(idx, prevOutScript, sighash, amount);\n                    const sig = (0, utils_ts_1.concatBytes)(u.signSchnorr(hash, privKey, _auxRand), sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY);\n                    this.updateInput(idx, { tapKeySig: sig }, true);\n                    signed = true;\n                }\n            }\n            if (input.tapLeafScript) {\n                input.tapScriptSig = input.tapScriptSig || [];\n                for (const [_, _script] of input.tapLeafScript) {\n                    const script = _script.subarray(0, -1);\n                    const scriptDecoded = script_ts_1.Script.decode(script);\n                    const ver = _script[_script.length - 1];\n                    const hash = (0, payment_ts_1.tapLeafHash)(script, ver);\n                    // NOTE: no need to tweak internal key here, since we don't support nested p2tr\n                    const pos = scriptDecoded.findIndex((i) => (0, utils_ts_1.isBytes)(i) && (0, utils_ts_1.equalBytes)(i, schnorrPub));\n                    // Skip if there is no public key in tapLeafScript\n                    if (pos === -1)\n                        continue;\n                    const msg = this.preimageWitnessV1(idx, prevOutScript, sighash, amount, undefined, script, ver);\n                    const sig = (0, utils_ts_1.concatBytes)(u.signSchnorr(msg, privateKey, _auxRand), sighash !== SignatureHash.DEFAULT ? new Uint8Array([sighash]) : P.EMPTY);\n                    this.updateInput(idx, { tapScriptSig: [[{ pubKey: schnorrPub, leafHash: hash }, sig]] }, true);\n                    signed = true;\n                }\n            }\n            if (!signed)\n                throw new Error('No taproot scripts signed');\n            return true;\n        }\n        else {\n            // only compressed keys are supported for now\n            const pubKey = u.pubECDSA(privateKey);\n            // TODO: replace with explicit checks\n            // Check if script has public key or its has inside\n            let hasPubkey = false;\n            const pubKeyHash = u.hash160(pubKey);\n            for (const i of script_ts_1.Script.decode(inputType.lastScript)) {\n                if ((0, utils_ts_1.isBytes)(i) && ((0, utils_ts_1.equalBytes)(i, pubKey) || (0, utils_ts_1.equalBytes)(i, pubKeyHash)))\n                    hasPubkey = true;\n            }\n            if (!hasPubkey)\n                throw new Error(`Input script doesn't have pubKey: ${inputType.lastScript}`);\n            let hash;\n            if (inputType.txType === 'legacy') {\n                hash = this.preimageLegacy(idx, inputType.lastScript, sighash);\n            }\n            else if (inputType.txType === 'segwit') {\n                let script = inputType.lastScript;\n                // If wpkh OR sh-wpkh, wsh-wpkh is impossible, so looks ok\n                if (inputType.last.type === 'wpkh')\n                    script = payment_ts_1.OutScript.encode({ type: 'pkh', hash: inputType.last.hash });\n                hash = this.preimageWitnessV0(idx, script, sighash, prevOut.amount);\n            }\n            else\n                throw new Error(`Transaction/sign: unknown tx type: ${inputType.txType}`);\n            const sig = u.signECDSA(hash, privateKey, this.opts.lowR);\n            this.updateInput(idx, {\n                partialSig: [[pubKey, (0, utils_ts_1.concatBytes)(sig, new Uint8Array([sighash]))]],\n            }, true);\n        }\n        return true;\n    }\n    // This is bad API. Will work if user creates and signs tx, but if\n    // there is some complex workflow with exchanging PSBT and signing them,\n    // then it is better to validate which output user signs. How could a better API look like?\n    // Example: user adds input, sends to another party, then signs received input (mixer etc),\n    // another user can add different input for same key and user will sign it.\n    // Even worse: another user can add bip32 derivation, and spend money from different address.\n    // Better api: signIdx\n    sign(privateKey, allowedSighash, _auxRand) {\n        let num = 0;\n        for (let i = 0; i < this.inputs.length; i++) {\n            try {\n                if (this.signIdx(privateKey, i, allowedSighash, _auxRand))\n                    num++;\n            }\n            catch (e) { }\n        }\n        if (!num)\n            throw new Error('No inputs signed');\n        return num;\n    }\n    finalizeIdx(idx) {\n        this.checkInputIdx(idx);\n        if (this.fee < 0n)\n            throw new Error('Outputs spends more than inputs amount');\n        const input = this.inputs[idx];\n        const inputType = getInputType(input, this.opts.allowLegacyWitnessUtxo);\n        // Taproot finalize\n        if (inputType.txType === 'taproot') {\n            if (input.tapKeySig)\n                input.finalScriptWitness = [input.tapKeySig];\n            else if (input.tapLeafScript && input.tapScriptSig) {\n                // Sort leafs by control block length.\n                const leafs = input.tapLeafScript.sort((a, b) => psbt.TaprootControlBlock.encode(a[0]).length -\n                    psbt.TaprootControlBlock.encode(b[0]).length);\n                for (const [cb, _script] of leafs) {\n                    // Last byte is version\n                    const script = _script.slice(0, -1);\n                    const ver = _script[_script.length - 1];\n                    const outScript = payment_ts_1.OutScript.decode(script);\n                    const hash = (0, payment_ts_1.tapLeafHash)(script, ver);\n                    const scriptSig = input.tapScriptSig.filter((i) => (0, utils_ts_1.equalBytes)(i[0].leafHash, hash));\n                    let signatures = [];\n                    if (outScript.type === 'tr_ms') {\n                        const m = outScript.m;\n                        const pubkeys = outScript.pubkeys;\n                        let added = 0;\n                        for (const pub of pubkeys) {\n                            const sigIdx = scriptSig.findIndex((i) => (0, utils_ts_1.equalBytes)(i[0].pubKey, pub));\n                            // Should have exact amount of signatures (more -- will fail)\n                            if (added === m || sigIdx === -1) {\n                                signatures.push(P.EMPTY);\n                                continue;\n                            }\n                            signatures.push(scriptSig[sigIdx][1]);\n                            added++;\n                        }\n                        // Should be exact same as m\n                        if (added !== m)\n                            continue;\n                    }\n                    else if (outScript.type === 'tr_ns') {\n                        for (const pub of outScript.pubkeys) {\n                            const sigIdx = scriptSig.findIndex((i) => (0, utils_ts_1.equalBytes)(i[0].pubKey, pub));\n                            if (sigIdx === -1)\n                                continue;\n                            signatures.push(scriptSig[sigIdx][1]);\n                        }\n                        if (signatures.length !== outScript.pubkeys.length)\n                            continue;\n                    }\n                    else if (outScript.type === 'unknown' && this.opts.allowUnknownInputs) {\n                        // Trying our best to sign what we can\n                        const scriptDecoded = script_ts_1.Script.decode(script);\n                        signatures = scriptSig\n                            .map(([{ pubKey }, signature]) => {\n                            const pos = scriptDecoded.findIndex((i) => (0, utils_ts_1.isBytes)(i) && (0, utils_ts_1.equalBytes)(i, pubKey));\n                            if (pos === -1)\n                                throw new Error('finalize/taproot: cannot find position of pubkey in script');\n                            return { signature, pos };\n                        })\n                            // Reverse order (because witness is stack and we take last element first from it)\n                            .sort((a, b) => a.pos - b.pos)\n                            .map((i) => i.signature);\n                        if (!signatures.length)\n                            continue;\n                    }\n                    else {\n                        const custom = this.opts.customScripts;\n                        if (custom) {\n                            for (const c of custom) {\n                                if (!c.finalizeTaproot)\n                                    continue;\n                                const scriptDecoded = script_ts_1.Script.decode(script);\n                                const csEncoded = c.encode(scriptDecoded);\n                                if (csEncoded === undefined)\n                                    continue;\n                                const finalized = c.finalizeTaproot(script, csEncoded, scriptSig);\n                                if (!finalized)\n                                    continue;\n                                input.finalScriptWitness = finalized.concat(psbt.TaprootControlBlock.encode(cb));\n                                input.finalScriptSig = P.EMPTY;\n                                cleanFinalInput(input);\n                                return;\n                            }\n                        }\n                        throw new Error('Finalize: Unknown tapLeafScript');\n                    }\n                    // Witness is stack, so last element will be used first\n                    input.finalScriptWitness = signatures\n                        .reverse()\n                        .concat([script, psbt.TaprootControlBlock.encode(cb)]);\n                    break;\n                }\n                if (!input.finalScriptWitness)\n                    throw new Error('finalize/taproot: empty witness');\n            }\n            else\n                throw new Error('finalize/taproot: unknown input');\n            input.finalScriptSig = P.EMPTY;\n            cleanFinalInput(input);\n            return;\n        }\n        if (!input.partialSig || !input.partialSig.length)\n            throw new Error('Not enough partial sign');\n        let inputScript = P.EMPTY;\n        let witness = [];\n        // TODO: move input scripts closer to payments/output scripts\n        // Multisig\n        if (inputType.last.type === 'ms') {\n            const m = inputType.last.m;\n            const pubkeys = inputType.last.pubkeys;\n            let signatures = [];\n            // partial: [pubkey, sign]\n            for (const pub of pubkeys) {\n                const sign = input.partialSig.find((s) => (0, utils_ts_1.equalBytes)(pub, s[0]));\n                if (!sign)\n                    continue;\n                signatures.push(sign[1]);\n            }\n            signatures = signatures.slice(0, m);\n            if (signatures.length !== m) {\n                throw new Error(`Multisig: wrong signatures count, m=${m} n=${pubkeys.length} signatures=${signatures.length}`);\n            }\n            inputScript = script_ts_1.Script.encode([0, ...signatures]);\n        }\n        else if (inputType.last.type === 'pk') {\n            inputScript = script_ts_1.Script.encode([input.partialSig[0][1]]);\n        }\n        else if (inputType.last.type === 'pkh') {\n            inputScript = script_ts_1.Script.encode([input.partialSig[0][1], input.partialSig[0][0]]);\n        }\n        else if (inputType.last.type === 'wpkh') {\n            inputScript = P.EMPTY;\n            witness = [input.partialSig[0][1], input.partialSig[0][0]];\n        }\n        else if (inputType.last.type === 'unknown' && !this.opts.allowUnknownInputs)\n            throw new Error('Unknown inputs not allowed');\n        // Create final scripts (generic part)\n        let finalScriptSig, finalScriptWitness;\n        if (inputType.type.includes('wsh-')) {\n            // P2WSH\n            if (inputScript.length && inputType.lastScript.length) {\n                witness = script_ts_1.Script.decode(inputScript).map((i) => {\n                    if (i === 0)\n                        return P.EMPTY;\n                    if ((0, utils_ts_1.isBytes)(i))\n                        return i;\n                    throw new Error(`Wrong witness op=${i}`);\n                });\n            }\n            witness = witness.concat(inputType.lastScript);\n        }\n        if (inputType.txType === 'segwit')\n            finalScriptWitness = witness;\n        if (inputType.type.startsWith('sh-wsh-')) {\n            finalScriptSig = script_ts_1.Script.encode([script_ts_1.Script.encode([0, u.sha256(inputType.lastScript)])]);\n        }\n        else if (inputType.type.startsWith('sh-')) {\n            finalScriptSig = script_ts_1.Script.encode([...script_ts_1.Script.decode(inputScript), inputType.lastScript]);\n        }\n        else if (inputType.type.startsWith('wsh-')) {\n        }\n        else if (inputType.txType !== 'segwit')\n            finalScriptSig = inputScript;\n        if (!finalScriptSig && !finalScriptWitness)\n            throw new Error('Unknown error finalizing input');\n        if (finalScriptSig)\n            input.finalScriptSig = finalScriptSig;\n        if (finalScriptWitness)\n            input.finalScriptWitness = finalScriptWitness;\n        cleanFinalInput(input);\n    }\n    finalize() {\n        for (let i = 0; i < this.inputs.length; i++)\n            this.finalizeIdx(i);\n    }\n    extract() {\n        if (!this.isFinal)\n            throw new Error('Transaction has unfinalized inputs');\n        if (!this.outputs.length)\n            throw new Error('Transaction has no outputs');\n        if (this.fee < 0n)\n            throw new Error('Outputs spends more than inputs amount');\n        return this.toBytes(true, true);\n    }\n    combine(other) {\n        for (const k of ['PSBTVersion', 'version', 'lockTime']) {\n            if (this.opts[k] !== other.opts[k]) {\n                throw new Error(`Transaction/combine: different ${k} this=${this.opts[k]} other=${other.opts[k]}`);\n            }\n        }\n        for (const k of ['inputs', 'outputs']) {\n            if (this[k].length !== other[k].length) {\n                throw new Error(`Transaction/combine: different ${k} length this=${this[k].length} other=${other[k].length}`);\n            }\n        }\n        const thisUnsigned = this.global.unsignedTx ? script_ts_1.RawOldTx.encode(this.global.unsignedTx) : P.EMPTY;\n        const otherUnsigned = other.global.unsignedTx\n            ? script_ts_1.RawOldTx.encode(other.global.unsignedTx)\n            : P.EMPTY;\n        if (!(0, utils_ts_1.equalBytes)(thisUnsigned, otherUnsigned))\n            throw new Error(`Transaction/combine: different unsigned tx`);\n        this.global = psbt.mergeKeyMap(psbt.PSBTGlobal, this.global, other.global, undefined, this.opts.allowUnknown);\n        for (let i = 0; i < this.inputs.length; i++)\n            this.updateInput(i, other.inputs[i], true);\n        for (let i = 0; i < this.outputs.length; i++)\n            this.updateOutput(i, other.outputs[i], true);\n        return this;\n    }\n    clone() {\n        // deepClone probably faster, but this enforces that encoding is valid\n        return Transaction.fromPSBT(this.toPSBT(this.opts.PSBTVersion), this.opts);\n    }\n}\nexports.Transaction = Transaction;\nfunction PSBTCombine(psbts) {\n    if (!psbts || !Array.isArray(psbts) || !psbts.length)\n        throw new Error('PSBTCombine: wrong PSBT list');\n    const tx = Transaction.fromPSBT(psbts[0]);\n    for (let i = 1; i < psbts.length; i++)\n        tx.combine(Transaction.fromPSBT(psbts[i]));\n    return tx.toPSBT();\n}\n// Copy-pasted from bip32 derive, maybe do something like 'bip32.parsePath'?\nconst HARDENED_OFFSET = 0x80000000;\nfunction bip32Path(path) {\n    const out = [];\n    if (!/^[mM]'?/.test(path))\n        throw new Error('Path must start with \"m\" or \"M\"');\n    if (/^[mM]'?$/.test(path))\n        return out;\n    const parts = path.replace(/^[mM]'?\\//, '').split('/');\n    for (const c of parts) {\n        const m = /^(\\d+)('?)$/.exec(c);\n        if (!m || m.length !== 3)\n            throw new Error(`Invalid child index: ${c}`);\n        let idx = +m[1];\n        if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET)\n            throw new Error('Invalid index');\n        // hardened key\n        if (m[2] === \"'\")\n            idx += HARDENED_OFFSET;\n        out.push(idx);\n    }\n    return out;\n}\n//# sourceMappingURL=transaction.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@scure/btc-signer/transaction.js?\n}")},"./node_modules/@scure/btc-signer/utils.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.TEST_NETWORK = exports.NETWORK = exports.TAPROOT_UNSPENDABLE_KEY = exports.PubT = exports.tagSchnorr = exports.signSchnorr = exports.pubECDSA = exports.pubSchnorr = exports.randomPrivateKeyBytes = exports.sha256x2 = exports.hash160 = exports.sha256 = exports.isBytes = exports.equalBytes = exports.concatBytes = void 0;\nexports.signECDSA = signECDSA;\nexports.validatePubkey = validatePubkey;\nexports.tapTweak = tapTweak;\nexports.taprootTweakPrivKey = taprootTweakPrivKey;\nexports.taprootTweakPubkey = taprootTweakPubkey;\nexports.compareBytes = compareBytes;\nconst secp256k1_js_1 = __webpack_require__(/*! @noble/curves/secp256k1.js */ "./node_modules/@noble/curves/secp256k1.js");\nconst legacy_js_1 = __webpack_require__(/*! @noble/hashes/legacy.js */ "./node_modules/@noble/hashes/legacy.js");\nconst sha2_js_1 = __webpack_require__(/*! @noble/hashes/sha2.js */ "./node_modules/@noble/hashes/sha2.js");\nObject.defineProperty(exports, "sha256", ({ enumerable: true, get: function () { return sha2_js_1.sha256; } }));\nconst micro_packed_1 = __webpack_require__(/*! micro-packed */ "./node_modules/micro-packed/lib/index.js");\nconst Point = secp256k1_js_1.secp256k1.ProjectivePoint;\nconst CURVE_ORDER = secp256k1_js_1.secp256k1.CURVE.n;\nconst isBytes = micro_packed_1.utils.isBytes;\nexports.isBytes = isBytes;\nconst concatBytes = micro_packed_1.utils.concatBytes;\nexports.concatBytes = concatBytes;\nconst equalBytes = micro_packed_1.utils.equalBytes;\nexports.equalBytes = equalBytes;\nconst hash160 = (msg) => (0, legacy_js_1.ripemd160)((0, sha2_js_1.sha256)(msg));\nexports.hash160 = hash160;\nconst sha256x2 = (...msgs) => (0, sha2_js_1.sha256)((0, sha2_js_1.sha256)(concatBytes(...msgs)));\nexports.sha256x2 = sha256x2;\nexports.randomPrivateKeyBytes = secp256k1_js_1.schnorr.utils.randomPrivateKey;\nexports.pubSchnorr = secp256k1_js_1.schnorr.getPublicKey;\nexports.pubECDSA = secp256k1_js_1.secp256k1.getPublicKey;\n// low-r signature grinding. Used to reduce tx size by 1 byte.\n// noble/secp256k1 does not support the feature: it is not used outside of BTC.\n// We implement it manually, because in BTC it\'s common.\n// Not best way, but closest to bitcoin implementation (easier to check)\nconst hasLowR = (sig) => sig.r < CURVE_ORDER / 2n;\nfunction signECDSA(hash, privateKey, lowR = false) {\n    let sig = secp256k1_js_1.secp256k1.sign(hash, privateKey);\n    if (lowR && !hasLowR(sig)) {\n        const extraEntropy = new Uint8Array(32);\n        let counter = 0;\n        while (!hasLowR(sig)) {\n            extraEntropy.set(micro_packed_1.U32LE.encode(counter++));\n            sig = secp256k1_js_1.secp256k1.sign(hash, privateKey, { extraEntropy });\n            if (counter > 4294967295)\n                throw new Error(\'lowR counter overflow: report the error\');\n        }\n    }\n    return sig.toDERRawBytes();\n}\nexports.signSchnorr = secp256k1_js_1.schnorr.sign;\nexports.tagSchnorr = secp256k1_js_1.schnorr.utils.taggedHash;\nvar PubT;\n(function (PubT) {\n    PubT[PubT["ecdsa"] = 0] = "ecdsa";\n    PubT[PubT["schnorr"] = 1] = "schnorr";\n})(PubT || (exports.PubT = PubT = {}));\nfunction validatePubkey(pub, type) {\n    const len = pub.length;\n    if (type === PubT.ecdsa) {\n        if (len === 32)\n            throw new Error(\'Expected non-Schnorr key\');\n        Point.fromHex(pub); // does assertValidity\n        return pub;\n    }\n    else if (type === PubT.schnorr) {\n        if (len !== 32)\n            throw new Error(\'Expected 32-byte Schnorr key\');\n        secp256k1_js_1.schnorr.utils.lift_x(secp256k1_js_1.schnorr.utils.bytesToNumberBE(pub));\n        return pub;\n    }\n    else {\n        throw new Error(\'Unknown key type\');\n    }\n}\nfunction tapTweak(a, b) {\n    const u = secp256k1_js_1.schnorr.utils;\n    const t = u.taggedHash(\'TapTweak\', a, b);\n    const tn = u.bytesToNumberBE(t);\n    if (tn >= CURVE_ORDER)\n        throw new Error(\'tweak higher than curve order\');\n    return tn;\n}\nfunction taprootTweakPrivKey(privKey, merkleRoot = Uint8Array.of()) {\n    const u = secp256k1_js_1.schnorr.utils;\n    const seckey0 = u.bytesToNumberBE(privKey); // seckey0 = int_from_bytes(seckey0)\n    const P = Point.fromPrivateKey(seckey0); // P = point_mul(G, seckey0)\n    // seckey = seckey0 if has_even_y(P) else SECP256K1_ORDER - seckey0\n    const seckey = P.hasEvenY() ? seckey0 : u.mod(-seckey0, CURVE_ORDER);\n    const xP = u.pointToBytes(P);\n    // t = int_from_bytes(tagged_hash("TapTweak", bytes_from_int(x(P)) + h)); >= SECP256K1_ORDER check\n    const t = tapTweak(xP, merkleRoot);\n    // bytes_from_int((seckey + t) % SECP256K1_ORDER)\n    return u.numberToBytesBE(u.mod(seckey + t, CURVE_ORDER), 32);\n}\nfunction taprootTweakPubkey(pubKey, h) {\n    const u = secp256k1_js_1.schnorr.utils;\n    const t = tapTweak(pubKey, h); // t = int_from_bytes(tagged_hash("TapTweak", pubkey + h))\n    const P = u.lift_x(u.bytesToNumberBE(pubKey)); // P = lift_x(int_from_bytes(pubkey))\n    const Q = P.add(Point.fromPrivateKey(t)); // Q = point_add(P, point_mul(G, t))\n    const parity = Q.hasEvenY() ? 0 : 1; // 0 if has_even_y(Q) else 1\n    return [u.pointToBytes(Q), parity]; // bytes_from_int(x(Q))\n}\n// Another stupid decision, where lack of standard affects security.\n// Multisig needs to be generated with some key.\n// We are using approach from BIP 341/bitcoinjs-lib: SHA256(uncompressedDER(SECP256K1_GENERATOR_POINT))\n// It is possible to switch SECP256K1_GENERATOR_POINT with some random point;\n// but it\'s too complex to prove.\n// Also used by bitcoin-core and bitcoinjs-lib\nexports.TAPROOT_UNSPENDABLE_KEY = (0, sha2_js_1.sha256)(Point.BASE.toRawBytes(false));\nexports.NETWORK = {\n    bech32: \'bc\',\n    pubKeyHash: 0x00,\n    scriptHash: 0x05,\n    wif: 0x80,\n};\nexports.TEST_NETWORK = {\n    bech32: \'tb\',\n    pubKeyHash: 0x6f,\n    scriptHash: 0xc4,\n    wif: 0xef,\n};\n// Exported for tests, internal method\nfunction compareBytes(a, b) {\n    if (!isBytes(a) || !isBytes(b))\n        throw new Error(`cmp: wrong type a=${typeof a} b=${typeof b}`);\n    // -1 -> a<b, 0 -> a==b, 1 -> a>b\n    const len = Math.min(a.length, b.length);\n    for (let i = 0; i < len; i++)\n        if (a[i] != b[i])\n            return Math.sign(a[i] - b[i]);\n    return Math.sign(a.length - b.length);\n}\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@scure/btc-signer/utils.js?\n}')},"./node_modules/@scure/btc-signer/utxo.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._Estimator = exports._cmpBig = void 0;\nexports.selectUTXO = selectUTXO;\nconst base_1 = __webpack_require__(/*! @scure/base */ \"./node_modules/@scure/base/lib/index.js\");\nconst P = __webpack_require__(/*! micro-packed */ \"./node_modules/micro-packed/lib/index.js\");\nconst payment_ts_1 = __webpack_require__(/*! ./payment.js */ \"./node_modules/@scure/btc-signer/payment.js\");\nconst psbt = __webpack_require__(/*! ./psbt.js */ \"./node_modules/@scure/btc-signer/psbt.js\");\nconst script_ts_1 = __webpack_require__(/*! ./script.js */ \"./node_modules/@scure/btc-signer/script.js\");\nconst transaction_ts_1 = __webpack_require__(/*! ./transaction.js */ \"./node_modules/@scure/btc-signer/transaction.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@scure/btc-signer/utils.js\");\nconst encodeTapBlock = (item) => psbt.TaprootControlBlock.encode(item);\nfunction iterLeafs(tapLeafScript, sigSize, customScripts) {\n    if (!tapLeafScript || !tapLeafScript.length)\n        throw new Error('no leafs');\n    const empty = () => new Uint8Array(sigSize);\n    // If user want to select specific leaf, which can signed,\n    // it is possible to remove all other leafs manually.\n    // Sort leafs by control block length.\n    const leafs = tapLeafScript.sort((a, b) => encodeTapBlock(a[0]).length - encodeTapBlock(b[0]).length);\n    for (const [cb, _script] of leafs) {\n        // Last byte is version\n        const script = _script.slice(0, -1);\n        const ver = _script[_script.length - 1];\n        const outs = payment_ts_1.OutScript.decode(script);\n        let signatures = [];\n        if (outs.type === 'tr_ms') {\n            const m = outs.m;\n            const n = outs.pubkeys.length - m;\n            for (let i = 0; i < m; i++)\n                signatures.push(empty());\n            for (let i = 0; i < n; i++)\n                signatures.push(P.EMPTY);\n        }\n        else if (outs.type === 'tr_ns') {\n            for (const _pub of outs.pubkeys)\n                signatures.push(empty());\n        }\n        else {\n            if (!customScripts)\n                throw new Error('Finalize: Unknown tapLeafScript');\n            const leafHash = (0, payment_ts_1.tapLeafHash)(script, ver);\n            for (const c of customScripts) {\n                if (!c.finalizeTaproot)\n                    continue;\n                const scriptDecoded = script_ts_1.Script.decode(script);\n                const csEncoded = c.encode(scriptDecoded);\n                if (csEncoded === undefined)\n                    continue;\n                const pubKeys = scriptDecoded.filter((i) => {\n                    if (!(0, utils_ts_1.isBytes)(i))\n                        return false;\n                    try {\n                        (0, utils_ts_1.validatePubkey)(i, utils_ts_1.PubT.schnorr);\n                        return true;\n                    }\n                    catch (e) {\n                        return false;\n                    }\n                });\n                const finalized = c.finalizeTaproot(script, csEncoded, pubKeys.map((pubKey) => [{ pubKey, leafHash }, empty()]));\n                if (!finalized)\n                    continue;\n                return finalized.concat(encodeTapBlock(cb));\n            }\n        }\n        // Witness is stack, so last element will be used first\n        return signatures.reverse().concat([script, encodeTapBlock(cb)]);\n    }\n    throw new Error('there was no witness');\n}\nfunction estimateInput(inputType, input, opts) {\n    let script = P.EMPTY;\n    let witness;\n    // schnorr sig is always 64 bytes. except for cases when sighash is not default!\n    if (inputType.txType === 'taproot') {\n        const SCHNORR_SIG_SIZE = inputType.sighash !== transaction_ts_1.SignatureHash.DEFAULT ? 65 : 64;\n        if (input.tapInternalKey && !(0, utils_ts_1.equalBytes)(input.tapInternalKey, utils_ts_1.TAPROOT_UNSPENDABLE_KEY)) {\n            witness = [new Uint8Array(SCHNORR_SIG_SIZE)];\n        }\n        else if (input.tapLeafScript) {\n            witness = iterLeafs(input.tapLeafScript, SCHNORR_SIG_SIZE, opts.customScripts);\n        }\n        else\n            throw new Error('estimateInput/taproot: unknown input');\n    }\n    else {\n        // It is possible to grind signatures until it has minimal size (but changing fee value +N satoshi),\n        // which will make estimations exact. But will be very hard for multi sig (need to make sure all signatures has small size).\n        const empty = () => new Uint8Array(72); // max size of sigs\n        const emptyPub = () => new Uint8Array(33); // size of pubkey\n        let inputScript = P.EMPTY;\n        let inputWitness = [];\n        const ltype = inputType.last.type;\n        if (ltype === 'ms') {\n            const m = inputType.last.m;\n            const sig = [0];\n            for (let i = 0; i < m; i++)\n                sig.push(empty());\n            inputScript = script_ts_1.Script.encode(sig);\n        }\n        else if (ltype === 'pk') {\n            // 71 sig + 1 sighash\n            inputScript = script_ts_1.Script.encode([empty()]);\n        }\n        else if (ltype === 'pkh') {\n            inputScript = script_ts_1.Script.encode([empty(), emptyPub()]);\n        }\n        else if (ltype === 'wpkh') {\n            inputScript = P.EMPTY;\n            inputWitness = [empty(), emptyPub()];\n        }\n        else if (ltype === 'unknown' && !opts.allowUnknownInputs)\n            throw new Error('Unknown inputs are not allowed');\n        if (inputType.type.includes('wsh-')) {\n            // P2WSH\n            if (inputScript.length && inputType.lastScript.length) {\n                inputWitness = script_ts_1.Script.decode(inputScript).map((i) => {\n                    if (i === 0)\n                        return P.EMPTY;\n                    if ((0, utils_ts_1.isBytes)(i))\n                        return i;\n                    throw new Error(`Wrong witness op=${i}`);\n                });\n            }\n            inputWitness = inputWitness.concat(inputType.lastScript);\n        }\n        if (inputType.txType === 'segwit')\n            witness = inputWitness;\n        if (inputType.type.startsWith('sh-wsh-')) {\n            script = script_ts_1.Script.encode([script_ts_1.Script.encode([0, new Uint8Array(utils_ts_1.sha256.outputLen)])]);\n        }\n        else if (inputType.type.startsWith('sh-')) {\n            script = script_ts_1.Script.encode([...script_ts_1.Script.decode(inputScript), inputType.lastScript]);\n        }\n        else if (inputType.type.startsWith('wsh-')) {\n        }\n        else if (inputType.txType !== 'segwit')\n            script = inputScript;\n    }\n    let weight = 160 + 4 * script_ts_1.VarBytes.encode(script).length;\n    let hasWitnesses = false;\n    if (witness) {\n        weight += script_ts_1.RawWitness.encode(witness).length;\n        hasWitnesses = true;\n    }\n    return { weight, hasWitnesses };\n}\n// Exported for tests, internal method\nconst _cmpBig = (a, b) => {\n    const n = a - b;\n    if (n < 0n)\n        return -1;\n    else if (n > 0n)\n        return 1;\n    return 0;\n};\nexports._cmpBig = _cmpBig;\nfunction getScript(o, opts = {}, network = utils_ts_1.NETWORK) {\n    let script;\n    if ('script' in o && (0, utils_ts_1.isBytes)(o.script)) {\n        script = o.script;\n    }\n    if ('address' in o) {\n        if (typeof o.address !== 'string')\n            throw new Error(`Estimator: wrong output address=${o.address}`);\n        script = payment_ts_1.OutScript.encode((0, payment_ts_1.Address)(network).decode(o.address));\n    }\n    if (!script)\n        throw new Error('Estimator: wrong output script');\n    if (typeof o.amount !== 'bigint')\n        throw new Error(`Estimator: wrong output amount=${o.amount}, should be of type bigint but got ${typeof o.amount}.`);\n    if (script && !opts.allowUnknownOutputs && payment_ts_1.OutScript.decode(script).type === 'unknown') {\n        throw new Error('Estimator: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure');\n    }\n    if (!opts.disableScriptCheck)\n        (0, payment_ts_1.checkScript)(script);\n    return script;\n}\n// class, because we need to re-use normalized inputs, instead of parsing each time\n// internal stuff, exported for tests only\nclass _Estimator {\n    constructor(inputs, outputs, opts) {\n        this.requiredIndices = [];\n        this.outputs = outputs;\n        this.opts = opts;\n        if (typeof opts.feePerByte !== 'bigint')\n            throw new Error(`Estimator: wrong feePerByte=${opts.feePerByte}, should be of type bigint but got ${typeof opts.feePerByte}.`);\n        // Dust stuff\n        // TODO: think about this more:\n        // - current dust filters tx which cannot be relayed by core\n        // - but actual dust meaning is 'can be this amount spent?'\n        // - dust contains full tx size. but we can use other inputs to pay for outputDust (and parially inputsDust)?\n        // - not sure if we can spent anything with feePerByte: 3. It will be relayed, but will it be mined?\n        // - for now it works exactly as bitcoin-core. But will create change/outputs which cannot be spent (reasonable).\n        // Number of bytes needed to create and spend a UTXO.\n        // https://github.com/bitcoin/bitcoin/blob/27a770b34b8f1dbb84760f442edb3e23a0c2420b/src/policy/policy.cpp#L28-L41\n        const inputsDust = 32 + 4 + 1 + 107 + 4; // NOTE: can be smaller for segwit tx?\n        const outputDust = 34; // NOTE: 'nSize = GetSerializeSize(txout)'\n        const dustBytes = opts.dust === undefined ? BigInt(inputsDust + outputDust) : opts.dust;\n        if (typeof dustBytes !== 'bigint') {\n            throw new Error(`Estimator: wrong dust=${opts.dust}, should be of type bigint but got ${typeof opts.dust}.`);\n        }\n        // 3 sat/vb is the default minimum fee rate used to calculate dust thresholds by bitcoin core.\n        // 3000 sat/kvb -> 3 sat/vb.\n        // https://github.com/bitcoin/bitcoin/blob/27a770b34b8f1dbb84760f442edb3e23a0c2420b/src/policy/policy.h#L55\n        const dustFee = opts.dustRelayFeeRate === undefined ? 3n : opts.dustRelayFeeRate;\n        if (typeof dustFee !== 'bigint') {\n            throw new Error(`Estimator: wrong dustRelayFeeRate=${opts.dustRelayFeeRate}, should be of type bigint but got ${typeof opts.dustRelayFeeRate}.`);\n        }\n        // Dust uses feePerbyte by default, but we allow separate dust fee if needed\n        this.dust = dustBytes * dustFee;\n        if (opts.requiredInputs !== undefined && !Array.isArray(opts.requiredInputs))\n            throw new Error(`Estimator: wrong required inputs=${opts.requiredInputs}`);\n        const network = opts.network || utils_ts_1.NETWORK;\n        let amount = 0n;\n        // Base weight: tx with outputs, no inputs\n        let baseWeight = 32;\n        for (const o of outputs) {\n            const script = getScript(o, opts, opts.network);\n            baseWeight += 32 + 4 * script_ts_1.VarBytes.encode(script).length;\n            amount += o.amount;\n        }\n        if (typeof opts.changeAddress !== 'string')\n            throw new Error(`Estimator: wrong change address=${opts.changeAddress}`);\n        let changeWeight = baseWeight +\n            32 +\n            4 * script_ts_1.VarBytes.encode(payment_ts_1.OutScript.encode((0, payment_ts_1.Address)(network).decode(opts.changeAddress))).length;\n        baseWeight += 4 * script_ts_1.CompactSizeLen.encode(outputs.length).length;\n        // If there a lot of outputs change can change fee\n        changeWeight += 4 * script_ts_1.CompactSizeLen.encode(outputs.length + 1).length;\n        this.baseWeight = baseWeight;\n        this.changeWeight = changeWeight;\n        this.amount = amount;\n        const allInputs = Array.from(inputs);\n        if (opts.requiredInputs) {\n            for (let i = 0; i < opts.requiredInputs.length; i++)\n                this.requiredIndices.push(allInputs.push(opts.requiredInputs[i]) - 1);\n        }\n        const inputKeys = new Set();\n        this.normalizedInputs = allInputs.map((i) => {\n            const normalized = (0, transaction_ts_1.normalizeInput)(i, undefined, undefined, opts.disableScriptCheck, opts.allowUnknown);\n            (0, transaction_ts_1.inputBeforeSign)(normalized); // check fields\n            const key = `${base_1.hex.encode(normalized.txid)}:${normalized.index}`;\n            if (!opts.allowSameUtxo && inputKeys.has(key))\n                throw new Error(`Estimator: same input passed multiple times: ${key}`);\n            inputKeys.add(key);\n            const inputType = (0, transaction_ts_1.getInputType)(normalized, opts.allowLegacyWitnessUtxo);\n            const prev = (0, transaction_ts_1.getPrevOut)(normalized);\n            const estimate = estimateInput(inputType, normalized, this.opts);\n            const value = prev.amount - opts.feePerByte * BigInt((0, transaction_ts_1.toVsize)(estimate.weight)); // value = amount-fee\n            return { inputType, normalized, amount: prev.amount, value, estimate };\n        });\n    }\n    checkInputIdx(idx) {\n        if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.normalizedInputs.length)\n            throw new Error(`Wrong input index=${idx}`);\n        return idx;\n    }\n    sortIndices(indices) {\n        return indices.slice().sort((a, b) => {\n            const ai = this.normalizedInputs[this.checkInputIdx(a)];\n            const bi = this.normalizedInputs[this.checkInputIdx(b)];\n            const out = (0, utils_ts_1.compareBytes)(ai.normalized.txid, bi.normalized.txid);\n            if (out !== 0)\n                return out;\n            return ai.normalized.index - bi.normalized.index;\n        });\n    }\n    sortOutputs(outputs) {\n        const scripts = outputs.map((o) => getScript(o, this.opts, this.opts.network));\n        const indices = outputs.map((_, j) => j);\n        return indices.sort((a, b) => {\n            const aa = outputs[a].amount;\n            const ba = outputs[b].amount;\n            const out = (0, exports._cmpBig)(aa, ba);\n            if (out !== 0)\n                return out;\n            return (0, utils_ts_1.compareBytes)(scripts[a], scripts[b]);\n        });\n    }\n    getSatoshi(weigth) {\n        return this.opts.feePerByte * BigInt((0, transaction_ts_1.toVsize)(weigth));\n    }\n    // Sort by value instead of amount\n    get biggest() {\n        return this.normalizedInputs\n            .map((_i, j) => j)\n            .sort((a, b) => (0, exports._cmpBig)(this.normalizedInputs[b].value, this.normalizedInputs[a].value));\n    }\n    get smallest() {\n        return this.biggest.reverse();\n    }\n    // These assume that UTXO array has historical order.\n    // Otherwise, we have no way to know which tx is oldest\n    // Explorers usually give UTXO in this order.\n    get oldest() {\n        return this.normalizedInputs.map((_i, j) => j);\n    }\n    get newest() {\n        return this.oldest.reverse();\n    }\n    // exact - like blackjack from coinselect.\n    // exact(biggest) will select one big utxo which is closer to targetValue+dust, if possible.\n    // If not, it will accumulate largest utxo until value is close to targetValue+dust.\n    accumulate(indices, exact = false, skipNegative = true, all = false) {\n        // TODO: how to handle change addresses?\n        // - cost of input\n        // - cost of change output (if input requires change)\n        // - cost of output spending\n        // Dust threshold should be significantly bigger, no point in\n        // creating an output, which cannot be spent.\n        // coinselect doesn't consider cost of output address for dust.\n        // Changing that can actually reduce privacy\n        let weight = this.opts.alwaysChange ? this.changeWeight : this.baseWeight;\n        let hasWitnesses = false;\n        let num = 0;\n        let inputsAmount = 0n;\n        const targetAmount = this.amount;\n        const res = new Set();\n        let fee;\n        for (const idx of this.requiredIndices) {\n            this.checkInputIdx(idx);\n            if (res.has(idx))\n                throw new Error('required input encountered multiple times'); // should not happen\n            const { estimate, amount } = this.normalizedInputs[idx];\n            let newWeight = weight + estimate.weight;\n            if (!hasWitnesses && estimate.hasWitnesses)\n                newWeight += 2; // enable witness if needed\n            const totalWeight = newWeight + 4 * script_ts_1.CompactSizeLen.encode(num).length; // number of outputs can change weight\n            fee = this.getSatoshi(totalWeight);\n            weight = newWeight;\n            if (estimate.hasWitnesses)\n                hasWitnesses = true;\n            num++;\n            inputsAmount += amount;\n            res.add(idx);\n            // inputsAmount is enough to cover cost of tx\n            if (!all && targetAmount + fee <= inputsAmount && num >= this.requiredIndices.length)\n                return { indices: Array.from(res), fee, weight: totalWeight, total: inputsAmount };\n        }\n        for (const idx of indices) {\n            this.checkInputIdx(idx);\n            if (res.has(idx))\n                continue; // skip required inputs\n            const { estimate, amount, value } = this.normalizedInputs[idx];\n            let newWeight = weight + estimate.weight;\n            if (!hasWitnesses && estimate.hasWitnesses)\n                newWeight += 2; // enable witness if needed\n            const totalWeight = newWeight + 4 * script_ts_1.CompactSizeLen.encode(num).length; // number of outputs can change weight\n            fee = this.getSatoshi(totalWeight);\n            // Best case scenario exact(biggest) -> we find biggest output, less than target+threshold\n            if (exact && amount + inputsAmount > targetAmount + fee + this.dust)\n                continue; // skip if added value is bigger than dust\n            // Negative: cost of using input is more than value provided (negative)\n            // By default 'blackjack' mode in coinselect doesn't use that, which means\n            // it will use negative output if sorted by 'smallest'\n            if (skipNegative && value <= 0n)\n                continue;\n            weight = newWeight;\n            if (estimate.hasWitnesses)\n                hasWitnesses = true;\n            num++;\n            inputsAmount += amount;\n            res.add(idx);\n            // inputsAmount is enough to cover cost of tx\n            if (!all && targetAmount + fee <= inputsAmount)\n                return { indices: Array.from(res), fee, weight: totalWeight, total: inputsAmount };\n        }\n        if (all) {\n            const newWeight = weight + 4 * script_ts_1.CompactSizeLen.encode(num).length;\n            return { indices: Array.from(res), fee, weight: newWeight, total: inputsAmount };\n        }\n        return undefined;\n    }\n    // Works like coinselect default method\n    default() {\n        const { biggest } = this;\n        const exact = this.accumulate(biggest, true, false);\n        if (exact)\n            return exact;\n        return this.accumulate(biggest);\n    }\n    select(strategy) {\n        if (strategy === 'all') {\n            return this.accumulate(this.normalizedInputs.map((_, j) => j), false, true, true);\n        }\n        if (strategy === 'default')\n            return this.default();\n        const data = {\n            Oldest: () => this.oldest,\n            Newest: () => this.newest,\n            Smallest: () => this.smallest,\n            Biggest: () => this.biggest,\n        };\n        if (strategy.startsWith('exact')) {\n            const [exactData, left] = strategy.slice(5).split('/');\n            if (!data[exactData])\n                throw new Error(`Estimator.select: wrong strategy=${strategy}`);\n            strategy = left;\n            const exact = this.accumulate(data[exactData](), true, true);\n            if (exact)\n                return exact;\n        }\n        if (strategy.startsWith('accum')) {\n            const accumData = strategy.slice(5);\n            if (!data[accumData])\n                throw new Error(`Estimator.select: wrong strategy=${strategy}`);\n            return this.accumulate(data[accumData]());\n        }\n        throw new Error(`Estimator.select: wrong strategy=${strategy}`);\n    }\n    result(strategy) {\n        const s = this.select(strategy);\n        if (!s)\n            return;\n        const { indices, weight, total } = s;\n        let needChange = this.opts.alwaysChange;\n        const changeWeight = this.opts.alwaysChange\n            ? weight\n            : weight + (this.changeWeight - this.baseWeight);\n        const changeFee = this.getSatoshi(changeWeight);\n        let fee = s.fee;\n        const change = total - this.amount - changeFee;\n        if (change > this.dust)\n            needChange = true;\n        let inputs = indices;\n        let outputs = Array.from(this.outputs);\n        if (needChange) {\n            fee = changeFee;\n            // this shouldn't happen!\n            if (change < 0n)\n                throw new Error(`Estimator.result: negative change=${change}`);\n            outputs.push({ address: this.opts.changeAddress, amount: change });\n        }\n        if (this.opts.bip69) {\n            inputs = this.sortIndices(inputs);\n            outputs = this.sortOutputs(outputs).map((i) => outputs[i]);\n        }\n        const res = {\n            inputs: inputs.map((i) => this.normalizedInputs[i].normalized),\n            outputs,\n            fee,\n            weight: this.opts.alwaysChange ? s.weight : changeWeight,\n            change: !!needChange,\n        };\n        let tx;\n        if (this.opts.createTx) {\n            const { inputs, outputs } = res;\n            tx = new transaction_ts_1.Transaction(this.opts);\n            for (const i of inputs)\n                tx.addInput(i);\n            for (const o of outputs)\n                tx.addOutput({ ...o, script: getScript(o, this.opts, this.opts.network) });\n        }\n        return Object.assign(res, { tx });\n        // return { ...res, tx: tx };\n    }\n}\nexports._Estimator = _Estimator;\nfunction selectUTXO(inputs, outputs, strategy, opts) {\n    // Defaults: do we want bip69 by default?\n    const _opts = { createTx: true, bip69: true, ...opts };\n    const est = new _Estimator(inputs, outputs, _opts);\n    return est.result(strategy);\n}\n//# sourceMappingURL=utxo.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/@scure/btc-signer/utxo.js?\n}")},"./node_modules/bip68/index.js":module=>{eval("{// see https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki#compatibility\n\nconst SEQUENCE_FINAL = 0xffffffff\nconst SEQUENCE_LOCKTIME_DISABLE_FLAG = (1 << 31)\nconst SEQUENCE_LOCKTIME_GRANULARITY = 9\nconst SEQUENCE_LOCKTIME_MASK = 0x0000ffff\nconst SEQUENCE_LOCKTIME_TYPE_FLAG = (1 << 22)\n\nconst BLOCKS_MAX = SEQUENCE_LOCKTIME_MASK\nconst SECONDS_MOD = 1 << SEQUENCE_LOCKTIME_GRANULARITY\nconst SECONDS_MAX = SEQUENCE_LOCKTIME_MASK << SEQUENCE_LOCKTIME_GRANULARITY\n\nfunction decode (sequence) {\n  if (sequence & SEQUENCE_LOCKTIME_DISABLE_FLAG) return {}\n  if (sequence & SEQUENCE_LOCKTIME_TYPE_FLAG) {\n    return {\n      seconds: (sequence & SEQUENCE_LOCKTIME_MASK) << SEQUENCE_LOCKTIME_GRANULARITY\n    }\n  }\n\n  return {\n    blocks: sequence & SEQUENCE_LOCKTIME_MASK\n  }\n}\n\nfunction encode ({ blocks, seconds }) {\n  if (blocks !== undefined && seconds !== undefined) throw new TypeError('Cannot encode blocks AND seconds')\n  if (blocks === undefined && seconds === undefined) return SEQUENCE_FINAL // neither? assume final\n\n  if (seconds !== undefined) {\n    if (!Number.isFinite(seconds)) throw new TypeError('Expected Number seconds')\n    if (seconds > SECONDS_MAX) throw new TypeError('Expected Number seconds <= ' + SECONDS_MAX)\n    if (seconds % SECONDS_MOD !== 0) throw new TypeError('Expected Number seconds as a multiple of ' + SECONDS_MOD)\n\n    return SEQUENCE_LOCKTIME_TYPE_FLAG | (seconds >> SEQUENCE_LOCKTIME_GRANULARITY)\n  }\n\n  if (!Number.isFinite(blocks)) throw new TypeError('Expected Number blocks')\n  if (blocks > SEQUENCE_LOCKTIME_MASK) throw new TypeError('Expected Number blocks <= ' + BLOCKS_MAX)\n\n  return blocks\n}\n\nmodule.exports = { decode, encode }\n\n\n//# sourceURL=webpack://ArkSDK/./node_modules/bip68/index.js?\n}")},"./node_modules/micro-packed/lib/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._TEST = exports.ZeroPad = exports.magicBytes = exports.flag = exports.cstring = exports.string = exports.hex = exports.bytes = exports.bool = exports.F64LE = exports.F64BE = exports.F32LE = exports.F32BE = exports.I8 = exports.U8 = exports.I16BE = exports.I16LE = exports.U16BE = exports.U16LE = exports.I32BE = exports.I32LE = exports.U32BE = exports.U32LE = exports.int = exports.I64BE = exports.I64LE = exports.U64BE = exports.U64LE = exports.I128BE = exports.I128LE = exports.U128BE = exports.U128LE = exports.I256BE = exports.I256LE = exports.U256BE = exports.U256LE = exports.bigint = exports.bits = exports.coders = exports.wrap = exports.utils = exports.NULL = exports.EMPTY = void 0;\nexports.validate = validate;\nexports.isCoder = isCoder;\nexports.prefix = prefix;\nexports.apply = apply;\nexports.lazy = lazy;\nexports.flagged = flagged;\nexports.optional = optional;\nexports.magic = magic;\nexports.constant = constant;\nexports.struct = struct;\nexports.tuple = tuple;\nexports.array = array;\nexports.map = map;\nexports.tag = tag;\nexports.mappedTag = mappedTag;\nexports.bitset = bitset;\nexports.padLeft = padLeft;\nexports.padRight = padRight;\nexports.pointer = pointer;\nconst base_1 = __webpack_require__(/*! @scure/base */ \"./node_modules/@scure/base/lib/index.js\");\n/**\n * Define complex binary structures using composable primitives.\n * Main ideas:\n * - Encode / decode can be chained, same as in `scure-base`\n * - A complex structure can be created from an array and struct of primitive types\n * - Strings / bytes are arrays with specific optimizations: we can just read bytes directly\n *   without creating plain array first and reading each byte separately.\n * - Types are inferred from definition\n * @module\n * @example\n * import * as P from 'micro-packed';\n * const s = P.struct({\n *   field1: P.U32BE, // 32-bit unsigned big-endian integer\n *   field2: P.string(P.U8), // String with U8 length prefix\n *   field3: P.bytes(32), // 32 bytes\n *   field4: P.array(P.U16BE, P.struct({ // Array of structs with U16BE length\n *     subField1: P.U64BE, // 64-bit unsigned big-endian integer\n *     subField2: P.string(10) // 10-byte string\n *   }))\n * });\n */\n// TODO: remove dependency on scure-base & inline?\n/*\nExports can be groupped like this:\n\n- Primitive types: P.bytes, P.string, P.hex, P.constant, P.pointer\n- Complex types: P.array, P.struct, P.tuple, P.map, P.tag, P.mappedTag\n- Padding, prefix, magic: P.padLeft, P.padRight, P.prefix, P.magic, P.magicBytes\n- Flags: P.flag, P.flagged, P.optional\n- Wrappers: P.apply, P.wrap, P.lazy\n- Bit fiddling: P.bits, P.bitset\n- utils: P.validate, coders.decimal\n- Debugger\n*/\n/** Shortcut to zero-length (empty) byte array */\nexports.EMPTY = new Uint8Array();\n/** Shortcut to one-element (element is 0) byte array */\nexports.NULL = new Uint8Array([0]);\n/** Checks if two Uint8Arrays are equal. Not constant-time. */\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] !== b[i])\n            return false;\n    return true;\n}\n/** Checks if the given value is a Uint8Array. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/**\n * Concatenates multiple Uint8Arrays.\n * Engines limit functions to 65K+ arguments.\n * @param arrays Array of Uint8Array elements\n * @returns Concatenated Uint8Array\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n/**\n * Creates DataView from Uint8Array\n * @param arr - bytes\n * @returns DataView\n */\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n/**\n * Checks if the provided value is a plain object, not created from any class or special constructor.\n * Array, Uint8Array and others are not plain objects.\n * @param obj - The value to be checked.\n */\nfunction isPlainObject(obj) {\n    return Object.prototype.toString.call(obj) === '[object Object]';\n}\nfunction isNum(num) {\n    return Number.isSafeInteger(num);\n}\nexports.utils = {\n    equalBytes,\n    isBytes,\n    isCoder,\n    checkBounds,\n    concatBytes,\n    createView,\n    isPlainObject,\n};\n// NOTE: we can't have terminator separate function, since it won't know about boundaries\n// E.g. array of U16LE ([1,2,3]) would be [1, 0, 2, 0, 3, 0]\n// But terminator will find array at index '1', which happens to be inside of an element itself\n/**\n * Can be:\n * - Dynamic (CoderType)\n * - Fixed (number)\n * - Terminated (usually zero): Uint8Array with terminator\n * - Field path to field with length (string)\n * - Infinity (null) - decodes until end of buffer\n * Used in:\n * - bytes (string, prefix is implementation of bytes)\n * - array\n */\nconst lengthCoder = (len) => {\n    if (len !== null && typeof len !== 'string' && !isCoder(len) && !isBytes(len) && !isNum(len)) {\n        throw new Error(`lengthCoder: expected null | number | Uint8Array | CoderType, got ${len} (${typeof len})`);\n    }\n    return {\n        encodeStream(w, value) {\n            if (len === null)\n                return;\n            if (isCoder(len))\n                return len.encodeStream(w, value);\n            let byteLen;\n            if (typeof len === 'number')\n                byteLen = len;\n            else if (typeof len === 'string')\n                byteLen = Path.resolve(w.stack, len);\n            if (typeof byteLen === 'bigint')\n                byteLen = Number(byteLen);\n            if (byteLen === undefined || byteLen !== value)\n                throw w.err(`Wrong length: ${byteLen} len=${len} exp=${value} (${typeof value})`);\n        },\n        decodeStream(r) {\n            let byteLen;\n            if (isCoder(len))\n                byteLen = Number(len.decodeStream(r));\n            else if (typeof len === 'number')\n                byteLen = len;\n            else if (typeof len === 'string')\n                byteLen = Path.resolve(r.stack, len);\n            if (typeof byteLen === 'bigint')\n                byteLen = Number(byteLen);\n            if (typeof byteLen !== 'number')\n                throw r.err(`Wrong length: ${byteLen}`);\n            return byteLen;\n        },\n    };\n};\n/**\n * Small bitset structure to store position of ranges that have been read.\n * Can be more efficient when internal trees are utilized at the cost of complexity.\n * Needs `O(N/8)` memory for parsing.\n * Purpose: if there are pointers in parsed structure,\n * they can cause read of two distinct ranges:\n * [0-32, 64-128], which means 'pos' is not enough to handle them\n */\nconst Bitset = {\n    BITS: 32,\n    FULL_MASK: -1 >>> 0, // 1<<32 will overflow\n    len: (len) => Math.ceil(len / 32),\n    create: (len) => new Uint32Array(Bitset.len(len)),\n    clean: (bs) => bs.fill(0),\n    debug: (bs) => Array.from(bs).map((i) => (i >>> 0).toString(2).padStart(32, '0')),\n    checkLen: (bs, len) => {\n        if (Bitset.len(len) === bs.length)\n            return;\n        throw new Error(`wrong length=${bs.length}. Expected: ${Bitset.len(len)}`);\n    },\n    chunkLen: (bsLen, pos, len) => {\n        if (pos < 0)\n            throw new Error(`wrong pos=${pos}`);\n        if (pos + len > bsLen)\n            throw new Error(`wrong range=${pos}/${len} of ${bsLen}`);\n    },\n    set: (bs, chunk, value, allowRewrite = true) => {\n        if (!allowRewrite && (bs[chunk] & value) !== 0)\n            return false;\n        bs[chunk] |= value;\n        return true;\n    },\n    pos: (pos, i) => ({\n        chunk: Math.floor((pos + i) / 32),\n        mask: 1 << (32 - ((pos + i) % 32) - 1),\n    }),\n    indices: (bs, len, invert = false) => {\n        Bitset.checkLen(bs, len);\n        const { FULL_MASK, BITS } = Bitset;\n        const left = BITS - (len % BITS);\n        const lastMask = left ? (FULL_MASK >>> left) << left : FULL_MASK;\n        const res = [];\n        for (let i = 0; i < bs.length; i++) {\n            let c = bs[i];\n            if (invert)\n                c = ~c; // allows to gen unset elements\n            // apply mask to last element, so we won't iterate non-existent items\n            if (i === bs.length - 1)\n                c &= lastMask;\n            if (c === 0)\n                continue; // fast-path\n            for (let j = 0; j < BITS; j++) {\n                const m = 1 << (BITS - j - 1);\n                if (c & m)\n                    res.push(i * BITS + j);\n            }\n        }\n        return res;\n    },\n    range: (arr) => {\n        const res = [];\n        let cur;\n        for (const i of arr) {\n            if (cur === undefined || i !== cur.pos + cur.length)\n                res.push((cur = { pos: i, length: 1 }));\n            else\n                cur.length += 1;\n        }\n        return res;\n    },\n    rangeDebug: (bs, len, invert = false) => `[${Bitset.range(Bitset.indices(bs, len, invert))\n        .map((i) => `(${i.pos}/${i.length})`)\n        .join(', ')}]`,\n    setRange: (bs, bsLen, pos, len, allowRewrite = true) => {\n        Bitset.chunkLen(bsLen, pos, len);\n        const { FULL_MASK, BITS } = Bitset;\n        // Try to set range with maximum efficiency:\n        // - first chunk is always    '0000[1111]' (only right ones)\n        // - middle chunks are set to '[1111 1111]' (all ones)\n        // - last chunk is always     '[1111]0000' (only left ones)\n        // - max operations:          (N/32) + 2 (first and last)\n        const first = pos % BITS ? Math.floor(pos / BITS) : undefined;\n        const lastPos = pos + len;\n        const last = lastPos % BITS ? Math.floor(lastPos / BITS) : undefined;\n        // special case, whole range inside single chunk\n        if (first !== undefined && first === last)\n            return Bitset.set(bs, first, (FULL_MASK >>> (BITS - len)) << (BITS - len - pos), allowRewrite);\n        if (first !== undefined) {\n            if (!Bitset.set(bs, first, FULL_MASK >>> pos % BITS, allowRewrite))\n                return false; // first chunk\n        }\n        // middle chunks\n        const start = first !== undefined ? first + 1 : pos / BITS;\n        const end = last !== undefined ? last : lastPos / BITS;\n        for (let i = start; i < end; i++)\n            if (!Bitset.set(bs, i, FULL_MASK, allowRewrite))\n                return false;\n        if (last !== undefined && first !== last)\n            if (!Bitset.set(bs, last, FULL_MASK << (BITS - (lastPos % BITS)), allowRewrite))\n                return false; // last chunk\n        return true;\n    },\n};\nconst Path = {\n    /**\n     * Internal method for handling stack of paths (debug, errors, dynamic fields via path)\n     * This is looks ugly (callback), but allows us to force stack cleaning by construction (.pop always after function).\n     * Also, this makes impossible:\n     * - pushing field when stack is empty\n     * - pushing field inside of field (real bug)\n     * NOTE: we don't want to do '.pop' on error!\n     */\n    pushObj: (stack, obj, objFn) => {\n        const last = { obj };\n        stack.push(last);\n        objFn((field, fieldFn) => {\n            last.field = field;\n            fieldFn();\n            last.field = undefined;\n        });\n        stack.pop();\n    },\n    path: (stack) => {\n        const res = [];\n        for (const i of stack)\n            if (i.field !== undefined)\n                res.push(i.field);\n        return res.join('/');\n    },\n    err: (name, stack, msg) => {\n        const err = new Error(`${name}(${Path.path(stack)}): ${typeof msg === 'string' ? msg : msg.message}`);\n        if (msg instanceof Error && msg.stack)\n            err.stack = msg.stack;\n        return err;\n    },\n    resolve: (stack, path) => {\n        const parts = path.split('/');\n        const objPath = stack.map((i) => i.obj);\n        let i = 0;\n        for (; i < parts.length; i++) {\n            if (parts[i] === '..')\n                objPath.pop();\n            else\n                break;\n        }\n        let cur = objPath.pop();\n        for (; i < parts.length; i++) {\n            if (!cur || cur[parts[i]] === undefined)\n                return undefined;\n            cur = cur[parts[i]];\n        }\n        return cur;\n    },\n};\n/**\n * Internal structure. Reader class for reading from a byte array.\n * `stack` is internal: for debugger and logging\n * @class Reader\n */\nclass _Reader {\n    constructor(data, opts = {}, stack = [], parent = undefined, parentOffset = 0) {\n        this.pos = 0;\n        this.bitBuf = 0;\n        this.bitPos = 0;\n        this.data = data;\n        this.opts = opts;\n        this.stack = stack;\n        this.parent = parent;\n        this.parentOffset = parentOffset;\n        this.view = createView(data);\n    }\n    /** Internal method for pointers. */\n    _enablePointers() {\n        if (this.parent)\n            return this.parent._enablePointers();\n        if (this.bs)\n            return;\n        this.bs = Bitset.create(this.data.length);\n        Bitset.setRange(this.bs, this.data.length, 0, this.pos, this.opts.allowMultipleReads);\n    }\n    markBytesBS(pos, len) {\n        if (this.parent)\n            return this.parent.markBytesBS(this.parentOffset + pos, len);\n        if (!len)\n            return true;\n        if (!this.bs)\n            return true;\n        return Bitset.setRange(this.bs, this.data.length, pos, len, false);\n    }\n    markBytes(len) {\n        const pos = this.pos;\n        this.pos += len;\n        const res = this.markBytesBS(pos, len);\n        if (!this.opts.allowMultipleReads && !res)\n            throw this.err(`multiple read pos=${this.pos} len=${len}`);\n        return res;\n    }\n    pushObj(obj, objFn) {\n        return Path.pushObj(this.stack, obj, objFn);\n    }\n    readView(n, fn) {\n        if (!Number.isFinite(n))\n            throw this.err(`readView: wrong length=${n}`);\n        if (this.pos + n > this.data.length)\n            throw this.err('readView: Unexpected end of buffer');\n        const res = fn(this.view, this.pos);\n        this.markBytes(n);\n        return res;\n    }\n    // read bytes by absolute offset\n    absBytes(n) {\n        if (n > this.data.length)\n            throw new Error('Unexpected end of buffer');\n        return this.data.subarray(n);\n    }\n    finish() {\n        if (this.opts.allowUnreadBytes)\n            return;\n        if (this.bitPos) {\n            throw this.err(`${this.bitPos} bits left after unpack: ${base_1.hex.encode(this.data.slice(this.pos))}`);\n        }\n        if (this.bs && !this.parent) {\n            const notRead = Bitset.indices(this.bs, this.data.length, true);\n            if (notRead.length) {\n                const formatted = Bitset.range(notRead)\n                    .map(({ pos, length }) => `(${pos}/${length})[${base_1.hex.encode(this.data.subarray(pos, pos + length))}]`)\n                    .join(', ');\n                throw this.err(`unread byte ranges: ${formatted} (total=${this.data.length})`);\n            }\n            else\n                return; // all bytes read, everything is ok\n        }\n        // Default: no pointers enabled\n        if (!this.isEnd()) {\n            throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${base_1.hex.encode(this.data.slice(this.pos))}`);\n        }\n    }\n    // User methods\n    err(msg) {\n        return Path.err('Reader', this.stack, msg);\n    }\n    offsetReader(n) {\n        if (n > this.data.length)\n            throw this.err('offsetReader: Unexpected end of buffer');\n        return new _Reader(this.absBytes(n), this.opts, this.stack, this, n);\n    }\n    bytes(n, peek = false) {\n        if (this.bitPos)\n            throw this.err('readBytes: bitPos not empty');\n        if (!Number.isFinite(n))\n            throw this.err(`readBytes: wrong length=${n}`);\n        if (this.pos + n > this.data.length)\n            throw this.err('readBytes: Unexpected end of buffer');\n        const slice = this.data.subarray(this.pos, this.pos + n);\n        if (!peek)\n            this.markBytes(n);\n        return slice;\n    }\n    byte(peek = false) {\n        if (this.bitPos)\n            throw this.err('readByte: bitPos not empty');\n        if (this.pos + 1 > this.data.length)\n            throw this.err('readBytes: Unexpected end of buffer');\n        const data = this.data[this.pos];\n        if (!peek)\n            this.markBytes(1);\n        return data;\n    }\n    get leftBytes() {\n        return this.data.length - this.pos;\n    }\n    get totalBytes() {\n        return this.data.length;\n    }\n    isEnd() {\n        return this.pos >= this.data.length && !this.bitPos;\n    }\n    // bits are read in BE mode (left to right): (0b1000_0000).readBits(1) == 1\n    bits(bits) {\n        if (bits > 32)\n            throw this.err('BitReader: cannot read more than 32 bits in single call');\n        let out = 0;\n        while (bits) {\n            if (!this.bitPos) {\n                this.bitBuf = this.byte();\n                this.bitPos = 8;\n            }\n            const take = Math.min(bits, this.bitPos);\n            this.bitPos -= take;\n            out = (out << take) | ((this.bitBuf >> this.bitPos) & (2 ** take - 1));\n            this.bitBuf &= 2 ** this.bitPos - 1;\n            bits -= take;\n        }\n        // Fix signed integers\n        return out >>> 0;\n    }\n    find(needle, pos = this.pos) {\n        if (!isBytes(needle))\n            throw this.err(`find: needle is not bytes! ${needle}`);\n        if (this.bitPos)\n            throw this.err('findByte: bitPos not empty');\n        if (!needle.length)\n            throw this.err(`find: needle is empty`);\n        // indexOf should be faster than full equalBytes check\n        for (let idx = pos; (idx = this.data.indexOf(needle[0], idx)) !== -1; idx++) {\n            if (idx === -1)\n                return;\n            const leftBytes = this.data.length - idx;\n            if (leftBytes < needle.length)\n                return;\n            if (equalBytes(needle, this.data.subarray(idx, idx + needle.length)))\n                return idx;\n        }\n        return;\n    }\n}\n/**\n * Internal structure. Writer class for writing to a byte array.\n * The `stack` argument of constructor is internal, for debugging and logs.\n * @class Writer\n */\nclass _Writer {\n    constructor(stack = []) {\n        this.pos = 0;\n        // We could have a single buffer here and re-alloc it with\n        // x1.5-2 size each time it full, but it will be slower:\n        // basic/encode bench: 395ns -> 560ns\n        this.buffers = [];\n        this.ptrs = [];\n        this.bitBuf = 0;\n        this.bitPos = 0;\n        this.viewBuf = new Uint8Array(8);\n        this.finished = false;\n        this.stack = stack;\n        this.view = createView(this.viewBuf);\n    }\n    pushObj(obj, objFn) {\n        return Path.pushObj(this.stack, obj, objFn);\n    }\n    writeView(len, fn) {\n        if (this.finished)\n            throw this.err('buffer: finished');\n        if (!isNum(len) || len > 8)\n            throw new Error(`wrong writeView length=${len}`);\n        fn(this.view);\n        this.bytes(this.viewBuf.slice(0, len));\n        this.viewBuf.fill(0);\n    }\n    // User methods\n    err(msg) {\n        if (this.finished)\n            throw this.err('buffer: finished');\n        return Path.err('Reader', this.stack, msg);\n    }\n    bytes(b) {\n        if (this.finished)\n            throw this.err('buffer: finished');\n        if (this.bitPos)\n            throw this.err('writeBytes: ends with non-empty bit buffer');\n        this.buffers.push(b);\n        this.pos += b.length;\n    }\n    byte(b) {\n        if (this.finished)\n            throw this.err('buffer: finished');\n        if (this.bitPos)\n            throw this.err('writeByte: ends with non-empty bit buffer');\n        this.buffers.push(new Uint8Array([b]));\n        this.pos++;\n    }\n    finish(clean = true) {\n        if (this.finished)\n            throw this.err('buffer: finished');\n        if (this.bitPos)\n            throw this.err('buffer: ends with non-empty bit buffer');\n        // Can't use concatBytes, because it limits amount of arguments (65K).\n        const buffers = this.buffers.concat(this.ptrs.map((i) => i.buffer));\n        const sum = buffers.map((b) => b.length).reduce((a, b) => a + b, 0);\n        const buf = new Uint8Array(sum);\n        for (let i = 0, pad = 0; i < buffers.length; i++) {\n            const a = buffers[i];\n            buf.set(a, pad);\n            pad += a.length;\n        }\n        for (let pos = this.pos, i = 0; i < this.ptrs.length; i++) {\n            const ptr = this.ptrs[i];\n            buf.set(ptr.ptr.encode(pos), ptr.pos);\n            pos += ptr.buffer.length;\n        }\n        // Cleanup\n        if (clean) {\n            // We cannot cleanup buffers here, since it can be static user provided buffer.\n            // Only '.byte' and '.bits' create buffer which we can safely clean.\n            // for (const b of this.buffers) b.fill(0);\n            this.buffers = [];\n            for (const p of this.ptrs)\n                p.buffer.fill(0);\n            this.ptrs = [];\n            this.finished = true;\n            this.bitBuf = 0;\n        }\n        return buf;\n    }\n    bits(value, bits) {\n        if (bits > 32)\n            throw this.err('writeBits: cannot write more than 32 bits in single call');\n        if (value >= 2 ** bits)\n            throw this.err(`writeBits: value (${value}) >= 2**bits (${bits})`);\n        while (bits) {\n            const take = Math.min(bits, 8 - this.bitPos);\n            this.bitBuf = (this.bitBuf << take) | (value >> (bits - take));\n            this.bitPos += take;\n            bits -= take;\n            value &= 2 ** bits - 1;\n            if (this.bitPos === 8) {\n                this.bitPos = 0;\n                this.buffers.push(new Uint8Array([this.bitBuf]));\n                this.pos++;\n            }\n        }\n    }\n}\n// Immutable LE<->BE\nconst swapEndianness = (b) => Uint8Array.from(b).reverse();\n/** Internal function for checking bit bounds of bigint in signed/unsinged form */\nfunction checkBounds(value, bits, signed) {\n    if (signed) {\n        // [-(2**(32-1)), 2**(32-1)-1]\n        const signBit = 2n ** (bits - 1n);\n        if (value < -signBit || value >= signBit)\n            throw new Error(`value out of signed bounds. Expected ${-signBit} <= ${value} < ${signBit}`);\n    }\n    else {\n        // [0, 2**32-1]\n        if (0n > value || value >= 2n ** bits)\n            throw new Error(`value out of unsigned bounds. Expected 0 <= ${value} < ${2n ** bits}`);\n    }\n}\nfunction _wrap(inner) {\n    return {\n        // NOTE: we cannot export validate here, since it is likely mistake.\n        encodeStream: inner.encodeStream,\n        decodeStream: inner.decodeStream,\n        size: inner.size,\n        encode: (value) => {\n            const w = new _Writer();\n            inner.encodeStream(w, value);\n            return w.finish();\n        },\n        decode: (data, opts = {}) => {\n            const r = new _Reader(data, opts);\n            const res = inner.decodeStream(r);\n            r.finish();\n            return res;\n        },\n    };\n}\n/**\n * Validates a value before encoding and after decoding using a provided function.\n * @param inner - The inner CoderType.\n * @param fn - The validation function.\n * @returns CoderType which check value with validation function.\n * @example\n * const val = (n: number) => {\n *   if (n > 10) throw new Error(`${n} > 10`);\n *   return n;\n * };\n *\n * const RangedInt = P.validate(P.U32LE, val); // Will check if value is <= 10 during encoding and decoding\n */\nfunction validate(inner, fn) {\n    if (!isCoder(inner))\n        throw new Error(`validate: invalid inner value ${inner}`);\n    if (typeof fn !== 'function')\n        throw new Error('validate: fn should be function');\n    return _wrap({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            let res;\n            try {\n                res = fn(value);\n            }\n            catch (e) {\n                throw w.err(e);\n            }\n            inner.encodeStream(w, res);\n        },\n        decodeStream: (r) => {\n            const res = inner.decodeStream(r);\n            try {\n                return fn(res);\n            }\n            catch (e) {\n                throw r.err(e);\n            }\n        },\n    });\n}\n/**\n * Wraps a stream encoder into a generic encoder and optionally validation function\n * @param {inner} inner BytesCoderStream & { validate?: Validate<T> }.\n * @returns The wrapped CoderType.\n * @example\n * const U8 = P.wrap({\n *   encodeStream: (w: Writer, value: number) => w.byte(value),\n *   decodeStream: (r: Reader): number => r.byte()\n * });\n * const checkedU8 = P.wrap({\n *   encodeStream: (w: Writer, value: number) => w.byte(value),\n *   decodeStream: (r: Reader): number => r.byte()\n *   validate: (n: number) => {\n *    if (n > 10) throw new Error(`${n} > 10`);\n *    return n;\n *   }\n * });\n */\nconst wrap = (inner) => {\n    const res = _wrap(inner);\n    return inner.validate ? validate(res, inner.validate) : res;\n};\nexports.wrap = wrap;\nconst isBaseCoder = (elm) => isPlainObject(elm) && typeof elm.decode === 'function' && typeof elm.encode === 'function';\n/**\n * Checks if the given value is a CoderType.\n * @param elm - The value to check.\n * @returns True if the value is a CoderType, false otherwise.\n */\nfunction isCoder(elm) {\n    return (isPlainObject(elm) &&\n        isBaseCoder(elm) &&\n        typeof elm.encodeStream === 'function' &&\n        typeof elm.decodeStream === 'function' &&\n        (elm.size === undefined || isNum(elm.size)));\n}\n// Coders (like in @scure/base) for common operations\n/**\n * Base coder for working with dictionaries (records, objects, key-value map)\n * Dictionary is dynamic type like: `[key: string, value: any][]`\n * @returns base coder that encodes/decodes between arrays of key-value tuples and dictionaries.\n * @example\n * const dict: P.CoderType<Record<string, number>> = P.apply(\n *  P.array(P.U16BE, P.tuple([P.cstring, P.U32LE] as const)),\n *  P.coders.dict()\n * );\n */\nfunction dict() {\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from))\n                throw new Error('array expected');\n            const to = {};\n            for (const item of from) {\n                if (!Array.isArray(item) || item.length !== 2)\n                    throw new Error(`array of two elements expected`);\n                const name = item[0];\n                const value = item[1];\n                if (to[name] !== undefined)\n                    throw new Error(`key(${name}) appears twice in struct`);\n                to[name] = value;\n            }\n            return to;\n        },\n        decode: (to) => {\n            if (!isPlainObject(to))\n                throw new Error(`expected plain object, got ${to}`);\n            return Object.entries(to);\n        },\n    };\n}\n/**\n * Safely converts bigint to number.\n * Sometimes pointers / tags use u64 or other big numbers which cannot be represented by number,\n * but we still can use them since real value will be smaller than u32\n */\nconst numberBigint = {\n    encode: (from) => {\n        if (typeof from !== 'bigint')\n            throw new Error(`expected bigint, got ${typeof from}`);\n        if (from > BigInt(Number.MAX_SAFE_INTEGER))\n            throw new Error(`element bigger than MAX_SAFE_INTEGER=${from}`);\n        return Number(from);\n    },\n    decode: (to) => {\n        if (!isNum(to))\n            throw new Error('element is not a safe integer');\n        return BigInt(to);\n    },\n};\n/**\n * Base coder for working with TypeScript enums.\n * @param e - TypeScript enum.\n * @returns base coder that encodes/decodes between numbers and enum keys.\n * @example\n * enum Color { Red, Green, Blue }\n * const colorCoder = P.coders.tsEnum(Color);\n * colorCoder.encode(Color.Red); // 'Red'\n * colorCoder.decode('Green'); // 1\n */\nfunction tsEnum(e) {\n    if (!isPlainObject(e))\n        throw new Error('plain object expected');\n    return {\n        encode: (from) => {\n            if (!isNum(from) || !(from in e))\n                throw new Error(`wrong value ${from}`);\n            return e[from];\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error(`wrong value ${typeof to}`);\n            return e[to];\n        },\n    };\n}\n/**\n * Base coder for working with decimal numbers.\n * @param precision - Number of decimal places.\n * @param round - Round fraction part if bigger than precision (throws error by default)\n * @returns base coder that encodes/decodes between bigints and decimal strings.\n * @example\n * const decimal8 = P.coders.decimal(8);\n * decimal8.encode(630880845n); // '6.30880845'\n * decimal8.decode('6.30880845'); // 630880845n\n */\nfunction decimal(precision, round = false) {\n    if (!isNum(precision))\n        throw new Error(`decimal/precision: wrong value ${precision}`);\n    if (typeof round !== 'boolean')\n        throw new Error(`decimal/round: expected boolean, got ${typeof round}`);\n    const decimalMask = 10n ** BigInt(precision);\n    return {\n        encode: (from) => {\n            if (typeof from !== 'bigint')\n                throw new Error(`expected bigint, got ${typeof from}`);\n            let s = (from < 0n ? -from : from).toString(10);\n            let sep = s.length - precision;\n            if (sep < 0) {\n                s = s.padStart(s.length - sep, '0');\n                sep = 0;\n            }\n            let i = s.length - 1;\n            for (; i >= sep && s[i] === '0'; i--)\n                ;\n            let int = s.slice(0, sep);\n            let frac = s.slice(sep, i + 1);\n            if (!int)\n                int = '0';\n            if (from < 0n)\n                int = '-' + int;\n            if (!frac)\n                return int;\n            return `${int}.${frac}`;\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error(`expected string, got ${typeof to}`);\n            if (to === '-0')\n                throw new Error(`negative zero is not allowed`);\n            let neg = false;\n            if (to.startsWith('-')) {\n                neg = true;\n                to = to.slice(1);\n            }\n            if (!/^(0|[1-9]\\d*)(\\.\\d+)?$/.test(to))\n                throw new Error(`wrong string value=${to}`);\n            let sep = to.indexOf('.');\n            sep = sep === -1 ? to.length : sep;\n            // split by separator and strip trailing zeros from fraction. always returns [string, string] (.split doesn't).\n            const intS = to.slice(0, sep);\n            const fracS = to.slice(sep + 1).replace(/0+$/, '');\n            const int = BigInt(intS) * decimalMask;\n            if (!round && fracS.length > precision) {\n                throw new Error(`fractional part cannot be represented with this precision (num=${to}, prec=${precision})`);\n            }\n            const fracLen = Math.min(fracS.length, precision);\n            const frac = BigInt(fracS.slice(0, fracLen)) * 10n ** BigInt(precision - fracLen);\n            const value = int + frac;\n            return neg ? -value : value;\n        },\n    };\n}\n/**\n * Combines multiple coders into a single coder, allowing conditional encoding/decoding based on input.\n * Acts as a parser combinator, splitting complex conditional coders into smaller parts.\n *\n *   `encode = [Ae, Be]; decode = [Ad, Bd]`\n *   ->\n *   `match([{encode: Ae, decode: Ad}, {encode: Be; decode: Bd}])`\n *\n * @param lst - Array of coders to match.\n * @returns Combined coder for conditional encoding/decoding.\n */\nfunction match(lst) {\n    if (!Array.isArray(lst))\n        throw new Error(`expected array, got ${typeof lst}`);\n    for (const i of lst)\n        if (!isBaseCoder(i))\n            throw new Error(`wrong base coder ${i}`);\n    return {\n        encode: (from) => {\n            for (const c of lst) {\n                const elm = c.encode(from);\n                if (elm !== undefined)\n                    return elm;\n            }\n            throw new Error(`match/encode: cannot find match in ${from}`);\n        },\n        decode: (to) => {\n            for (const c of lst) {\n                const elm = c.decode(to);\n                if (elm !== undefined)\n                    return elm;\n            }\n            throw new Error(`match/decode: cannot find match in ${to}`);\n        },\n    };\n}\n/** Reverses direction of coder */\nconst reverse = (coder) => {\n    if (!isBaseCoder(coder))\n        throw new Error('BaseCoder expected');\n    return { encode: coder.decode, decode: coder.encode };\n};\nexports.coders = { dict, numberBigint, tsEnum, decimal, match, reverse };\n/**\n * CoderType for parsing individual bits.\n * NOTE: Structure should parse whole amount of bytes before it can start parsing byte-level elements.\n * @param len - Number of bits to parse.\n * @returns CoderType representing the parsed bits.\n * @example\n * const s = P.struct({ magic: P.bits(1), version: P.bits(1), tag: P.bits(4), len: P.bits(2) });\n */\nconst bits = (len) => {\n    if (!isNum(len))\n        throw new Error(`bits: wrong length ${len} (${typeof len})`);\n    return (0, exports.wrap)({\n        encodeStream: (w, value) => w.bits(value, len),\n        decodeStream: (r) => r.bits(len),\n        validate: (value) => {\n            if (!isNum(value))\n                throw new Error(`bits: wrong value ${value}`);\n            return value;\n        },\n    });\n};\nexports.bits = bits;\n/**\n * CoderType for working with bigint values.\n * Unsized bigint values should be wrapped in a container (e.g., bytes or string).\n *\n * `0n = new Uint8Array([])`\n *\n * `1n = new Uint8Array([1n])`\n *\n * Please open issue, if you need different behavior for zero.\n *\n * @param size - Size of the bigint in bytes.\n * @param le - Whether to use little-endian byte order.\n * @param signed - Whether the bigint is signed.\n * @param sized - Whether the bigint should have a fixed size.\n * @returns CoderType representing the bigint value.\n * @example\n * const U512BE = P.bigint(64, false, true, true); // Define a CoderType for a 512-bit unsigned big-endian integer\n */\nconst bigint = (size, le = false, signed = false, sized = true) => {\n    if (!isNum(size))\n        throw new Error(`bigint/size: wrong value ${size}`);\n    if (typeof le !== 'boolean')\n        throw new Error(`bigint/le: expected boolean, got ${typeof le}`);\n    if (typeof signed !== 'boolean')\n        throw new Error(`bigint/signed: expected boolean, got ${typeof signed}`);\n    if (typeof sized !== 'boolean')\n        throw new Error(`bigint/sized: expected boolean, got ${typeof sized}`);\n    const bLen = BigInt(size);\n    const signBit = 2n ** (8n * bLen - 1n);\n    return (0, exports.wrap)({\n        size: sized ? size : undefined,\n        encodeStream: (w, value) => {\n            if (signed && value < 0)\n                value = value | signBit;\n            const b = [];\n            for (let i = 0; i < size; i++) {\n                b.push(Number(value & 255n));\n                value >>= 8n;\n            }\n            let res = new Uint8Array(b).reverse();\n            if (!sized) {\n                let pos = 0;\n                for (pos = 0; pos < res.length; pos++)\n                    if (res[pos] !== 0)\n                        break;\n                res = res.subarray(pos); // remove leading zeros\n            }\n            w.bytes(le ? res.reverse() : res);\n        },\n        decodeStream: (r) => {\n            // TODO: for le we can read until first zero?\n            const value = r.bytes(sized ? size : Math.min(size, r.leftBytes));\n            const b = le ? value : swapEndianness(value);\n            let res = 0n;\n            for (let i = 0; i < b.length; i++)\n                res |= BigInt(b[i]) << (8n * BigInt(i));\n            if (signed && res & signBit)\n                res = (res ^ signBit) - signBit;\n            return res;\n        },\n        validate: (value) => {\n            if (typeof value !== 'bigint')\n                throw new Error(`bigint: invalid value: ${value}`);\n            checkBounds(value, 8n * bLen, !!signed);\n            return value;\n        },\n    });\n};\nexports.bigint = bigint;\n/** Unsigned 256-bit little-endian integer CoderType. */\nexports.U256LE = (0, exports.bigint)(32, true);\n/** Unsigned 256-bit big-endian integer CoderType. */\nexports.U256BE = (0, exports.bigint)(32, false);\n/** Signed 256-bit little-endian integer CoderType. */\nexports.I256LE = (0, exports.bigint)(32, true, true);\n/** Signed 256-bit big-endian integer CoderType. */\nexports.I256BE = (0, exports.bigint)(32, false, true);\n/** Unsigned 128-bit little-endian integer CoderType. */\nexports.U128LE = (0, exports.bigint)(16, true);\n/** Unsigned 128-bit big-endian integer CoderType. */\nexports.U128BE = (0, exports.bigint)(16, false);\n/** Signed 128-bit little-endian integer CoderType. */\nexports.I128LE = (0, exports.bigint)(16, true, true);\n/** Signed 128-bit big-endian integer CoderType. */\nexports.I128BE = (0, exports.bigint)(16, false, true);\n/** Unsigned 64-bit little-endian integer CoderType. */\nexports.U64LE = (0, exports.bigint)(8, true);\n/** Unsigned 64-bit big-endian integer CoderType. */\nexports.U64BE = (0, exports.bigint)(8, false);\n/** Signed 64-bit little-endian integer CoderType. */\nexports.I64LE = (0, exports.bigint)(8, true, true);\n/** Signed 64-bit big-endian integer CoderType. */\nexports.I64BE = (0, exports.bigint)(8, false, true);\n/**\n * CoderType for working with numbber values (up to 6 bytes/48 bits).\n * Unsized int values should be wrapped in a container (e.g., bytes or string).\n *\n * `0 = new Uint8Array([])`\n *\n * `1 = new Uint8Array([1n])`\n *\n * Please open issue, if you need different behavior for zero.\n *\n * @param size - Size of the number in bytes.\n * @param le - Whether to use little-endian byte order.\n * @param signed - Whether the number is signed.\n * @param sized - Whether the number should have a fixed size.\n * @returns CoderType representing the number value.\n * @example\n * const uint64BE = P.bigint(8, false, true); // Define a CoderType for a 64-bit unsigned big-endian integer\n */\nconst int = (size, le = false, signed = false, sized = true) => {\n    if (!isNum(size))\n        throw new Error(`int/size: wrong value ${size}`);\n    if (typeof le !== 'boolean')\n        throw new Error(`int/le: expected boolean, got ${typeof le}`);\n    if (typeof signed !== 'boolean')\n        throw new Error(`int/signed: expected boolean, got ${typeof signed}`);\n    if (typeof sized !== 'boolean')\n        throw new Error(`int/sized: expected boolean, got ${typeof sized}`);\n    if (size > 6)\n        throw new Error('int supports size up to 6 bytes (48 bits): use bigints instead');\n    return apply((0, exports.bigint)(size, le, signed, sized), exports.coders.numberBigint);\n};\nexports.int = int;\nconst view = (len, opts) => (0, exports.wrap)({\n    size: len,\n    encodeStream: (w, value) => w.writeView(len, (view) => opts.write(view, value)),\n    decodeStream: (r) => r.readView(len, opts.read),\n    validate: (value) => {\n        if (typeof value !== 'number')\n            throw new Error(`viewCoder: expected number, got ${typeof value}`);\n        if (opts.validate)\n            opts.validate(value);\n        return value;\n    },\n});\nconst intView = (len, signed, opts) => {\n    const bits = len * 8;\n    const signBit = 2 ** (bits - 1);\n    // Inlined checkBounds for integer\n    const validateSigned = (value) => {\n        if (!isNum(value))\n            throw new Error(`sintView: value is not safe integer: ${value}`);\n        if (value < -signBit || value >= signBit) {\n            throw new Error(`sintView: value out of bounds. Expected ${-signBit} <= ${value} < ${signBit}`);\n        }\n    };\n    const maxVal = 2 ** bits;\n    const validateUnsigned = (value) => {\n        if (!isNum(value))\n            throw new Error(`uintView: value is not safe integer: ${value}`);\n        if (0 > value || value >= maxVal) {\n            throw new Error(`uintView: value out of bounds. Expected 0 <= ${value} < ${maxVal}`);\n        }\n    };\n    return view(len, {\n        write: opts.write,\n        read: opts.read,\n        validate: signed ? validateSigned : validateUnsigned,\n    });\n};\n/** Unsigned 32-bit little-endian integer CoderType. */\nexports.U32LE = intView(4, false, {\n    read: (view, pos) => view.getUint32(pos, true),\n    write: (view, value) => view.setUint32(0, value, true),\n});\n/** Unsigned 32-bit big-endian integer CoderType. */\nexports.U32BE = intView(4, false, {\n    read: (view, pos) => view.getUint32(pos, false),\n    write: (view, value) => view.setUint32(0, value, false),\n});\n/** Signed 32-bit little-endian integer CoderType. */\nexports.I32LE = intView(4, true, {\n    read: (view, pos) => view.getInt32(pos, true),\n    write: (view, value) => view.setInt32(0, value, true),\n});\n/** Signed 32-bit big-endian integer CoderType. */\nexports.I32BE = intView(4, true, {\n    read: (view, pos) => view.getInt32(pos, false),\n    write: (view, value) => view.setInt32(0, value, false),\n});\n/** Unsigned 16-bit little-endian integer CoderType. */\nexports.U16LE = intView(2, false, {\n    read: (view, pos) => view.getUint16(pos, true),\n    write: (view, value) => view.setUint16(0, value, true),\n});\n/** Unsigned 16-bit big-endian integer CoderType. */\nexports.U16BE = intView(2, false, {\n    read: (view, pos) => view.getUint16(pos, false),\n    write: (view, value) => view.setUint16(0, value, false),\n});\n/** Signed 16-bit little-endian integer CoderType. */\nexports.I16LE = intView(2, true, {\n    read: (view, pos) => view.getInt16(pos, true),\n    write: (view, value) => view.setInt16(0, value, true),\n});\n/** Signed 16-bit big-endian integer CoderType. */\nexports.I16BE = intView(2, true, {\n    read: (view, pos) => view.getInt16(pos, false),\n    write: (view, value) => view.setInt16(0, value, false),\n});\n/** Unsigned 8-bit integer CoderType. */\nexports.U8 = intView(1, false, {\n    read: (view, pos) => view.getUint8(pos),\n    write: (view, value) => view.setUint8(0, value),\n});\n/** Signed 8-bit integer CoderType. */\nexports.I8 = intView(1, true, {\n    read: (view, pos) => view.getInt8(pos),\n    write: (view, value) => view.setInt8(0, value),\n});\n// Floats\nconst f32 = (le) => view(4, {\n    read: (view, pos) => view.getFloat32(pos, le),\n    write: (view, value) => view.setFloat32(0, value, le),\n    validate: (value) => {\n        if (Math.fround(value) !== value && !Number.isNaN(value))\n            throw new Error(`f32: wrong value=${value}`);\n    },\n});\nconst f64 = (le) => view(8, {\n    read: (view, pos) => view.getFloat64(pos, le),\n    write: (view, value) => view.setFloat64(0, value, le),\n});\n/** 32-bit big-endian floating point CoderType (\"binary32\", IEEE 754-2008). */\nexports.F32BE = f32(false);\n/** 32-bit little-endian floating point  CoderType (\"binary32\", IEEE 754-2008). */\nexports.F32LE = f32(true);\n/** A 64-bit big-endian floating point type (\"binary64\", IEEE 754-2008). Any JS number can be encoded. */\nexports.F64BE = f64(false);\n/** A 64-bit little-endian floating point type (\"binary64\", IEEE 754-2008). Any JS number can be encoded. */\nexports.F64LE = f64(true);\n/** Boolean CoderType. */\nexports.bool = (0, exports.wrap)({\n    size: 1,\n    encodeStream: (w, value) => w.byte(value ? 1 : 0),\n    decodeStream: (r) => {\n        const value = r.byte();\n        if (value !== 0 && value !== 1)\n            throw r.err(`bool: invalid value ${value}`);\n        return value === 1;\n    },\n    validate: (value) => {\n        if (typeof value !== 'boolean')\n            throw new Error(`bool: invalid value ${value}`);\n        return value;\n    },\n});\n/**\n * Bytes CoderType with a specified length and endianness.\n * The bytes can have:\n * - Dynamic size (prefixed with a length CoderType like U16BE)\n * - Fixed size (specified by a number)\n * - Unknown size (null, will parse until end of buffer)\n * - Zero-terminated (terminator can be any Uint8Array)\n * @param len - CoderType, number, Uint8Array (terminator) or null\n * @param le - Whether to use little-endian byte order.\n * @returns CoderType representing the bytes.\n * @example\n * // Dynamic size bytes (prefixed with P.U16BE number of bytes length)\n * const dynamicBytes = P.bytes(P.U16BE, false);\n * const fixedBytes = P.bytes(32, false); // Fixed size bytes\n * const unknownBytes = P.bytes(null, false); // Unknown size bytes, will parse until end of buffer\n * const zeroTerminatedBytes = P.bytes(new Uint8Array([0]), false); // Zero-terminated bytes\n */\nconst createBytes = (len, le = false) => {\n    if (typeof le !== 'boolean')\n        throw new Error(`bytes/le: expected boolean, got ${typeof le}`);\n    const _length = lengthCoder(len);\n    const _isb = isBytes(len);\n    return (0, exports.wrap)({\n        size: typeof len === 'number' ? len : undefined,\n        encodeStream: (w, value) => {\n            if (!_isb)\n                _length.encodeStream(w, value.length);\n            w.bytes(le ? swapEndianness(value) : value);\n            if (_isb)\n                w.bytes(len);\n        },\n        decodeStream: (r) => {\n            let bytes;\n            if (_isb) {\n                const tPos = r.find(len);\n                if (!tPos)\n                    throw r.err(`bytes: cannot find terminator`);\n                bytes = r.bytes(tPos - r.pos);\n                r.bytes(len.length);\n            }\n            else {\n                bytes = r.bytes(len === null ? r.leftBytes : _length.decodeStream(r));\n            }\n            return le ? swapEndianness(bytes) : bytes;\n        },\n        validate: (value) => {\n            if (!isBytes(value))\n                throw new Error(`bytes: invalid value ${value}`);\n            return value;\n        },\n    });\n};\nexports.bytes = createBytes;\n/**\n * Prefix-encoded value using a length prefix and an inner CoderType.\n * The prefix can have:\n * - Dynamic size (prefixed with a length CoderType like U16BE)\n * - Fixed size (specified by a number)\n * - Unknown size (null, will parse until end of buffer)\n * - Zero-terminated (terminator can be any Uint8Array)\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param inner - CoderType for the actual value to be prefix-encoded.\n * @returns CoderType representing the prefix-encoded value.\n * @example\n * const dynamicPrefix = P.prefix(P.U16BE, P.bytes(null)); // Dynamic size prefix (prefixed with P.U16BE number of bytes length)\n * const fixedPrefix = P.prefix(10, P.bytes(null)); // Fixed size prefix (always 10 bytes)\n */\nfunction prefix(len, inner) {\n    if (!isCoder(inner))\n        throw new Error(`prefix: invalid inner value ${inner}`);\n    return apply(createBytes(len), reverse(inner));\n}\n/**\n * String CoderType with a specified length and endianness.\n * The string can be:\n * - Dynamic size (prefixed with a length CoderType like U16BE)\n * - Fixed size (specified by a number)\n * - Unknown size (null, will parse until end of buffer)\n * - Zero-terminated (terminator can be any Uint8Array)\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param le - Whether to use little-endian byte order.\n * @returns CoderType representing the string.\n * @example\n * const dynamicString = P.string(P.U16BE, false); // Dynamic size string (prefixed with P.U16BE number of string length)\n * const fixedString = P.string(10, false); // Fixed size string\n * const unknownString = P.string(null, false); // Unknown size string, will parse until end of buffer\n * const nullTerminatedString = P.cstring; // NUL-terminated string\n * const _cstring = P.string(new Uint8Array([0])); // Same thing\n */\nconst string = (len, le = false) => validate(apply(createBytes(len, le), base_1.utf8), (value) => {\n    // TextEncoder/TextDecoder will fail on non-string, but we create more readable errors earlier\n    if (typeof value !== 'string')\n        throw new Error(`expected string, got ${typeof value}`);\n    return value;\n});\nexports.string = string;\n/** NUL-terminated string CoderType. */\nexports.cstring = (0, exports.string)(exports.NULL);\n/**\n * Hexadecimal string CoderType with a specified length, endianness, and optional 0x prefix.\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param le - Whether to use little-endian byte order.\n * @param withZero - Whether to include the 0x prefix.\n * @returns CoderType representing the hexadecimal string.\n * @example\n * const dynamicHex = P.hex(P.U16BE, {isLE: false, with0x: true}); // Hex string with 0x prefix and U16BE length\n * const fixedHex = P.hex(32, {isLE: false, with0x: false}); // Fixed-length 32-byte hex string without 0x prefix\n */\nconst createHex = (len, options = { isLE: false, with0x: false }) => {\n    let inner = apply(createBytes(len, options.isLE), base_1.hex);\n    const prefix = options.with0x;\n    if (typeof prefix !== 'boolean')\n        throw new Error(`hex/with0x: expected boolean, got ${typeof prefix}`);\n    if (prefix) {\n        inner = apply(inner, {\n            encode: (value) => `0x${value}`,\n            decode: (value) => {\n                if (!value.startsWith('0x'))\n                    throw new Error('hex(with0x=true).encode input should start with 0x');\n                return value.slice(2);\n            },\n        });\n    }\n    return inner;\n};\nexports.hex = createHex;\n/**\n * Applies a base coder to a CoderType.\n * @param inner - The inner CoderType.\n * @param b - The base coder to apply.\n * @returns CoderType representing the transformed value.\n * @example\n * import { hex } from '@scure/base';\n * const hex = P.apply(P.bytes(32), hex); // will decode bytes into a hex string\n */\nfunction apply(inner, base) {\n    if (!isCoder(inner))\n        throw new Error(`apply: invalid inner value ${inner}`);\n    if (!isBaseCoder(base))\n        throw new Error(`apply: invalid base value ${inner}`);\n    return (0, exports.wrap)({\n        size: inner.size,\n        encodeStream: (w, value) => {\n            let innerValue;\n            try {\n                innerValue = base.decode(value);\n            }\n            catch (e) {\n                throw w.err('' + e);\n            }\n            return inner.encodeStream(w, innerValue);\n        },\n        decodeStream: (r) => {\n            const innerValue = inner.decodeStream(r);\n            try {\n                return base.encode(innerValue);\n            }\n            catch (e) {\n                throw r.err('' + e);\n            }\n        },\n    });\n}\n/**\n * Lazy CoderType that is evaluated at runtime.\n * @param fn - A function that returns the CoderType.\n * @returns CoderType representing the lazy value.\n * @example\n * type Tree = { name: string; children: Tree[] };\n * const tree = P.struct({\n *   name: P.cstring,\n *   children: P.array(\n *     P.U16BE,\n *     P.lazy((): P.CoderType<Tree> => tree)\n *   ),\n * });\n */\nfunction lazy(fn) {\n    if (typeof fn !== 'function')\n        throw new Error(`lazy: expected function, got ${typeof fn}`);\n    return (0, exports.wrap)({\n        encodeStream: (w, value) => fn().encodeStream(w, value),\n        decodeStream: (r) => fn().decodeStream(r),\n    });\n}\n/**\n * Flag CoderType that encodes/decodes a boolean value based on the presence of a marker.\n * @param flagValue - Marker value.\n * @param xor - Whether to invert the flag behavior.\n * @returns CoderType representing the flag value.\n * @example\n * const flag = P.flag(new Uint8Array([0x01, 0x02])); // Encodes true as u8a([0x01, 0x02]), false as u8a([])\n * const flagXor = P.flag(new Uint8Array([0x01, 0x02]), true); // Encodes true as u8a([]), false as u8a([0x01, 0x02])\n * // Conditional encoding with flagged\n * const s = P.struct({ f: P.flag(new Uint8Array([0x0, 0x1])), f2: P.flagged('f', P.U32BE) });\n */\nconst flag = (flagValue, xor = false) => {\n    if (!isBytes(flagValue))\n        throw new Error(`flag/flagValue: expected Uint8Array, got ${typeof flagValue}`);\n    if (typeof xor !== 'boolean')\n        throw new Error(`flag/xor: expected boolean, got ${typeof xor}`);\n    return (0, exports.wrap)({\n        size: flagValue.length,\n        encodeStream: (w, value) => {\n            if (!!value !== xor)\n                w.bytes(flagValue);\n        },\n        decodeStream: (r) => {\n            let hasFlag = r.leftBytes >= flagValue.length;\n            if (hasFlag) {\n                hasFlag = equalBytes(r.bytes(flagValue.length, true), flagValue);\n                // Found flag, advance cursor position\n                if (hasFlag)\n                    r.bytes(flagValue.length);\n            }\n            return hasFlag !== xor; // hasFlag ^ xor\n        },\n        validate: (value) => {\n            if (value !== undefined && typeof value !== 'boolean')\n                throw new Error(`flag: expected boolean value or undefined, got ${typeof value}`);\n            return value;\n        },\n    });\n};\nexports.flag = flag;\n/**\n * Conditional CoderType that encodes/decodes a value only if a flag is present.\n * @param path - Path to the flag value or a CoderType for the flag.\n * @param inner - Inner CoderType for the value.\n * @param def - Optional default value to use if the flag is not present.\n * @returns CoderType representing the conditional value.\n * @example\n * const s = P.struct({\n *   f: P.flag(new Uint8Array([0x0, 0x1])),\n *   f2: P.flagged('f', P.U32BE)\n * });\n *\n * @example\n * const s2 = P.struct({\n *   f: P.flag(new Uint8Array([0x0, 0x1])),\n *   f2: P.flagged('f', P.U32BE, 123)\n * });\n */\nfunction flagged(path, inner, def) {\n    if (!isCoder(inner))\n        throw new Error(`flagged: invalid inner value ${inner}`);\n    if (typeof path !== 'string' && !isCoder(inner))\n        throw new Error(`flagged: wrong path=${path}`);\n    return (0, exports.wrap)({\n        encodeStream: (w, value) => {\n            if (typeof path === 'string') {\n                if (Path.resolve(w.stack, path))\n                    inner.encodeStream(w, value);\n                else if (def)\n                    inner.encodeStream(w, def);\n            }\n            else {\n                path.encodeStream(w, !!value);\n                if (!!value)\n                    inner.encodeStream(w, value);\n                else if (def)\n                    inner.encodeStream(w, def);\n            }\n        },\n        decodeStream: (r) => {\n            let hasFlag = false;\n            if (typeof path === 'string')\n                hasFlag = !!Path.resolve(r.stack, path);\n            else\n                hasFlag = path.decodeStream(r);\n            // If there is a flag -- decode and return value\n            if (hasFlag)\n                return inner.decodeStream(r);\n            else if (def)\n                inner.decodeStream(r);\n            return;\n        },\n    });\n}\n/**\n * Optional CoderType that encodes/decodes a value based on a flag.\n * @param flag - CoderType for the flag value.\n * @param inner - Inner CoderType for the value.\n * @param def - Optional default value to use if the flag is not present.\n * @returns CoderType representing the optional value.\n * @example\n * // Will decode into P.U32BE only if flag present\n * const optional = P.optional(P.flag(new Uint8Array([0x0, 0x1])), P.U32BE);\n *\n * @example\n * // If no flag present, will decode into default value\n * const optionalWithDefault = P.optional(P.flag(new Uint8Array([0x0, 0x1])), P.U32BE, 123);\n */\nfunction optional(flag, inner, def) {\n    if (!isCoder(flag) || !isCoder(inner))\n        throw new Error(`optional: invalid flag or inner value flag=${flag} inner=${inner}`);\n    return (0, exports.wrap)({\n        size: def !== undefined && flag.size && inner.size ? flag.size + inner.size : undefined,\n        encodeStream: (w, value) => {\n            flag.encodeStream(w, !!value);\n            if (value)\n                inner.encodeStream(w, value);\n            else if (def !== undefined)\n                inner.encodeStream(w, def);\n        },\n        decodeStream: (r) => {\n            if (flag.decodeStream(r))\n                return inner.decodeStream(r);\n            else if (def !== undefined)\n                inner.decodeStream(r);\n            return;\n        },\n    });\n}\n/**\n * Magic value CoderType that encodes/decodes a constant value.\n * This can be used to check for a specific magic value or sequence of bytes at the beginning of a data structure.\n * @param inner - Inner CoderType for the value.\n * @param constant - Constant value.\n * @param check - Whether to check the decoded value against the constant.\n * @returns CoderType representing the magic value.\n * @example\n * // Always encodes constant as bytes using inner CoderType, throws if encoded value is not present\n * const magicU8 = P.magic(P.U8, 0x42);\n */\nfunction magic(inner, constant, check = true) {\n    if (!isCoder(inner))\n        throw new Error(`magic: invalid inner value ${inner}`);\n    if (typeof check !== 'boolean')\n        throw new Error(`magic: expected boolean, got ${typeof check}`);\n    return (0, exports.wrap)({\n        size: inner.size,\n        encodeStream: (w, _value) => inner.encodeStream(w, constant),\n        decodeStream: (r) => {\n            const value = inner.decodeStream(r);\n            if ((check && typeof value !== 'object' && value !== constant) ||\n                (isBytes(constant) && !equalBytes(constant, value))) {\n                throw r.err(`magic: invalid value: ${value} !== ${constant}`);\n            }\n            return;\n        },\n        validate: (value) => {\n            if (value !== undefined)\n                throw new Error(`magic: wrong value=${typeof value}`);\n            return value;\n        },\n    });\n}\n/**\n * Magic bytes CoderType that encodes/decodes a constant byte array or string.\n * @param constant - Constant byte array or string.\n * @returns CoderType representing the magic bytes.\n * @example\n * // Always encodes undefined into byte representation of string 'MAGIC'\n * const magicBytes = P.magicBytes('MAGIC');\n */\nconst magicBytes = (constant) => {\n    const c = typeof constant === 'string' ? base_1.utf8.decode(constant) : constant;\n    return magic(createBytes(c.length), c);\n};\nexports.magicBytes = magicBytes;\n/**\n * Creates a CoderType for a constant value. The function enforces this value during encoding,\n * ensuring it matches the provided constant. During decoding, it always returns the constant value.\n * The actual value is not written to or read from any byte stream; it's used only for validation.\n *\n * @param c - Constant value.\n * @returns CoderType representing the constant value.\n * @example\n * // Always return 123 on decode, throws on encoding anything other than 123\n * const constantU8 = P.constant(123);\n */\nfunction constant(c) {\n    return (0, exports.wrap)({\n        encodeStream: (_w, value) => {\n            if (value !== c)\n                throw new Error(`constant: invalid value ${value} (exp: ${c})`);\n        },\n        decodeStream: (_r) => c,\n    });\n}\nfunction sizeof(fields) {\n    let size = 0;\n    for (const f of fields) {\n        if (f.size === undefined)\n            return;\n        if (!isNum(f.size))\n            throw new Error(`sizeof: wrong element size=${size}`);\n        size += f.size;\n    }\n    return size;\n}\n/**\n * Structure of composable primitives (C/Rust struct)\n * @param fields - Object mapping field names to CoderTypes.\n * @returns CoderType representing the structure.\n * @example\n * // Define a structure with a 32-bit big-endian unsigned integer, a string, and a nested structure\n * const myStruct = P.struct({\n *   id: P.U32BE,\n *   name: P.string(P.U8),\n *   nested: P.struct({\n *     flag: P.bool,\n *     value: P.I16LE\n *   })\n * });\n */\nfunction struct(fields) {\n    if (!isPlainObject(fields))\n        throw new Error(`struct: expected plain object, got ${fields}`);\n    for (const name in fields) {\n        if (!isCoder(fields[name]))\n            throw new Error(`struct: field ${name} is not CoderType`);\n    }\n    return (0, exports.wrap)({\n        size: sizeof(Object.values(fields)),\n        encodeStream: (w, value) => {\n            w.pushObj(value, (fieldFn) => {\n                for (const name in fields)\n                    fieldFn(name, () => fields[name].encodeStream(w, value[name]));\n            });\n        },\n        decodeStream: (r) => {\n            const res = {};\n            r.pushObj(res, (fieldFn) => {\n                for (const name in fields)\n                    fieldFn(name, () => (res[name] = fields[name].decodeStream(r)));\n            });\n            return res;\n        },\n        validate: (value) => {\n            if (typeof value !== 'object' || value === null)\n                throw new Error(`struct: invalid value ${value}`);\n            return value;\n        },\n    });\n}\n/**\n * Tuple (unnamed structure) of CoderTypes. Same as struct but with unnamed fields.\n * @param fields - Array of CoderTypes.\n * @returns CoderType representing the tuple.\n * @example\n * const myTuple = P.tuple([P.U8, P.U16LE, P.string(P.U8)]);\n */\nfunction tuple(fields) {\n    if (!Array.isArray(fields))\n        throw new Error(`Packed.Tuple: got ${typeof fields} instead of array`);\n    for (let i = 0; i < fields.length; i++) {\n        if (!isCoder(fields[i]))\n            throw new Error(`tuple: field ${i} is not CoderType`);\n    }\n    return (0, exports.wrap)({\n        size: sizeof(fields),\n        encodeStream: (w, value) => {\n            // TODO: fix types\n            if (!Array.isArray(value))\n                throw w.err(`tuple: invalid value ${value}`);\n            w.pushObj(value, (fieldFn) => {\n                for (let i = 0; i < fields.length; i++)\n                    fieldFn(`${i}`, () => fields[i].encodeStream(w, value[i]));\n            });\n        },\n        decodeStream: (r) => {\n            const res = [];\n            r.pushObj(res, (fieldFn) => {\n                for (let i = 0; i < fields.length; i++)\n                    fieldFn(`${i}`, () => res.push(fields[i].decodeStream(r)));\n            });\n            return res;\n        },\n        validate: (value) => {\n            if (!Array.isArray(value))\n                throw new Error(`tuple: invalid value ${value}`);\n            if (value.length !== fields.length)\n                throw new Error(`tuple: wrong length=${value.length}, expected ${fields.length}`);\n            return value;\n        },\n    });\n}\n/**\n * Array of items (inner type) with a specified length.\n * @param len - Length CoderType (dynamic size), number (fixed size), Uint8Array (for terminator), or null (will parse until end of buffer)\n * @param inner - CoderType for encoding/decoding each array item.\n * @returns CoderType representing the array.\n * @example\n * const a1 = P.array(P.U16BE, child); // Dynamic size array (prefixed with P.U16BE number of array length)\n * const a2 = P.array(4, child); // Fixed size array\n * const a3 = P.array(null, child); // Unknown size array, will parse until end of buffer\n * const a4 = P.array(new Uint8Array([0]), child); // zero-terminated array (NOTE: terminator can be any buffer)\n */\nfunction array(len, inner) {\n    if (!isCoder(inner))\n        throw new Error(`array: invalid inner value ${inner}`);\n    // By construction length is inside array (otherwise there will be various incorrect stack states)\n    // But forcing users always write '..' seems like bad idea. Also, breaking change.\n    const _length = lengthCoder(typeof len === 'string' ? `../${len}` : len);\n    return (0, exports.wrap)({\n        size: typeof len === 'number' && inner.size ? len * inner.size : undefined,\n        encodeStream: (w, value) => {\n            const _w = w;\n            _w.pushObj(value, (fieldFn) => {\n                if (!isBytes(len))\n                    _length.encodeStream(w, value.length);\n                for (let i = 0; i < value.length; i++) {\n                    fieldFn(`${i}`, () => {\n                        const elm = value[i];\n                        const startPos = w.pos;\n                        inner.encodeStream(w, elm);\n                        if (isBytes(len)) {\n                            // Terminator is bigger than elm size, so skip\n                            if (len.length > _w.pos - startPos)\n                                return;\n                            const data = _w.finish(false).subarray(startPos, _w.pos);\n                            // There is still possible case when multiple elements create terminator,\n                            // but it is hard to catch here, will be very slow\n                            if (equalBytes(data.subarray(0, len.length), len))\n                                throw _w.err(`array: inner element encoding same as separator. elm=${elm} data=${data}`);\n                        }\n                    });\n                }\n            });\n            if (isBytes(len))\n                w.bytes(len);\n        },\n        decodeStream: (r) => {\n            const res = [];\n            r.pushObj(res, (fieldFn) => {\n                if (len === null) {\n                    for (let i = 0; !r.isEnd(); i++) {\n                        fieldFn(`${i}`, () => res.push(inner.decodeStream(r)));\n                        if (inner.size && r.leftBytes < inner.size)\n                            break;\n                    }\n                }\n                else if (isBytes(len)) {\n                    for (let i = 0;; i++) {\n                        if (equalBytes(r.bytes(len.length, true), len)) {\n                            // Advance cursor position if terminator found\n                            r.bytes(len.length);\n                            break;\n                        }\n                        fieldFn(`${i}`, () => res.push(inner.decodeStream(r)));\n                    }\n                }\n                else {\n                    let length;\n                    fieldFn('arrayLen', () => (length = _length.decodeStream(r)));\n                    for (let i = 0; i < length; i++)\n                        fieldFn(`${i}`, () => res.push(inner.decodeStream(r)));\n                }\n            });\n            return res;\n        },\n        validate: (value) => {\n            if (!Array.isArray(value))\n                throw new Error(`array: invalid value ${value}`);\n            return value;\n        },\n    });\n}\n/**\n * Mapping between encoded values and string representations.\n * @param inner - CoderType for encoded values.\n * @param variants - Object mapping string representations to encoded values.\n * @returns CoderType representing the mapping.\n * @example\n * // Map between numbers and strings\n * const numberMap = P.map(P.U8, {\n *   'one': 1,\n *   'two': 2,\n *   'three': 3\n * });\n *\n * // Map between byte arrays and strings\n * const byteMap = P.map(P.bytes(2, false), {\n *   'ab': Uint8Array.from([0x61, 0x62]),\n *   'cd': Uint8Array.from([0x63, 0x64])\n * });\n */\nfunction map(inner, variants) {\n    if (!isCoder(inner))\n        throw new Error(`map: invalid inner value ${inner}`);\n    if (!isPlainObject(variants))\n        throw new Error(`map: variants should be plain object`);\n    const variantNames = new Map();\n    for (const k in variants)\n        variantNames.set(variants[k], k);\n    return (0, exports.wrap)({\n        size: inner.size,\n        encodeStream: (w, value) => inner.encodeStream(w, variants[value]),\n        decodeStream: (r) => {\n            const variant = inner.decodeStream(r);\n            const name = variantNames.get(variant);\n            if (name === undefined)\n                throw r.err(`Enum: unknown value: ${variant} ${Array.from(variantNames.keys())}`);\n            return name;\n        },\n        validate: (value) => {\n            if (typeof value !== 'string')\n                throw new Error(`map: invalid value ${value}`);\n            if (!(value in variants))\n                throw new Error(`Map: unknown variant: ${value}`);\n            return value;\n        },\n    });\n}\n/**\n * Tagged union of CoderTypes, where the tag value determines which CoderType to use.\n * The decoded value will have the structure `{ TAG: number, data: ... }`.\n * @param tag - CoderType for the tag value.\n * @param variants - Object mapping tag values to CoderTypes.\n * @returns CoderType representing the tagged union.\n * @example\n * // Tagged union of array, string, and number\n * // Depending on the value of the first byte, it will be decoded as an array, string, or number.\n * const taggedUnion = P.tag(P.U8, {\n *   0x01: P.array(P.U16LE, P.U8),\n *   0x02: P.string(P.U8),\n *   0x03: P.U32BE\n * });\n *\n * const encoded = taggedUnion.encode({ TAG: 0x01, data: 'hello' }); // Encodes the string 'hello' with tag 0x01\n * const decoded = taggedUnion.decode(encoded); // Decodes the encoded value back to { TAG: 0x01, data: 'hello' }\n */\nfunction tag(tag, variants) {\n    if (!isCoder(tag))\n        throw new Error(`tag: invalid tag value ${tag}`);\n    if (!isPlainObject(variants))\n        throw new Error(`tag: variants should be plain object`);\n    for (const name in variants) {\n        if (!isCoder(variants[name]))\n            throw new Error(`tag: variant ${name} is not CoderType`);\n    }\n    return (0, exports.wrap)({\n        size: tag.size,\n        encodeStream: (w, value) => {\n            const { TAG, data } = value;\n            const dataType = variants[TAG];\n            tag.encodeStream(w, TAG);\n            dataType.encodeStream(w, data);\n        },\n        decodeStream: (r) => {\n            const TAG = tag.decodeStream(r);\n            const dataType = variants[TAG];\n            if (!dataType)\n                throw r.err(`Tag: invalid tag ${TAG}`);\n            return { TAG, data: dataType.decodeStream(r) };\n        },\n        validate: (value) => {\n            const { TAG } = value;\n            const dataType = variants[TAG];\n            if (!dataType)\n                throw new Error(`Tag: invalid tag ${TAG.toString()}`);\n            return value;\n        },\n    });\n}\n/**\n * Mapping between encoded values, string representations, and CoderTypes using a tag CoderType.\n * @param tagCoder - CoderType for the tag value.\n * @param variants - Object mapping string representations to [tag value, CoderType] pairs.\n *  * @returns CoderType representing the mapping.\n * @example\n * const cborValue: P.CoderType<CborValue> = P.mappedTag(P.bits(3), {\n *   uint: [0, cborUint], // An unsigned integer in the range 0..264-1 inclusive.\n *   negint: [1, cborNegint], // A negative integer in the range -264..-1 inclusive\n *   bytes: [2, P.lazy(() => cborLength(P.bytes, cborValue))], // A byte string.\n *   string: [3, P.lazy(() => cborLength(P.string, cborValue))], // A text string (utf8)\n *   array: [4, cborArrLength(P.lazy(() => cborValue))], // An array of data items\n *   map: [5, P.lazy(() => cborArrLength(P.tuple([cborValue, cborValue])))], // A map of pairs of data items\n *   tag: [6, P.tuple([cborUint, P.lazy(() => cborValue)] as const)], // A tagged data item (\"tag\") whose tag number\n *   simple: [7, cborSimple], // Floating-point numbers and simple values, as well as the \"break\" stop code\n * });\n */\nfunction mappedTag(tagCoder, variants) {\n    if (!isCoder(tagCoder))\n        throw new Error(`mappedTag: invalid tag value ${tag}`);\n    if (!isPlainObject(variants))\n        throw new Error(`mappedTag: variants should be plain object`);\n    const mapValue = {};\n    const tagValue = {};\n    for (const key in variants) {\n        const v = variants[key];\n        mapValue[key] = v[0];\n        tagValue[key] = v[1];\n    }\n    return tag(map(tagCoder, mapValue), tagValue);\n}\n/**\n * Bitset of boolean values with optional padding.\n * @param names - An array of string names for the bitset values.\n * @param pad - Whether to pad the bitset to a multiple of 8 bits.\n * @returns CoderType representing the bitset.\n * @template Names\n * @example\n * const myBitset = P.bitset(['flag1', 'flag2', 'flag3', 'flag4'], true);\n */\nfunction bitset(names, pad = false) {\n    if (typeof pad !== 'boolean')\n        throw new Error(`bitset/pad: expected boolean, got ${typeof pad}`);\n    if (!Array.isArray(names))\n        throw new Error('bitset/names: expected array');\n    for (const name of names) {\n        if (typeof name !== 'string')\n            throw new Error('bitset/names: expected array of strings');\n    }\n    return (0, exports.wrap)({\n        encodeStream: (w, value) => {\n            for (let i = 0; i < names.length; i++)\n                w.bits(+value[names[i]], 1);\n            if (pad && names.length % 8)\n                w.bits(0, 8 - (names.length % 8));\n        },\n        decodeStream: (r) => {\n            const out = {};\n            for (let i = 0; i < names.length; i++)\n                out[names[i]] = !!r.bits(1);\n            if (pad && names.length % 8)\n                r.bits(8 - (names.length % 8));\n            return out;\n        },\n        validate: (value) => {\n            if (!isPlainObject(value))\n                throw new Error(`bitset: invalid value ${value}`);\n            for (const v of Object.values(value)) {\n                if (typeof v !== 'boolean')\n                    throw new Error('expected boolean');\n            }\n            return value;\n        },\n    });\n}\n/** Padding function which always returns zero */\nconst ZeroPad = (_) => 0;\nexports.ZeroPad = ZeroPad;\nfunction padLength(blockSize, len) {\n    if (len % blockSize === 0)\n        return 0;\n    return blockSize - (len % blockSize);\n}\n/**\n * Pads a CoderType with a specified block size and padding function on the left side.\n * @param blockSize - Block size for padding (positive safe integer).\n * @param inner - Inner CoderType to pad.\n * @param padFn - Padding function to use. If not provided, zero padding is used.\n * @returns CoderType representing the padded value.\n * @example\n * // Pad a U32BE with a block size of 4 and zero padding\n * const paddedU32BE = P.padLeft(4, P.U32BE);\n *\n * // Pad a string with a block size of 16 and custom padding\n * const paddedString = P.padLeft(16, P.string(P.U8), (i) => i + 1);\n */\nfunction padLeft(blockSize, inner, padFn) {\n    if (!isNum(blockSize) || blockSize <= 0)\n        throw new Error(`padLeft: wrong blockSize=${blockSize}`);\n    if (!isCoder(inner))\n        throw new Error(`padLeft: invalid inner value ${inner}`);\n    if (padFn !== undefined && typeof padFn !== 'function')\n        throw new Error(`padLeft: wrong padFn=${typeof padFn}`);\n    const _padFn = padFn || exports.ZeroPad;\n    if (!inner.size)\n        throw new Error('padLeft cannot have dynamic size');\n    return (0, exports.wrap)({\n        size: inner.size + padLength(blockSize, inner.size),\n        encodeStream: (w, value) => {\n            const padBytes = padLength(blockSize, inner.size);\n            for (let i = 0; i < padBytes; i++)\n                w.byte(_padFn(i));\n            inner.encodeStream(w, value);\n        },\n        decodeStream: (r) => {\n            r.bytes(padLength(blockSize, inner.size));\n            return inner.decodeStream(r);\n        },\n    });\n}\n/**\n * Pads a CoderType with a specified block size and padding function on the right side.\n * @param blockSize - Block size for padding (positive safe integer).\n * @param inner - Inner CoderType to pad.\n * @param padFn - Padding function to use. If not provided, zero padding is used.\n * @returns CoderType representing the padded value.\n * @example\n * // Pad a U16BE with a block size of 2 and zero padding\n * const paddedU16BE = P.padRight(2, P.U16BE);\n *\n * // Pad a bytes with a block size of 8 and custom padding\n * const paddedBytes = P.padRight(8, P.bytes(null), (i) => i + 1);\n */\nfunction padRight(blockSize, inner, padFn) {\n    if (!isCoder(inner))\n        throw new Error(`padRight: invalid inner value ${inner}`);\n    if (!isNum(blockSize) || blockSize <= 0)\n        throw new Error(`padLeft: wrong blockSize=${blockSize}`);\n    if (padFn !== undefined && typeof padFn !== 'function')\n        throw new Error(`padRight: wrong padFn=${typeof padFn}`);\n    const _padFn = padFn || exports.ZeroPad;\n    return (0, exports.wrap)({\n        size: inner.size ? inner.size + padLength(blockSize, inner.size) : undefined,\n        encodeStream: (w, value) => {\n            const _w = w;\n            const pos = _w.pos;\n            inner.encodeStream(w, value);\n            const padBytes = padLength(blockSize, _w.pos - pos);\n            for (let i = 0; i < padBytes; i++)\n                w.byte(_padFn(i));\n        },\n        decodeStream: (r) => {\n            const start = r.pos;\n            const res = inner.decodeStream(r);\n            r.bytes(padLength(blockSize, r.pos - start));\n            return res;\n        },\n    });\n}\n1;\n/**\n * Pointer to a value using a pointer CoderType and an inner CoderType.\n * Pointers are scoped, and the next pointer in the dereference chain is offset by the previous one.\n * By default (if no 'allowMultipleReads' in ReaderOpts is set) is safe, since\n * same region of memory cannot be read multiple times.\n * @param ptr - CoderType for the pointer value.\n * @param inner - CoderType for encoding/decoding the pointed value.\n * @param sized - Whether the pointer should have a fixed size.\n * @returns CoderType representing the pointer to the value.\n * @example\n * const pointerToU8 = P.pointer(P.U16BE, P.U8); // Pointer to a single U8 value\n */\nfunction pointer(ptr, inner, sized = false) {\n    if (!isCoder(ptr))\n        throw new Error(`pointer: invalid ptr value ${ptr}`);\n    if (!isCoder(inner))\n        throw new Error(`pointer: invalid inner value ${inner}`);\n    if (typeof sized !== 'boolean')\n        throw new Error(`pointer/sized: expected boolean, got ${typeof sized}`);\n    if (!ptr.size)\n        throw new Error('unsized pointer');\n    return (0, exports.wrap)({\n        size: sized ? ptr.size : undefined,\n        encodeStream: (w, value) => {\n            const _w = w;\n            const start = _w.pos;\n            ptr.encodeStream(w, 0);\n            _w.ptrs.push({ pos: start, ptr, buffer: inner.encode(value) });\n        },\n        decodeStream: (r) => {\n            const ptrVal = ptr.decodeStream(r);\n            r._enablePointers();\n            return inner.decodeStream(r.offsetReader(ptrVal));\n        },\n    });\n}\n// Internal methods for test purposes only\nexports._TEST = { _bitset: Bitset, _Reader, _Writer, Path };\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ArkSDK/./node_modules/micro-packed/lib/index.js?\n}")},"./webpack-entry.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('{// Webpack entry point to export Ark SDK modules for browser use\nconst { DefaultVtxo, ArkAddress, RestArkProvider } = __webpack_require__(/*! @arkade-os/sdk */ "./node_modules/@arkade-os/sdk/dist/cjs/index.js");\n\n// Export modules directly - webpack will handle the library creation\nmodule.exports = {\n    DefaultVtxo,\n    ArkAddress,\n    RestArkProvider\n};\n\n//# sourceURL=webpack://ArkSDK/./webpack-entry.js?\n}')}},__webpack_module_cache__={};function __webpack_require__(n){var e=__webpack_module_cache__[n];if(void 0!==e)return e.exports;var t=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n].call(t.exports,t,t.exports,__webpack_require__),t.exports}__webpack_require__.d=(n,e)=>{for(var t in e)__webpack_require__.o(e,t)&&!__webpack_require__.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})},__webpack_require__.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./webpack-entry.js");return __webpack_exports__})());